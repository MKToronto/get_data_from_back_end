
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root.host) {
            return root;
        }
        return document;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.40.3' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }
    function quadIn(t) {
        return t * t;
    }
    function quadOut(t) {
        return -t * (t - 2.0);
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => 'overflow: hidden;' +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }
    function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const sd = 1 - start;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
        };
    }

    function isObject(value) {
      const type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    function getColumnSizeClass(isXs, colWidth, colSize) {
      if (colSize === true || colSize === '') {
        return isXs ? 'col' : `col-${colWidth}`;
      } else if (colSize === 'auto') {
        return isXs ? 'col-auto' : `col-${colWidth}-auto`;
      }

      return isXs ? `col-${colSize}` : `col-${colWidth}-${colSize}`;
    }

    function toClassName(value) {
      let result = '';

      if (typeof value === 'string' || typeof value === 'number') {
        result += value;
      } else if (typeof value === 'object') {
        if (Array.isArray(value)) {
          result = value.map(toClassName).filter(Boolean).join(' ');
        } else {
          for (let key in value) {
            if (value[key]) {
              result && (result += ' ');
              result += key;
            }
          }
        }
      }

      return result;
    }

    function classnames(...args) {
      return args.map(toClassName).filter(Boolean).join(' ');
    }

    /* node_modules/sveltestrap/src/Badge.svelte generated by Svelte v3.40.3 */
    const file$X = "node_modules/sveltestrap/src/Badge.svelte";

    // (27:0) {:else}
    function create_else_block_1$4(ctx) {
    	let span;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block_2$c, create_else_block_2$4];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*children*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let span_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			set_attributes(span, span_data);
    			add_location(span, file$X, 27, 2, 501);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_blocks[current_block_type_index].m(span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(span, null);
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(27:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:0) {#if href}
    function create_if_block$x(ctx) {
    	let a;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block_1$k, create_else_block$f];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*children*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let a_levels = [
    		/*$$restProps*/ ctx[3],
    		{ href: /*href*/ ctx[1] },
    		{ class: /*classes*/ ctx[2] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if_block.c();
    			set_attributes(a, a_data);
    			add_location(a, file$X, 19, 2, 367);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if_blocks[current_block_type_index].m(a, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(a, null);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*href*/ 2) && { href: /*href*/ ctx[1] },
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(19:0) {#if href}",
    		ctx
    	});

    	return block;
    }

    // (31:4) {:else}
    function create_else_block_2$4(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$4.name,
    		type: "else",
    		source: "(31:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (29:4) {#if children}
    function create_if_block_2$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*children*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(29:4) {#if children}",
    		ctx
    	});

    	return block;
    }

    // (23:4) {:else}
    function create_else_block$f(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(23:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:4) {#if children}
    function create_if_block_1$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*children*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(21:4) {#if children}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$13(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$x, create_else_block_1$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","children","color","href","pill"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Badge', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { children = undefined } = $$props;
    	let { color = 'secondary' } = $$props;
    	let { href = undefined } = $$props;
    	let { pill = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('children' in $$new_props) $$invalidate(0, children = $$new_props.children);
    		if ('color' in $$new_props) $$invalidate(5, color = $$new_props.color);
    		if ('href' in $$new_props) $$invalidate(1, href = $$new_props.href);
    		if ('pill' in $$new_props) $$invalidate(6, pill = $$new_props.pill);
    		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		children,
    		color,
    		href,
    		pill,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('children' in $$props) $$invalidate(0, children = $$new_props.children);
    		if ('color' in $$props) $$invalidate(5, color = $$new_props.color);
    		if ('href' in $$props) $$invalidate(1, href = $$new_props.href);
    		if ('pill' in $$props) $$invalidate(6, pill = $$new_props.pill);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, color, pill*/ 112) {
    			$$invalidate(2, classes = classnames(className, 'badge', `badge-${color}`, pill ? 'badge-pill' : false));
    		}
    	};

    	return [children, href, classes, $$restProps, className, color, pill, $$scope, slots];
    }

    class Badge extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$13, create_fragment$13, safe_not_equal, {
    			class: 4,
    			children: 0,
    			color: 5,
    			href: 1,
    			pill: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Badge",
    			options,
    			id: create_fragment$13.name
    		});
    	}

    	get class() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get children() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set children(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pill() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pill(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Button.svelte generated by Svelte v3.40.3 */
    const file$W = "node_modules/sveltestrap/src/Button.svelte";

    // (48:0) {:else}
    function create_else_block_1$3(ctx) {
    	let button;
    	let button_aria_label_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	const default_slot_or_fallback = default_slot || fallback_block$8(ctx);

    	let button_levels = [
    		/*$$restProps*/ ctx[9],
    		{ class: /*classes*/ ctx[7] },
    		{ disabled: /*disabled*/ ctx[2] },
    		{ value: /*value*/ ctx[5] },
    		{
    			"aria-label": button_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6]
    		},
    		{ style: /*style*/ ctx[4] }
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			button = element("button");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(button, button_data);
    			add_location(button, file$W, 48, 2, 985);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[19], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*close, children, $$scope*/ 65539)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
    				(!current || dirty & /*value*/ 32) && { value: /*value*/ ctx[5] },
    				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 320 && button_aria_label_value !== (button_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6])) && { "aria-label": button_aria_label_value },
    				(!current || dirty & /*style*/ 16) && { style: /*style*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(48:0) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (33:0) {#if href}
    function create_if_block$w(ctx) {
    	let a;
    	let current_block_type_index;
    	let if_block;
    	let a_aria_label_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$j, create_else_block$e];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*children*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let a_levels = [
    		/*$$restProps*/ ctx[9],
    		{ class: /*classes*/ ctx[7] },
    		{ disabled: /*disabled*/ ctx[2] },
    		{ href: /*href*/ ctx[3] },
    		{
    			"aria-label": a_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6]
    		},
    		{ style: /*style*/ ctx[4] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			a = element("a");
    			if_block.c();
    			set_attributes(a, a_data);
    			add_location(a, file$W, 33, 2, 752);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if_blocks[current_block_type_index].m(a, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[18], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(a, null);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
    				(!current || dirty & /*href*/ 8) && { href: /*href*/ ctx[3] },
    				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 320 && a_aria_label_value !== (a_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6])) && { "aria-label": a_aria_label_value },
    				(!current || dirty & /*style*/ 16) && { style: /*style*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(33:0) {#if href}",
    		ctx
    	});

    	return block_1;
    }

    // (62:6) {:else}
    function create_else_block_2$3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

    	const block_1 = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block_2$3.name,
    		type: "else",
    		source: "(62:6) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (60:25) 
    function create_if_block_3$5(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text(/*children*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(60:25) ",
    		ctx
    	});

    	return block_1;
    }

    // (58:6) {#if close}
    function create_if_block_2$b(ctx) {
    	let span;

    	const block_1 = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "×";
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$W, 58, 8, 1171);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(58:6) {#if close}",
    		ctx
    	});

    	return block_1;
    }

    // (57:10)        
    function fallback_block$8(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$b, create_if_block_3$5, create_else_block_2$3];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*close*/ ctx[1]) return 0;
    		if (/*children*/ ctx[0]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: fallback_block$8.name,
    		type: "fallback",
    		source: "(57:10)        ",
    		ctx
    	});

    	return block_1;
    }

    // (44:4) {:else}
    function create_else_block$e(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

    	const block_1 = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(44:4) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (42:4) {#if children}
    function create_if_block_1$j(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text(/*children*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(42:4) {#if children}",
    		ctx
    	});

    	return block_1;
    }

    function create_fragment$12(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$w, create_else_block_1$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block_1;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let ariaLabel;
    	let classes;
    	let defaultAriaLabel;

    	const omit_props_names = [
    		"class","active","block","children","close","color","disabled","href","outline","size","style","value"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { active = false } = $$props;
    	let { block = false } = $$props;
    	let { children = undefined } = $$props;
    	let { close = false } = $$props;
    	let { color = 'secondary' } = $$props;
    	let { disabled = false } = $$props;
    	let { href = '' } = $$props;
    	let { outline = false } = $$props;
    	let { size = null } = $$props;
    	let { style = '' } = $$props;
    	let { value = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
    		if ('active' in $$new_props) $$invalidate(11, active = $$new_props.active);
    		if ('block' in $$new_props) $$invalidate(12, block = $$new_props.block);
    		if ('children' in $$new_props) $$invalidate(0, children = $$new_props.children);
    		if ('close' in $$new_props) $$invalidate(1, close = $$new_props.close);
    		if ('color' in $$new_props) $$invalidate(13, color = $$new_props.color);
    		if ('disabled' in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('href' in $$new_props) $$invalidate(3, href = $$new_props.href);
    		if ('outline' in $$new_props) $$invalidate(14, outline = $$new_props.outline);
    		if ('size' in $$new_props) $$invalidate(15, size = $$new_props.size);
    		if ('style' in $$new_props) $$invalidate(4, style = $$new_props.style);
    		if ('value' in $$new_props) $$invalidate(5, value = $$new_props.value);
    		if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		active,
    		block,
    		children,
    		close,
    		color,
    		disabled,
    		href,
    		outline,
    		size,
    		style,
    		value,
    		defaultAriaLabel,
    		classes,
    		ariaLabel
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(10, className = $$new_props.className);
    		if ('active' in $$props) $$invalidate(11, active = $$new_props.active);
    		if ('block' in $$props) $$invalidate(12, block = $$new_props.block);
    		if ('children' in $$props) $$invalidate(0, children = $$new_props.children);
    		if ('close' in $$props) $$invalidate(1, close = $$new_props.close);
    		if ('color' in $$props) $$invalidate(13, color = $$new_props.color);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('href' in $$props) $$invalidate(3, href = $$new_props.href);
    		if ('outline' in $$props) $$invalidate(14, outline = $$new_props.outline);
    		if ('size' in $$props) $$invalidate(15, size = $$new_props.size);
    		if ('style' in $$props) $$invalidate(4, style = $$new_props.style);
    		if ('value' in $$props) $$invalidate(5, value = $$new_props.value);
    		if ('defaultAriaLabel' in $$props) $$invalidate(6, defaultAriaLabel = $$new_props.defaultAriaLabel);
    		if ('classes' in $$props) $$invalidate(7, classes = $$new_props.classes);
    		if ('ariaLabel' in $$props) $$invalidate(8, ariaLabel = $$new_props.ariaLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(8, ariaLabel = $$props['aria-label']);

    		if ($$self.$$.dirty & /*className, close, outline, color, size, block, active*/ 64514) {
    			$$invalidate(7, classes = classnames(className, { close }, close || 'btn', close || `btn${outline ? '-outline' : ''}-${color}`, size ? `btn-${size}` : false, block ? 'btn-block' : false, { active }));
    		}

    		if ($$self.$$.dirty & /*close*/ 2) {
    			$$invalidate(6, defaultAriaLabel = close ? 'Close' : null);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		children,
    		close,
    		disabled,
    		href,
    		style,
    		value,
    		defaultAriaLabel,
    		classes,
    		ariaLabel,
    		$$restProps,
    		className,
    		active,
    		block,
    		color,
    		outline,
    		size,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1
    	];
    }

    class Button$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$12, create_fragment$12, safe_not_equal, {
    			class: 10,
    			active: 11,
    			block: 12,
    			children: 0,
    			close: 1,
    			color: 13,
    			disabled: 2,
    			href: 3,
    			outline: 14,
    			size: 15,
    			style: 4,
    			value: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$12.name
    		});
    	}

    	get class() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get block() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set block(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get children() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set children(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set close(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    const createContext = () => writable({});

    /* node_modules/sveltestrap/src/Dropdown.svelte generated by Svelte v3.40.3 */

    const { Error: Error_1$1 } = globals;
    const file$V = "node_modules/sveltestrap/src/Dropdown.svelte";

    // (105:0) {:else}
    function create_else_block$d(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	let div_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$V, 105, 2, 2574);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[19](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[19](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(105:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (101:0) {#if nav}
    function create_if_block$v(ctx) {
    	let li;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	let li_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$V, 101, 2, 2483);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			/*li_binding*/ ctx[18](li);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    			/*li_binding*/ ctx[18](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(101:0) {#if nav}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$11(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$v, create_else_block$d];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nav*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let subItemIsActive;
    	let classes;

    	const omit_props_names = [
    		"class","direction","group","isOpen","nav","active","addonType","size","toggle","inNavbar","setActiveFromChild","dropup"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dropdown', slots, ['default']);
    	let context = createContext();
    	setContext('dropdownContext', context);
    	let { class: className = '' } = $$props;
    	let { direction = 'down' } = $$props;
    	let { group = false } = $$props;
    	let { isOpen = false } = $$props;
    	let { nav = false } = $$props;
    	let { active = false } = $$props;
    	let { addonType = false } = $$props;
    	let { size = '' } = $$props;
    	let { toggle = undefined } = $$props;
    	let { inNavbar = false } = $$props;
    	let { setActiveFromChild = false } = $$props;
    	let { dropup = false } = $$props;
    	const validDirections = ['up', 'down', 'left', 'right'];

    	if (validDirections.indexOf(direction) === -1) {
    		throw new Error(`Invalid direction sent: '${direction}' is not one of 'up', 'down', 'left', 'right'`);
    	}

    	let component;

    	function handleDocumentClick(e) {
    		if (e && (e.which === 3 || e.type === 'keyup' && e.which !== 9)) return;

    		if (component.contains(e.target) && component !== e.target && (e.type !== 'keyup' || e.which === 9)) {
    			return;
    		}

    		toggle(e);
    	}

    	onDestroy(() => {
    		['click', 'touchstart', 'keyup'].forEach(event => document.removeEventListener(event, handleDocumentClick, true));
    	});

    	function li_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			component = $$value;
    			$$invalidate(1, component);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			component = $$value;
    			$$invalidate(1, component);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('direction' in $$new_props) $$invalidate(5, direction = $$new_props.direction);
    		if ('group' in $$new_props) $$invalidate(6, group = $$new_props.group);
    		if ('isOpen' in $$new_props) $$invalidate(7, isOpen = $$new_props.isOpen);
    		if ('nav' in $$new_props) $$invalidate(0, nav = $$new_props.nav);
    		if ('active' in $$new_props) $$invalidate(8, active = $$new_props.active);
    		if ('addonType' in $$new_props) $$invalidate(9, addonType = $$new_props.addonType);
    		if ('size' in $$new_props) $$invalidate(10, size = $$new_props.size);
    		if ('toggle' in $$new_props) $$invalidate(11, toggle = $$new_props.toggle);
    		if ('inNavbar' in $$new_props) $$invalidate(12, inNavbar = $$new_props.inNavbar);
    		if ('setActiveFromChild' in $$new_props) $$invalidate(13, setActiveFromChild = $$new_props.setActiveFromChild);
    		if ('dropup' in $$new_props) $$invalidate(14, dropup = $$new_props.dropup);
    		if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		setContext,
    		onDestroy,
    		classnames,
    		createContext,
    		context,
    		className,
    		direction,
    		group,
    		isOpen,
    		nav,
    		active,
    		addonType,
    		size,
    		toggle,
    		inNavbar,
    		setActiveFromChild,
    		dropup,
    		validDirections,
    		component,
    		handleDocumentClick,
    		subItemIsActive,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('context' in $$props) $$invalidate(20, context = $$new_props.context);
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('direction' in $$props) $$invalidate(5, direction = $$new_props.direction);
    		if ('group' in $$props) $$invalidate(6, group = $$new_props.group);
    		if ('isOpen' in $$props) $$invalidate(7, isOpen = $$new_props.isOpen);
    		if ('nav' in $$props) $$invalidate(0, nav = $$new_props.nav);
    		if ('active' in $$props) $$invalidate(8, active = $$new_props.active);
    		if ('addonType' in $$props) $$invalidate(9, addonType = $$new_props.addonType);
    		if ('size' in $$props) $$invalidate(10, size = $$new_props.size);
    		if ('toggle' in $$props) $$invalidate(11, toggle = $$new_props.toggle);
    		if ('inNavbar' in $$props) $$invalidate(12, inNavbar = $$new_props.inNavbar);
    		if ('setActiveFromChild' in $$props) $$invalidate(13, setActiveFromChild = $$new_props.setActiveFromChild);
    		if ('dropup' in $$props) $$invalidate(14, dropup = $$new_props.dropup);
    		if ('component' in $$props) $$invalidate(1, component = $$new_props.component);
    		if ('subItemIsActive' in $$props) $$invalidate(15, subItemIsActive = $$new_props.subItemIsActive);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*setActiveFromChild, component*/ 8194) {
    			$$invalidate(15, subItemIsActive = !!(setActiveFromChild && component && typeof component.querySelector === 'function' && component.querySelector('.active')));
    		}

    		if ($$self.$$.dirty & /*className, direction, nav, active, setActiveFromChild, subItemIsActive, addonType, group, size, isOpen*/ 42993) {
    			$$invalidate(2, classes = classnames(className, direction !== 'down' && `drop${direction}`, nav && active ? 'active' : false, setActiveFromChild && subItemIsActive ? 'active' : false, {
    				[`input-group-${addonType}`]: addonType,
    				'btn-group': group,
    				[`btn-group-${size}`]: !!size,
    				dropdown: !group && !addonType,
    				show: isOpen,
    				'nav-item': nav
    			}));
    		}

    		if ($$self.$$.dirty & /*isOpen*/ 128) {
    			{
    				if (typeof document !== 'undefined') {
    					if (isOpen) {
    						['click', 'touchstart', 'keyup'].forEach(event => document.addEventListener(event, handleDocumentClick, true));
    					} else {
    						['click', 'touchstart', 'keyup'].forEach(event => document.removeEventListener(event, handleDocumentClick, true));
    					}
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*toggle, isOpen, direction, dropup, inNavbar*/ 22688) {
    			{
    				context.update(() => {
    					return {
    						toggle,
    						isOpen,
    						direction: direction === 'down' && dropup ? 'up' : direction,
    						inNavbar
    					};
    				});
    			}
    		}
    	};

    	return [
    		nav,
    		component,
    		classes,
    		$$restProps,
    		className,
    		direction,
    		group,
    		isOpen,
    		active,
    		addonType,
    		size,
    		toggle,
    		inNavbar,
    		setActiveFromChild,
    		dropup,
    		subItemIsActive,
    		$$scope,
    		slots,
    		li_binding,
    		div_binding
    	];
    }

    class Dropdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$11, create_fragment$11, safe_not_equal, {
    			class: 4,
    			direction: 5,
    			group: 6,
    			isOpen: 7,
    			nav: 0,
    			active: 8,
    			addonType: 9,
    			size: 10,
    			toggle: 11,
    			inNavbar: 12,
    			setActiveFromChild: 13,
    			dropup: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dropdown",
    			options,
    			id: create_fragment$11.name
    		});
    	}

    	get class() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nav() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nav(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addonType() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addonType(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inNavbar() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inNavbar(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setActiveFromChild() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set setActiveFromChild(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dropup() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dropup(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Collapse.svelte generated by Svelte v3.40.3 */
    const file$U = "node_modules/sveltestrap/src/Collapse.svelte";

    // (57:0) {#if isOpen}
    function create_if_block$u(ctx) {
    	let div;
    	let div_style_value;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	let div_levels = [
    		{
    			style: div_style_value = /*navbar*/ ctx[1] ? undefined : 'overflow: hidden;'
    		},
    		/*$$restProps*/ ctx[8],
    		{ class: /*classes*/ ctx[7] }
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$U, 57, 2, 1231);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "introstart", /*introstart_handler*/ ctx[15], false, false, false),
    					listen_dev(div, "introend", /*introend_handler*/ ctx[16], false, false, false),
    					listen_dev(div, "outrostart", /*outrostart_handler*/ ctx[17], false, false, false),
    					listen_dev(div, "outroend", /*outroend_handler*/ ctx[18], false, false, false),
    					listen_dev(
    						div,
    						"introstart",
    						function () {
    							if (is_function(/*onEntering*/ ctx[2])) /*onEntering*/ ctx[2].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div,
    						"introend",
    						function () {
    							if (is_function(/*onEntered*/ ctx[3])) /*onEntered*/ ctx[3].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div,
    						"outrostart",
    						function () {
    							if (is_function(/*onExiting*/ ctx[4])) /*onExiting*/ ctx[4].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div,
    						"outroend",
    						function () {
    							if (is_function(/*onExited*/ ctx[5])) /*onExited*/ ctx[5].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*navbar*/ 2 && div_style_value !== (div_style_value = /*navbar*/ ctx[1] ? undefined : 'overflow: hidden;')) && { style: div_style_value },
    				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
    					div_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);

    			if (local) {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
    				div_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(57:0) {#if isOpen}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[19]);
    	let if_block = /*isOpen*/ ctx[0] && create_if_block$u(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "resize", /*onwindowresize*/ ctx[19]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$u(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"isOpen","class","navbar","onEntering","onEntered","onExiting","onExited","expand"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Collapse', slots, ['default']);
    	const noop = () => undefined;
    	let { isOpen = false } = $$props;
    	let { class: className = '' } = $$props;
    	let { navbar = false } = $$props;
    	let { onEntering = noop } = $$props;
    	let { onEntered = noop } = $$props;
    	let { onExiting = noop } = $$props;
    	let { onExited = noop } = $$props;
    	let { expand = false } = $$props;
    	let windowWidth = 0;
    	let _wasMaximazed = false;
    	const minWidth = {};
    	minWidth['xs'] = 0;
    	minWidth['sm'] = 576;
    	minWidth['md'] = 768;
    	minWidth['lg'] = 992;
    	minWidth['xl'] = 1200;
    	const dispatch = createEventDispatcher();

    	function notify() {
    		dispatch('update', { isOpen });
    	}

    	function introstart_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function introend_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function outrostart_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function outroend_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function onwindowresize() {
    		$$invalidate(6, windowWidth = window.innerWidth);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
    		if ('navbar' in $$new_props) $$invalidate(1, navbar = $$new_props.navbar);
    		if ('onEntering' in $$new_props) $$invalidate(2, onEntering = $$new_props.onEntering);
    		if ('onEntered' in $$new_props) $$invalidate(3, onEntered = $$new_props.onEntered);
    		if ('onExiting' in $$new_props) $$invalidate(4, onExiting = $$new_props.onExiting);
    		if ('onExited' in $$new_props) $$invalidate(5, onExited = $$new_props.onExited);
    		if ('expand' in $$new_props) $$invalidate(10, expand = $$new_props.expand);
    		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		createEventDispatcher,
    		slide,
    		noop,
    		isOpen,
    		className,
    		navbar,
    		onEntering,
    		onEntered,
    		onExiting,
    		onExited,
    		expand,
    		windowWidth,
    		_wasMaximazed,
    		minWidth,
    		dispatch,
    		notify,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ('className' in $$props) $$invalidate(9, className = $$new_props.className);
    		if ('navbar' in $$props) $$invalidate(1, navbar = $$new_props.navbar);
    		if ('onEntering' in $$props) $$invalidate(2, onEntering = $$new_props.onEntering);
    		if ('onEntered' in $$props) $$invalidate(3, onEntered = $$new_props.onEntered);
    		if ('onExiting' in $$props) $$invalidate(4, onExiting = $$new_props.onExiting);
    		if ('onExited' in $$props) $$invalidate(5, onExited = $$new_props.onExited);
    		if ('expand' in $$props) $$invalidate(10, expand = $$new_props.expand);
    		if ('windowWidth' in $$props) $$invalidate(6, windowWidth = $$new_props.windowWidth);
    		if ('_wasMaximazed' in $$props) $$invalidate(11, _wasMaximazed = $$new_props._wasMaximazed);
    		if ('classes' in $$props) $$invalidate(7, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, navbar*/ 514) {
    			$$invalidate(7, classes = classnames(className, // collapseClass,
    			navbar && 'navbar-collapse'));
    		}

    		if ($$self.$$.dirty & /*navbar, expand, windowWidth, minWidth, isOpen, _wasMaximazed*/ 7235) {
    			if (navbar && expand) {
    				if (windowWidth >= minWidth[expand] && !isOpen) {
    					$$invalidate(0, isOpen = true);
    					$$invalidate(11, _wasMaximazed = true);
    					notify();
    				} else if (windowWidth < minWidth[expand] && _wasMaximazed) {
    					$$invalidate(0, isOpen = false);
    					$$invalidate(11, _wasMaximazed = false);
    					notify();
    				}
    			}
    		}
    	};

    	return [
    		isOpen,
    		navbar,
    		onEntering,
    		onEntered,
    		onExiting,
    		onExited,
    		windowWidth,
    		classes,
    		$$restProps,
    		className,
    		expand,
    		_wasMaximazed,
    		minWidth,
    		$$scope,
    		slots,
    		introstart_handler,
    		introend_handler,
    		outrostart_handler,
    		outroend_handler,
    		onwindowresize
    	];
    }

    class Collapse extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$10, create_fragment$10, safe_not_equal, {
    			isOpen: 0,
    			class: 9,
    			navbar: 1,
    			onEntering: 2,
    			onEntered: 3,
    			onExiting: 4,
    			onExited: 5,
    			expand: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Collapse",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get isOpen() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navbar() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navbar(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onEntering() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEntering(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onEntered() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEntered(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExiting() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExiting(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExited() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExited(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expand(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/DropdownItem.svelte generated by Svelte v3.40.3 */
    const file$T = "node_modules/sveltestrap/src/DropdownItem.svelte";

    // (49:0) {:else}
    function create_else_block$c(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let button_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			set_attributes(button, button_data);
    			add_location(button, file$T, 49, 2, 1086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler_2*/ ctx[15], false, false, false),
    					listen_dev(button, "click", /*handleItemClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(49:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:15) 
    function create_if_block_2$a(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	let a_levels = [
    		/*$$restProps*/ ctx[6],
    		{ click: "" },
    		{ href: /*href*/ ctx[2] },
    		{ class: /*classes*/ ctx[3] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$T, 45, 2, 979);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*handleItemClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				{ click: "" },
    				(!current || dirty & /*href*/ 4) && { href: /*href*/ ctx[2] },
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(45:15) ",
    		ctx
    	});

    	return block;
    }

    // (41:18) 
    function create_if_block_1$i(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let div_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$T, 41, 2, 864);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", /*click_handler_1*/ ctx[14], false, false, false),
    					listen_dev(div, "click", /*handleItemClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(41:18) ",
    		ctx
    	});

    	return block;
    }

    // (37:0) {#if header}
    function create_if_block$t(ctx) {
    	let h6;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let h6_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
    	let h6_data = {};

    	for (let i = 0; i < h6_levels.length; i += 1) {
    		h6_data = assign(h6_data, h6_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			if (default_slot) default_slot.c();
    			set_attributes(h6, h6_data);
    			add_location(h6, file$T, 37, 2, 748);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);

    			if (default_slot) {
    				default_slot.m(h6, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(h6, "click", /*click_handler*/ ctx[13], false, false, false),
    					listen_dev(h6, "click", /*handleItemClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(h6, h6_data = get_spread_update(h6_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(37:0) {#if header}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$$(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$t, create_if_block_1$i, create_if_block_2$a, create_else_block$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*header*/ ctx[1]) return 0;
    		if (/*divider*/ ctx[0]) return 1;
    		if (/*href*/ ctx[2]) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","active","disabled","divider","header","toggle","href"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $context;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DropdownItem', slots, ['default']);
    	const context = getContext('dropdownContext');
    	validate_store(context, 'context');
    	component_subscribe($$self, context, value => $$invalidate(16, $context = value));
    	let { class: className = '' } = $$props;
    	let { active = false } = $$props;
    	let { disabled = false } = $$props;
    	let { divider = false } = $$props;
    	let { header = false } = $$props;
    	let { toggle = true } = $$props;
    	let { href = '' } = $$props;

    	function handleItemClick(e) {
    		if (disabled || header || divider) {
    			e.preventDefault();
    			return;
    		}

    		if (toggle) {
    			$context.toggle(e);
    		}
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
    		if ('active' in $$new_props) $$invalidate(8, active = $$new_props.active);
    		if ('disabled' in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ('divider' in $$new_props) $$invalidate(0, divider = $$new_props.divider);
    		if ('header' in $$new_props) $$invalidate(1, header = $$new_props.header);
    		if ('toggle' in $$new_props) $$invalidate(10, toggle = $$new_props.toggle);
    		if ('href' in $$new_props) $$invalidate(2, href = $$new_props.href);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		classnames,
    		context,
    		className,
    		active,
    		disabled,
    		divider,
    		header,
    		toggle,
    		href,
    		handleItemClick,
    		classes,
    		$context
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(7, className = $$new_props.className);
    		if ('active' in $$props) $$invalidate(8, active = $$new_props.active);
    		if ('disabled' in $$props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ('divider' in $$props) $$invalidate(0, divider = $$new_props.divider);
    		if ('header' in $$props) $$invalidate(1, header = $$new_props.header);
    		if ('toggle' in $$props) $$invalidate(10, toggle = $$new_props.toggle);
    		if ('href' in $$props) $$invalidate(2, href = $$new_props.href);
    		if ('classes' in $$props) $$invalidate(3, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, disabled, divider, header, active*/ 899) {
    			$$invalidate(3, classes = classnames(className, {
    				disabled,
    				'dropdown-item': !divider && !header,
    				active,
    				'dropdown-header': header,
    				'dropdown-divider': divider
    			}));
    		}
    	};

    	return [
    		divider,
    		header,
    		href,
    		classes,
    		context,
    		handleItemClick,
    		$$restProps,
    		className,
    		active,
    		disabled,
    		toggle,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class DropdownItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$$, create_fragment$$, safe_not_equal, {
    			class: 7,
    			active: 8,
    			disabled: 9,
    			divider: 0,
    			header: 1,
    			toggle: 10,
    			href: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownItem",
    			options,
    			id: create_fragment$$.name
    		});
    	}

    	get class() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get divider() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set divider(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get header() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/DropdownMenu.svelte generated by Svelte v3.40.3 */
    const file$S = "node_modules/sveltestrap/src/DropdownMenu.svelte";

    function create_fragment$_(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$S, 16, 0, 352);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","right"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $context;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DropdownMenu', slots, ['default']);
    	const context = getContext('dropdownContext');
    	validate_store(context, 'context');
    	component_subscribe($$self, context, value => $$invalidate(5, $context = value));
    	let { class: className = '' } = $$props;
    	let { right = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('right' in $$new_props) $$invalidate(4, right = $$new_props.right);
    		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		classnames,
    		context,
    		className,
    		right,
    		classes,
    		$context
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('right' in $$props) $$invalidate(4, right = $$new_props.right);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, right, $context*/ 56) {
    			$$invalidate(0, classes = classnames(className, 'dropdown-menu', {
    				'dropdown-menu-right': right,
    				show: $context.isOpen
    			}));
    		}
    	};

    	return [classes, context, $$restProps, className, right, $context, $$scope, slots];
    }

    class DropdownMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, { class: 3, right: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownMenu",
    			options,
    			id: create_fragment$_.name
    		});
    	}

    	get class() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get right() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set right(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/DropdownToggle.svelte generated by Svelte v3.40.3 */
    const file$R = "node_modules/sveltestrap/src/DropdownToggle.svelte";

    // (67:0) {:else}
    function create_else_block$b(ctx) {
    	let button;
    	let current;

    	const button_spread_levels = [
    		/*$$restProps*/ ctx[10],
    		{ ariaHaspopup: /*ariaHaspopup*/ ctx[1] },
    		{ class: /*classes*/ ctx[7] },
    		{ color: /*color*/ ctx[0] },
    		{ size: /*size*/ ctx[4] },
    		{ outline: /*outline*/ ctx[6] }
    	];

    	let button_props = {
    		$$slots: { default: [create_default_slot$q] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < button_spread_levels.length; i += 1) {
    		button_props = assign(button_props, button_spread_levels[i]);
    	}

    	button = new Button$1({ props: button_props, $$inline: true });
    	button.$on("click", /*click_handler_2*/ ctx[18]);
    	button.$on("click", /*toggleButton*/ ctx[9]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = (dirty & /*$$restProps, ariaHaspopup, classes, color, size, outline*/ 1235)
    			? get_spread_update(button_spread_levels, [
    					dirty & /*$$restProps*/ 1024 && get_spread_object(/*$$restProps*/ ctx[10]),
    					dirty & /*ariaHaspopup*/ 2 && { ariaHaspopup: /*ariaHaspopup*/ ctx[1] },
    					dirty & /*classes*/ 128 && { class: /*classes*/ ctx[7] },
    					dirty & /*color*/ 1 && { color: /*color*/ ctx[0] },
    					dirty & /*size*/ 16 && { size: /*size*/ ctx[4] },
    					dirty & /*outline*/ 64 && { outline: /*outline*/ ctx[6] }
    				])
    			: {};

    			if (dirty & /*$$scope, ariaLabel*/ 524292) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(67:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (54:25) 
    function create_if_block_1$h(ctx) {
    	let span;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	const default_slot_or_fallback = default_slot || fallback_block_1$2(ctx);

    	let span_levels = [
    		/*$$restProps*/ ctx[10],
    		{ ariahaspopup: /*ariaHaspopup*/ ctx[1] },
    		{ class: /*classes*/ ctx[7] },
    		{ color: /*color*/ ctx[0] },
    		{ size: /*size*/ ctx[4] }
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(span, span_data);
    			add_location(span, file$R, 54, 2, 1098);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(span, "click", /*click_handler_1*/ ctx[17], false, false, false),
    					listen_dev(span, "click", /*toggleButton*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 4)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10],
    				(!current || dirty & /*ariaHaspopup*/ 2) && { ariahaspopup: /*ariaHaspopup*/ ctx[1] },
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				(!current || dirty & /*color*/ 1) && { color: /*color*/ ctx[0] },
    				(!current || dirty & /*size*/ 16) && { size: /*size*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(54:25) ",
    		ctx
    	});

    	return block;
    }

    // (42:0) {#if nav}
    function create_if_block$s(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	const default_slot_or_fallback = default_slot || fallback_block$7(ctx);

    	let a_levels = [
    		/*$$restProps*/ ctx[10],
    		{ href: "#nav" },
    		{ ariahaspopup: /*ariaHaspopup*/ ctx[1] },
    		{ class: /*classes*/ ctx[7] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(a, a_data);
    			add_location(a, file$R, 42, 2, 872);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*click_handler*/ ctx[16], false, false, false),
    					listen_dev(a, "click", /*toggleButton*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 4)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10],
    				{ href: "#nav" },
    				(!current || dirty & /*ariaHaspopup*/ 2) && { ariahaspopup: /*ariaHaspopup*/ ctx[1] },
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(42:0) {#if nav}",
    		ctx
    	});

    	return block;
    }

    // (77:10)        
    function fallback_block_2$1(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*ariaLabel*/ ctx[2]);
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$R, 77, 6, 1483);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaLabel*/ 4) set_data_dev(t, /*ariaLabel*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2$1.name,
    		type: "fallback",
    		source: "(77:10)        ",
    		ctx
    	});

    	return block;
    }

    // (68:2) <Button     {...$$restProps}     on:click     on:click={toggleButton}     {ariaHaspopup}     class={classes}     {color}     {size}     {outline}>
    function create_default_slot$q(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	const default_slot_or_fallback = default_slot || fallback_block_2$1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 4)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(68:2) <Button     {...$$restProps}     on:click     on:click={toggleButton}     {ariaHaspopup}     class={classes}     {color}     {size}     {outline}>",
    		ctx
    	});

    	return block;
    }

    // (63:10)        
    function fallback_block_1$2(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*ariaLabel*/ ctx[2]);
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$R, 63, 6, 1246);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaLabel*/ 4) set_data_dev(t, /*ariaLabel*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1$2.name,
    		type: "fallback",
    		source: "(63:10)        ",
    		ctx
    	});

    	return block;
    }

    // (50:10)        
    function fallback_block$7(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*ariaLabel*/ ctx[2]);
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$R, 50, 6, 1010);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaLabel*/ 4) set_data_dev(t, /*ariaLabel*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$7.name,
    		type: "fallback",
    		source: "(50:10)        ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$s, create_if_block_1$h, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nav*/ ctx[3]) return 0;
    		if (/*tag*/ ctx[5] === 'span') return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","caret","color","disabled","ariaHaspopup","ariaLabel","split","nav","size","tag","outline"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $context;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DropdownToggle', slots, ['default']);
    	const context = getContext('dropdownContext');
    	validate_store(context, 'context');
    	component_subscribe($$self, context, value => $$invalidate(20, $context = value));
    	let { class: className = '' } = $$props;
    	let { caret = false } = $$props;
    	let { color = 'secondary' } = $$props;
    	let { disabled = false } = $$props;
    	let { ariaHaspopup = true } = $$props;
    	let { ariaLabel = 'Toggle Dropdown' } = $$props;
    	let { split = false } = $$props;
    	let { nav = false } = $$props;
    	let { size = '' } = $$props;
    	let { tag = null } = $$props;
    	let { outline = false } = $$props;

    	function toggleButton(e) {
    		if (disabled) {
    			e.preventDefault();
    			return;
    		}

    		if (nav) {
    			e.preventDefault();
    		}

    		$context.toggle(e);
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(11, className = $$new_props.class);
    		if ('caret' in $$new_props) $$invalidate(12, caret = $$new_props.caret);
    		if ('color' in $$new_props) $$invalidate(0, color = $$new_props.color);
    		if ('disabled' in $$new_props) $$invalidate(13, disabled = $$new_props.disabled);
    		if ('ariaHaspopup' in $$new_props) $$invalidate(1, ariaHaspopup = $$new_props.ariaHaspopup);
    		if ('ariaLabel' in $$new_props) $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    		if ('split' in $$new_props) $$invalidate(14, split = $$new_props.split);
    		if ('nav' in $$new_props) $$invalidate(3, nav = $$new_props.nav);
    		if ('size' in $$new_props) $$invalidate(4, size = $$new_props.size);
    		if ('tag' in $$new_props) $$invalidate(5, tag = $$new_props.tag);
    		if ('outline' in $$new_props) $$invalidate(6, outline = $$new_props.outline);
    		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		classnames,
    		Button: Button$1,
    		context,
    		className,
    		caret,
    		color,
    		disabled,
    		ariaHaspopup,
    		ariaLabel,
    		split,
    		nav,
    		size,
    		tag,
    		outline,
    		toggleButton,
    		classes,
    		$context
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(11, className = $$new_props.className);
    		if ('caret' in $$props) $$invalidate(12, caret = $$new_props.caret);
    		if ('color' in $$props) $$invalidate(0, color = $$new_props.color);
    		if ('disabled' in $$props) $$invalidate(13, disabled = $$new_props.disabled);
    		if ('ariaHaspopup' in $$props) $$invalidate(1, ariaHaspopup = $$new_props.ariaHaspopup);
    		if ('ariaLabel' in $$props) $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    		if ('split' in $$props) $$invalidate(14, split = $$new_props.split);
    		if ('nav' in $$props) $$invalidate(3, nav = $$new_props.nav);
    		if ('size' in $$props) $$invalidate(4, size = $$new_props.size);
    		if ('tag' in $$props) $$invalidate(5, tag = $$new_props.tag);
    		if ('outline' in $$props) $$invalidate(6, outline = $$new_props.outline);
    		if ('classes' in $$props) $$invalidate(7, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, caret, split, nav*/ 22536) {
    			$$invalidate(7, classes = classnames(className, {
    				'dropdown-toggle': caret || split,
    				'dropdown-toggle-split': split,
    				'nav-link': nav
    			}));
    		}
    	};

    	return [
    		color,
    		ariaHaspopup,
    		ariaLabel,
    		nav,
    		size,
    		tag,
    		outline,
    		classes,
    		context,
    		toggleButton,
    		$$restProps,
    		className,
    		caret,
    		disabled,
    		split,
    		slots,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		$$scope
    	];
    }

    class DropdownToggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
    			class: 11,
    			caret: 12,
    			color: 0,
    			disabled: 13,
    			ariaHaspopup: 1,
    			ariaLabel: 2,
    			split: 14,
    			nav: 3,
    			size: 4,
    			tag: 5,
    			outline: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownToggle",
    			options,
    			id: create_fragment$Z.name
    		});
    	}

    	get class() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get caret() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set caret(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaHaspopup() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaHaspopup(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaLabel() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaLabel(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get split() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set split(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nav() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nav(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tag() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tag(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Fade.svelte generated by Svelte v3.40.3 */
    const file$Q = "node_modules/sveltestrap/src/Fade.svelte";

    // (14:0) {#if isOpen}
    function create_if_block$r(ctx) {
    	let div;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	let div_levels = [/*$$restProps*/ ctx[6], { class: /*className*/ ctx[1] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$Q, 14, 2, 320);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "introstart", /*introstart_handler*/ ctx[9], false, false, false),
    					listen_dev(div, "introend", /*introend_handler*/ ctx[10], false, false, false),
    					listen_dev(div, "outrostart", /*outrostart_handler*/ ctx[11], false, false, false),
    					listen_dev(div, "outroend", /*outroend_handler*/ ctx[12], false, false, false),
    					listen_dev(
    						div,
    						"introstart",
    						function () {
    							if (is_function(/*onEntering*/ ctx[2])) /*onEntering*/ ctx[2].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div,
    						"introend",
    						function () {
    							if (is_function(/*onEntered*/ ctx[3])) /*onEntered*/ ctx[3].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div,
    						"outrostart",
    						function () {
    							if (is_function(/*onExiting*/ ctx[4])) /*onExiting*/ ctx[4].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div,
    						"outroend",
    						function () {
    							if (is_function(/*onExited*/ ctx[5])) /*onExited*/ ctx[5].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*className*/ 2) && { class: /*className*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
    					div_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);

    			if (local) {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
    				div_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(14:0) {#if isOpen}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*isOpen*/ ctx[0] && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$r(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	const omit_props_names = ["isOpen","class","onEntering","onEntered","onExiting","onExited"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Fade', slots, ['default']);
    	const noop = () => undefined;
    	let { isOpen = false } = $$props;
    	let { class: className = '' } = $$props;
    	let { onEntering = noop } = $$props;
    	let { onEntered = noop } = $$props;
    	let { onExiting = noop } = $$props;
    	let { onExited = noop } = $$props;

    	function introstart_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function introend_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function outrostart_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function outroend_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('onEntering' in $$new_props) $$invalidate(2, onEntering = $$new_props.onEntering);
    		if ('onEntered' in $$new_props) $$invalidate(3, onEntered = $$new_props.onEntered);
    		if ('onExiting' in $$new_props) $$invalidate(4, onExiting = $$new_props.onExiting);
    		if ('onExited' in $$new_props) $$invalidate(5, onExited = $$new_props.onExited);
    		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		noop,
    		isOpen,
    		className,
    		onEntering,
    		onEntered,
    		onExiting,
    		onExited
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('onEntering' in $$props) $$invalidate(2, onEntering = $$new_props.onEntering);
    		if ('onEntered' in $$props) $$invalidate(3, onEntered = $$new_props.onEntered);
    		if ('onExiting' in $$props) $$invalidate(4, onExiting = $$new_props.onExiting);
    		if ('onExited' in $$props) $$invalidate(5, onExited = $$new_props.onExited);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isOpen,
    		className,
    		onEntering,
    		onEntered,
    		onExiting,
    		onExited,
    		$$restProps,
    		$$scope,
    		slots,
    		introstart_handler,
    		introend_handler,
    		outrostart_handler,
    		outroend_handler
    	];
    }

    class Fade extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
    			isOpen: 0,
    			class: 1,
    			onEntering: 2,
    			onEntered: 3,
    			onExiting: 4,
    			onExited: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Fade",
    			options,
    			id: create_fragment$Y.name
    		});
    	}

    	get isOpen() {
    		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onEntering() {
    		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEntering(value) {
    		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onEntered() {
    		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEntered(value) {
    		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExiting() {
    		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExiting(value) {
    		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExited() {
    		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExited(value) {
    		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/FormGroup.svelte generated by Svelte v3.40.3 */
    const file$P = "node_modules/sveltestrap/src/FormGroup.svelte";

    // (25:0) {:else}
    function create_else_block$a(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
    	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$P, 25, 2, 574);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(25:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:0) {#if tag === 'fieldset'}
    function create_if_block$q(ctx) {
    	let fieldset;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
    	let fieldset_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
    	let fieldset_data = {};

    	for (let i = 0; i < fieldset_levels.length; i += 1) {
    		fieldset_data = assign(fieldset_data, fieldset_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			fieldset = element("fieldset");
    			if (default_slot) default_slot.c();
    			set_attributes(fieldset, fieldset_data);
    			add_location(fieldset, file$P, 21, 2, 493);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fieldset, anchor);

    			if (default_slot) {
    				default_slot.m(fieldset, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fieldset);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(21:0) {#if tag === 'fieldset'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$X(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$q, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tag*/ ctx[0] === 'fieldset') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","row","check","inline","disabled","tag"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormGroup', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { row = false } = $$props;
    	let { check = false } = $$props;
    	let { inline = false } = $$props;
    	let { disabled = false } = $$props;
    	let { tag = null } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('row' in $$new_props) $$invalidate(4, row = $$new_props.row);
    		if ('check' in $$new_props) $$invalidate(5, check = $$new_props.check);
    		if ('inline' in $$new_props) $$invalidate(6, inline = $$new_props.inline);
    		if ('disabled' in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    		if ('tag' in $$new_props) $$invalidate(0, tag = $$new_props.tag);
    		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		row,
    		check,
    		inline,
    		disabled,
    		tag,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('row' in $$props) $$invalidate(4, row = $$new_props.row);
    		if ('check' in $$props) $$invalidate(5, check = $$new_props.check);
    		if ('inline' in $$props) $$invalidate(6, inline = $$new_props.inline);
    		if ('disabled' in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    		if ('tag' in $$props) $$invalidate(0, tag = $$new_props.tag);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, row, check, inline, disabled*/ 248) {
    			$$invalidate(1, classes = classnames(className, row ? 'row' : false, check ? 'form-check' : 'form-group', check && inline ? 'form-check-inline' : false, check && disabled ? 'disabled' : false));
    		}
    	};

    	return [
    		tag,
    		classes,
    		$$restProps,
    		className,
    		row,
    		check,
    		inline,
    		disabled,
    		$$scope,
    		slots
    	];
    }

    class FormGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$X, create_fragment$X, safe_not_equal, {
    			class: 3,
    			row: 4,
    			check: 5,
    			inline: 6,
    			disabled: 7,
    			tag: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormGroup",
    			options,
    			id: create_fragment$X.name
    		});
    	}

    	get class() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get row() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get check() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set check(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inline() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inline(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tag() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tag(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Label.svelte generated by Svelte v3.40.3 */
    const file$O = "node_modules/sveltestrap/src/Label.svelte";

    function create_fragment$W(ctx) {
    	let label;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	let label_levels = [
    		/*$$restProps*/ ctx[2],
    		{ class: /*classes*/ ctx[1] },
    		{ for: /*fore*/ ctx[0] }
    	];

    	let label_data = {};

    	for (let i = 0; i < label_levels.length; i += 1) {
    		label_data = assign(label_data, label_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			label = element("label");
    			if (default_slot) default_slot.c();
    			set_attributes(label, label_data);
    			add_location(label, file$O, 69, 0, 1625);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);

    			if (default_slot) {
    				default_slot.m(label, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(label, label_data = get_spread_update(label_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				(!current || dirty & /*fore*/ 1) && { for: /*fore*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","hidden","check","size","for","xs","sm","md","lg","xl","widths"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Label', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { hidden = false } = $$props;
    	let { check = false } = $$props;
    	let { size = '' } = $$props;
    	let { for: fore = null } = $$props;
    	let { xs = '' } = $$props;
    	let { sm = '' } = $$props;
    	let { md = '' } = $$props;
    	let { lg = '' } = $$props;
    	let { xl = '' } = $$props;
    	const colWidths = { xs, sm, md, lg, xl };
    	let { widths = Object.keys(colWidths) } = $$props;
    	const colClasses = [];

    	widths.forEach(colWidth => {
    		let columnProp = $$props[colWidth];

    		if (!columnProp && columnProp !== '') {
    			return;
    		}

    		const isXs = colWidth === 'xs';
    		let colClass;

    		if (isObject(columnProp)) {
    			const colSizeInterfix = isXs ? '-' : `-${colWidth}-`;
    			colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);

    			colClasses.push(classnames({
    				[colClass]: columnProp.size || columnProp.size === '',
    				[`order${colSizeInterfix}${columnProp.order}`]: columnProp.order || columnProp.order === 0,
    				[`offset${colSizeInterfix}${columnProp.offset}`]: columnProp.offset || columnProp.offset === 0
    			}));
    		} else {
    			colClass = getColumnSizeClass(isXs, colWidth, columnProp);
    			colClasses.push(colClass);
    		}
    	});

    	$$self.$$set = $$new_props => {
    		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('hidden' in $$new_props) $$invalidate(4, hidden = $$new_props.hidden);
    		if ('check' in $$new_props) $$invalidate(5, check = $$new_props.check);
    		if ('size' in $$new_props) $$invalidate(6, size = $$new_props.size);
    		if ('for' in $$new_props) $$invalidate(0, fore = $$new_props.for);
    		if ('xs' in $$new_props) $$invalidate(7, xs = $$new_props.xs);
    		if ('sm' in $$new_props) $$invalidate(8, sm = $$new_props.sm);
    		if ('md' in $$new_props) $$invalidate(9, md = $$new_props.md);
    		if ('lg' in $$new_props) $$invalidate(10, lg = $$new_props.lg);
    		if ('xl' in $$new_props) $$invalidate(11, xl = $$new_props.xl);
    		if ('widths' in $$new_props) $$invalidate(12, widths = $$new_props.widths);
    		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		getColumnSizeClass,
    		isObject,
    		className,
    		hidden,
    		check,
    		size,
    		fore,
    		xs,
    		sm,
    		md,
    		lg,
    		xl,
    		colWidths,
    		widths,
    		colClasses,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('hidden' in $$props) $$invalidate(4, hidden = $$new_props.hidden);
    		if ('check' in $$props) $$invalidate(5, check = $$new_props.check);
    		if ('size' in $$props) $$invalidate(6, size = $$new_props.size);
    		if ('fore' in $$props) $$invalidate(0, fore = $$new_props.fore);
    		if ('xs' in $$props) $$invalidate(7, xs = $$new_props.xs);
    		if ('sm' in $$props) $$invalidate(8, sm = $$new_props.sm);
    		if ('md' in $$props) $$invalidate(9, md = $$new_props.md);
    		if ('lg' in $$props) $$invalidate(10, lg = $$new_props.lg);
    		if ('xl' in $$props) $$invalidate(11, xl = $$new_props.xl);
    		if ('widths' in $$props) $$invalidate(12, widths = $$new_props.widths);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, hidden, check, size*/ 120) {
    			$$invalidate(1, classes = classnames(className, hidden ? 'sr-only' : false, check ? 'form-check-label' : false, size ? `col-form-label-${size}` : false, colClasses, colClasses.length ? 'col-form-label' : false));
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		fore,
    		classes,
    		$$restProps,
    		className,
    		hidden,
    		check,
    		size,
    		xs,
    		sm,
    		md,
    		lg,
    		xl,
    		widths,
    		$$scope,
    		slots
    	];
    }

    class Label$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$W, create_fragment$W, safe_not_equal, {
    			class: 3,
    			hidden: 4,
    			check: 5,
    			size: 6,
    			for: 0,
    			xs: 7,
    			sm: 8,
    			md: 9,
    			lg: 10,
    			xl: 11,
    			widths: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Label",
    			options,
    			id: create_fragment$W.name
    		});
    	}

    	get class() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hidden() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hidden(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get check() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set check(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get for() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set for(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xs() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xs(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sm() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sm(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get md() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set md(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lg() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lg(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xl() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xl(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get widths() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set widths(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Nav.svelte generated by Svelte v3.40.3 */
    const file$N = "node_modules/sveltestrap/src/Nav.svelte";

    function create_fragment$V(ctx) {
    	let ul;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let ul_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let ul_data = {};

    	for (let i = 0; i < ul_levels.length; i += 1) {
    		ul_data = assign(ul_data, ul_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			set_attributes(ul, ul_data);
    			add_location(ul, file$N, 39, 0, 941);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(ul, ul_data = get_spread_update(ul_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getVerticalClass(vertical) {
    	if (vertical === false) {
    		return false;
    	} else if (vertical === true || vertical === 'xs') {
    		return 'flex-column';
    	}

    	return `flex-${vertical}-column`;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","tabs","pills","vertical","horizontal","justified","fill","navbar","card"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nav', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { tabs = false } = $$props;
    	let { pills = false } = $$props;
    	let { vertical = false } = $$props;
    	let { horizontal = '' } = $$props;
    	let { justified = false } = $$props;
    	let { fill = false } = $$props;
    	let { navbar = false } = $$props;
    	let { card = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('tabs' in $$new_props) $$invalidate(3, tabs = $$new_props.tabs);
    		if ('pills' in $$new_props) $$invalidate(4, pills = $$new_props.pills);
    		if ('vertical' in $$new_props) $$invalidate(5, vertical = $$new_props.vertical);
    		if ('horizontal' in $$new_props) $$invalidate(6, horizontal = $$new_props.horizontal);
    		if ('justified' in $$new_props) $$invalidate(7, justified = $$new_props.justified);
    		if ('fill' in $$new_props) $$invalidate(8, fill = $$new_props.fill);
    		if ('navbar' in $$new_props) $$invalidate(9, navbar = $$new_props.navbar);
    		if ('card' in $$new_props) $$invalidate(10, card = $$new_props.card);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		tabs,
    		pills,
    		vertical,
    		horizontal,
    		justified,
    		fill,
    		navbar,
    		card,
    		getVerticalClass,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('tabs' in $$props) $$invalidate(3, tabs = $$new_props.tabs);
    		if ('pills' in $$props) $$invalidate(4, pills = $$new_props.pills);
    		if ('vertical' in $$props) $$invalidate(5, vertical = $$new_props.vertical);
    		if ('horizontal' in $$props) $$invalidate(6, horizontal = $$new_props.horizontal);
    		if ('justified' in $$props) $$invalidate(7, justified = $$new_props.justified);
    		if ('fill' in $$props) $$invalidate(8, fill = $$new_props.fill);
    		if ('navbar' in $$props) $$invalidate(9, navbar = $$new_props.navbar);
    		if ('card' in $$props) $$invalidate(10, card = $$new_props.card);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, navbar, horizontal, vertical, tabs, card, pills, justified, fill*/ 2044) {
    			$$invalidate(0, classes = classnames(className, navbar ? 'navbar-nav' : 'nav', horizontal ? `justify-content-${horizontal}` : false, getVerticalClass(vertical), {
    				'nav-tabs': tabs,
    				'card-header-tabs': card && tabs,
    				'nav-pills': pills,
    				'card-header-pills': card && pills,
    				'nav-justified': justified,
    				'nav-fill': fill
    			}));
    		}
    	};

    	return [
    		classes,
    		$$restProps,
    		className,
    		tabs,
    		pills,
    		vertical,
    		horizontal,
    		justified,
    		fill,
    		navbar,
    		card,
    		$$scope,
    		slots
    	];
    }

    class Nav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {
    			class: 2,
    			tabs: 3,
    			pills: 4,
    			vertical: 5,
    			horizontal: 6,
    			justified: 7,
    			fill: 8,
    			navbar: 9,
    			card: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav",
    			options,
    			id: create_fragment$V.name
    		});
    	}

    	get class() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pills() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pills(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vertical() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vertical(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get horizontal() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set horizontal(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get justified() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set justified(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navbar() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navbar(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Navbar.svelte generated by Svelte v3.40.3 */
    const file$M = "node_modules/sveltestrap/src/Navbar.svelte";

    function create_fragment$U(ctx) {
    	let nav;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
    	let nav_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let nav_data = {};

    	for (let i = 0; i < nav_levels.length; i += 1) {
    		nav_data = assign(nav_data, nav_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			if (default_slot) default_slot.c();
    			set_attributes(nav, nav_data);
    			add_location(nav, file$M, 31, 0, 719);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);

    			if (default_slot) {
    				default_slot.m(nav, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(nav, nav_data = get_spread_update(nav_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getExpandClass(expand) {
    	if (expand === false) {
    		return false;
    	} else if (expand === true || expand === 'xs') {
    		return 'navbar-expand';
    	}

    	return `navbar-expand-${expand}`;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","light","dark","fixed","sticky","color","expand"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Navbar', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { light = false } = $$props;
    	let { dark = false } = $$props;
    	let { fixed = '' } = $$props;
    	let { sticky = '' } = $$props;
    	let { color = '' } = $$props;
    	let { expand = '' } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('light' in $$new_props) $$invalidate(3, light = $$new_props.light);
    		if ('dark' in $$new_props) $$invalidate(4, dark = $$new_props.dark);
    		if ('fixed' in $$new_props) $$invalidate(5, fixed = $$new_props.fixed);
    		if ('sticky' in $$new_props) $$invalidate(6, sticky = $$new_props.sticky);
    		if ('color' in $$new_props) $$invalidate(7, color = $$new_props.color);
    		if ('expand' in $$new_props) $$invalidate(8, expand = $$new_props.expand);
    		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		light,
    		dark,
    		fixed,
    		sticky,
    		color,
    		expand,
    		getExpandClass,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('light' in $$props) $$invalidate(3, light = $$new_props.light);
    		if ('dark' in $$props) $$invalidate(4, dark = $$new_props.dark);
    		if ('fixed' in $$props) $$invalidate(5, fixed = $$new_props.fixed);
    		if ('sticky' in $$props) $$invalidate(6, sticky = $$new_props.sticky);
    		if ('color' in $$props) $$invalidate(7, color = $$new_props.color);
    		if ('expand' in $$props) $$invalidate(8, expand = $$new_props.expand);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, expand, light, dark, color, fixed, sticky*/ 508) {
    			$$invalidate(0, classes = classnames(className, 'navbar', getExpandClass(expand), {
    				'navbar-light': light,
    				'navbar-dark': dark,
    				[`bg-${color}`]: color,
    				[`fixed-${fixed}`]: fixed,
    				[`sticky-${sticky}`]: sticky
    			}));
    		}
    	};

    	return [
    		classes,
    		$$restProps,
    		className,
    		light,
    		dark,
    		fixed,
    		sticky,
    		color,
    		expand,
    		$$scope,
    		slots
    	];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$U, create_fragment$U, safe_not_equal, {
    			class: 2,
    			light: 3,
    			dark: 4,
    			fixed: 5,
    			sticky: 6,
    			color: 7,
    			expand: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$U.name
    		});
    	}

    	get class() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get light() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set light(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dark() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dark(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fixed() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fixed(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sticky() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sticky(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expand(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/NavItem.svelte generated by Svelte v3.40.3 */
    const file$L = "node_modules/sveltestrap/src/NavItem.svelte";

    function create_fragment$T(ctx) {
    	let li;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let li_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$L, 10, 0, 219);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","active"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NavItem', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { active = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('active' in $$new_props) $$invalidate(3, active = $$new_props.active);
    		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, active, classes });

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('active' in $$props) $$invalidate(3, active = $$new_props.active);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, active*/ 12) {
    			$$invalidate(0, classes = classnames(className, 'nav-item', active ? 'active' : false));
    		}
    	};

    	return [classes, $$restProps, className, active, $$scope, slots];
    }

    class NavItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, { class: 2, active: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavItem",
    			options,
    			id: create_fragment$T.name
    		});
    	}

    	get class() {
    		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/NavLink.svelte generated by Svelte v3.40.3 */
    const file$K = "node_modules/sveltestrap/src/NavLink.svelte";

    function create_fragment$S(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	let a_levels = [
    		/*$$restProps*/ ctx[3],
    		{ href: /*href*/ ctx[0] },
    		{ class: /*classes*/ ctx[1] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$K, 27, 0, 472);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(a, "click", /*handleClick*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","disabled","active","href"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NavLink', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { disabled = false } = $$props;
    	let { active = false } = $$props;
    	let { href = '#' } = $$props;

    	function handleClick(e) {
    		if (disabled) {
    			e.preventDefault();
    			e.stopImmediatePropagation();
    			return;
    		}

    		if (href === '#') {
    			e.preventDefault();
    		}
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('disabled' in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
    		if ('active' in $$new_props) $$invalidate(6, active = $$new_props.active);
    		if ('href' in $$new_props) $$invalidate(0, href = $$new_props.href);
    		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		disabled,
    		active,
    		href,
    		handleClick,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('disabled' in $$props) $$invalidate(5, disabled = $$new_props.disabled);
    		if ('active' in $$props) $$invalidate(6, active = $$new_props.active);
    		if ('href' in $$props) $$invalidate(0, href = $$new_props.href);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, disabled, active*/ 112) {
    			$$invalidate(1, classes = classnames(className, 'nav-link', { disabled, active }));
    		}
    	};

    	return [
    		href,
    		classes,
    		handleClick,
    		$$restProps,
    		className,
    		disabled,
    		active,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class NavLink extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$S, create_fragment$S, safe_not_equal, {
    			class: 4,
    			disabled: 5,
    			active: 6,
    			href: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavLink",
    			options,
    			id: create_fragment$S.name
    		});
    	}

    	get class() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/NavbarBrand.svelte generated by Svelte v3.40.3 */
    const file$J = "node_modules/sveltestrap/src/NavbarBrand.svelte";

    function create_fragment$R(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	let a_levels = [
    		/*$$restProps*/ ctx[2],
    		{ class: /*classes*/ ctx[1] },
    		{ href: /*href*/ ctx[0] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$J, 10, 0, 192);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","href"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NavbarBrand', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { href = '/' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('href' in $$new_props) $$invalidate(0, href = $$new_props.href);
    		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, href, classes });

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('href' in $$props) $$invalidate(0, href = $$new_props.href);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 8) {
    			$$invalidate(1, classes = classnames(className, 'navbar-brand'));
    		}
    	};

    	return [href, classes, $$restProps, className, $$scope, slots, click_handler];
    }

    class NavbarBrand extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, { class: 3, href: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavbarBrand",
    			options,
    			id: create_fragment$R.name
    		});
    	}

    	get class() {
    		throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/NavbarToggler.svelte generated by Svelte v3.40.3 */
    const file$I = "node_modules/sveltestrap/src/NavbarToggler.svelte";

    // (13:8)      
    function fallback_block$6(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "navbar-toggler-icon");
    			add_location(span, file$I, 13, 4, 274);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$6.name,
    		type: "fallback",
    		source: "(13:8)      ",
    		ctx
    	});

    	return block;
    }

    // (12:0) <Button {...$$restProps} on:click class={classes}>
    function create_default_slot$p(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	const default_slot_or_fallback = default_slot || fallback_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(12:0) <Button {...$$restProps} on:click class={classes}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let button;
    	let current;
    	const button_spread_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];

    	let button_props = {
    		$$slots: { default: [create_default_slot$p] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < button_spread_levels.length; i += 1) {
    		button_props = assign(button_props, button_spread_levels[i]);
    	}

    	button = new Button$1({ props: button_props, $$inline: true });
    	button.$on("click", /*click_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button_changes = (dirty & /*$$restProps, classes*/ 3)
    			? get_spread_update(button_spread_levels, [
    					dirty & /*$$restProps*/ 2 && get_spread_object(/*$$restProps*/ ctx[1]),
    					dirty & /*classes*/ 1 && { class: /*classes*/ ctx[0] }
    				])
    			: {};

    			if (dirty & /*$$scope*/ 32) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NavbarToggler', slots, ['default']);
    	let { class: className = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, Button: Button$1, className, classes });

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 4) {
    			$$invalidate(0, classes = classnames(className, 'navbar-toggler'));
    		}
    	};

    	return [classes, $$restProps, className, slots, click_handler, $$scope];
    }

    class NavbarToggler extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavbarToggler",
    			options,
    			id: create_fragment$Q.name
    		});
    	}

    	get class() {
    		throw new Error("<NavbarToggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NavbarToggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Progress.svelte generated by Svelte v3.40.3 */
    const file$H = "node_modules/sveltestrap/src/Progress.svelte";

    // (43:0) {:else}
    function create_else_block_1$2(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block_2$9, create_else_block_2$2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*multi*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let div_levels = [/*$$restProps*/ ctx[7], { class: /*classes*/ ctx[6] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			set_attributes(div, div_data);
    			add_location(div, file$H, 43, 2, 993);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
    				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(43:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (28:0) {#if bar}
    function create_if_block$p(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$g, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*multi*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(28:0) {#if bar}",
    		ctx
    	});

    	return block;
    }

    // (47:4) {:else}
    function create_else_block_2$2(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*progressBarClasses*/ ctx[5]);
    			set_style(div, "width", /*percent*/ ctx[4] + "%");
    			attr_dev(div, "role", "progressbar");
    			attr_dev(div, "aria-valuenow", /*value*/ ctx[2]);
    			attr_dev(div, "aria-valuemin", "0");
    			attr_dev(div, "aria-valuemax", /*max*/ ctx[3]);
    			add_location(div, file$H, 47, 6, 1081);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*progressBarClasses*/ 32) {
    				attr_dev(div, "class", /*progressBarClasses*/ ctx[5]);
    			}

    			if (!current || dirty & /*percent*/ 16) {
    				set_style(div, "width", /*percent*/ ctx[4] + "%");
    			}

    			if (!current || dirty & /*value*/ 4) {
    				attr_dev(div, "aria-valuenow", /*value*/ ctx[2]);
    			}

    			if (!current || dirty & /*max*/ 8) {
    				attr_dev(div, "aria-valuemax", /*max*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(47:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:4) {#if multi}
    function create_if_block_2$9(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(45:4) {#if multi}",
    		ctx
    	});

    	return block;
    }

    // (31:2) {:else}
    function create_else_block$9(ctx) {
    	let div;
    	let div_style_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	let div_levels = [
    		/*$$restProps*/ ctx[7],
    		{ class: /*progressBarClasses*/ ctx[5] },
    		{
    			style: div_style_value = "width: " + /*percent*/ ctx[4] + "%"
    		},
    		{ role: "progressbar" },
    		{ "aria-valuenow": /*value*/ ctx[2] },
    		{ "aria-valuemin": "0" },
    		{ "aria-valuemax": /*max*/ ctx[3] }
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$H, 31, 4, 752);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
    				(!current || dirty & /*progressBarClasses*/ 32) && { class: /*progressBarClasses*/ ctx[5] },
    				(!current || dirty & /*percent*/ 16 && div_style_value !== (div_style_value = "width: " + /*percent*/ ctx[4] + "%")) && { style: div_style_value },
    				{ role: "progressbar" },
    				(!current || dirty & /*value*/ 4) && { "aria-valuenow": /*value*/ ctx[2] },
    				{ "aria-valuemin": "0" },
    				(!current || dirty & /*max*/ 8) && { "aria-valuemax": /*max*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(31:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (29:2) {#if multi}
    function create_if_block_1$g(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(29:2) {#if multi}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$p, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*bar*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let classes;
    	let progressBarClasses;
    	let percent;

    	const omit_props_names = [
    		"class","bar","multi","value","max","animated","striped","color","barClassName"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Progress', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { bar = false } = $$props;
    	let { multi = false } = $$props;
    	let { value = 0 } = $$props;
    	let { max = 100 } = $$props;
    	let { animated = false } = $$props;
    	let { striped = false } = $$props;
    	let { color = '' } = $$props;
    	let { barClassName = '' } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
    		if ('bar' in $$new_props) $$invalidate(0, bar = $$new_props.bar);
    		if ('multi' in $$new_props) $$invalidate(1, multi = $$new_props.multi);
    		if ('value' in $$new_props) $$invalidate(2, value = $$new_props.value);
    		if ('max' in $$new_props) $$invalidate(3, max = $$new_props.max);
    		if ('animated' in $$new_props) $$invalidate(9, animated = $$new_props.animated);
    		if ('striped' in $$new_props) $$invalidate(10, striped = $$new_props.striped);
    		if ('color' in $$new_props) $$invalidate(11, color = $$new_props.color);
    		if ('barClassName' in $$new_props) $$invalidate(12, barClassName = $$new_props.barClassName);
    		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		bar,
    		multi,
    		value,
    		max,
    		animated,
    		striped,
    		color,
    		barClassName,
    		percent,
    		progressBarClasses,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(8, className = $$new_props.className);
    		if ('bar' in $$props) $$invalidate(0, bar = $$new_props.bar);
    		if ('multi' in $$props) $$invalidate(1, multi = $$new_props.multi);
    		if ('value' in $$props) $$invalidate(2, value = $$new_props.value);
    		if ('max' in $$props) $$invalidate(3, max = $$new_props.max);
    		if ('animated' in $$props) $$invalidate(9, animated = $$new_props.animated);
    		if ('striped' in $$props) $$invalidate(10, striped = $$new_props.striped);
    		if ('color' in $$props) $$invalidate(11, color = $$new_props.color);
    		if ('barClassName' in $$props) $$invalidate(12, barClassName = $$new_props.barClassName);
    		if ('percent' in $$props) $$invalidate(4, percent = $$new_props.percent);
    		if ('progressBarClasses' in $$props) $$invalidate(5, progressBarClasses = $$new_props.progressBarClasses);
    		if ('classes' in $$props) $$invalidate(6, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 256) {
    			$$invalidate(6, classes = classnames(className, 'progress'));
    		}

    		if ($$self.$$.dirty & /*bar, className, barClassName, animated, color, striped*/ 7937) {
    			$$invalidate(5, progressBarClasses = classnames('progress-bar', bar ? className || barClassName : barClassName, animated ? 'progress-bar-animated' : null, color ? `bg-${color}` : null, striped || animated ? 'progress-bar-striped' : null));
    		}

    		if ($$self.$$.dirty & /*value, max*/ 12) {
    			$$invalidate(4, percent = parseInt(value, 10) / parseInt(max, 10) * 100);
    		}
    	};

    	return [
    		bar,
    		multi,
    		value,
    		max,
    		percent,
    		progressBarClasses,
    		classes,
    		$$restProps,
    		className,
    		animated,
    		striped,
    		color,
    		barClassName,
    		$$scope,
    		slots
    	];
    }

    class Progress extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {
    			class: 8,
    			bar: 0,
    			multi: 1,
    			value: 2,
    			max: 3,
    			animated: 9,
    			striped: 10,
    			color: 11,
    			barClassName: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Progress",
    			options,
    			id: create_fragment$P.name
    		});
    	}

    	get class() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bar() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bar(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multi() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multi(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get animated() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animated(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get striped() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set striped(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get barClassName() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set barClassName(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/UncontrolledDropdown.svelte generated by Svelte v3.40.3 */

    // (21:0) <Dropdown   {...$$restProps}   {isOpen}   toggle={() => (isOpen = !isOpen)}   class={className}   {disabled}   {direction}   {group}   {nav}   {active}   {addonType}   {size}   {inNavbar}   {setActiveFromChild}   {dropup}>
    function create_default_slot$o(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(21:0) <Dropdown   {...$$restProps}   {isOpen}   toggle={() => (isOpen = !isOpen)}   class={className}   {disabled}   {direction}   {group}   {nav}   {active}   {addonType}   {size}   {inNavbar}   {setActiveFromChild}   {dropup}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let dropdown;
    	let current;

    	const dropdown_spread_levels = [
    		/*$$restProps*/ ctx[12],
    		{ isOpen: /*isOpen*/ ctx[11] },
    		{ toggle: /*func*/ ctx[15] },
    		{ class: /*className*/ ctx[0] },
    		{ disabled: /*disabled*/ ctx[1] },
    		{ direction: /*direction*/ ctx[2] },
    		{ group: /*group*/ ctx[3] },
    		{ nav: /*nav*/ ctx[4] },
    		{ active: /*active*/ ctx[5] },
    		{ addonType: /*addonType*/ ctx[6] },
    		{ size: /*size*/ ctx[7] },
    		{ inNavbar: /*inNavbar*/ ctx[8] },
    		{
    			setActiveFromChild: /*setActiveFromChild*/ ctx[9]
    		},
    		{ dropup: /*dropup*/ ctx[10] }
    	];

    	let dropdown_props = {
    		$$slots: { default: [create_default_slot$o] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < dropdown_spread_levels.length; i += 1) {
    		dropdown_props = assign(dropdown_props, dropdown_spread_levels[i]);
    	}

    	dropdown = new Dropdown({ props: dropdown_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dropdown.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dropdown_changes = (dirty & /*$$restProps, isOpen, className, disabled, direction, group, nav, active, addonType, size, inNavbar, setActiveFromChild, dropup*/ 8191)
    			? get_spread_update(dropdown_spread_levels, [
    					dirty & /*$$restProps*/ 4096 && get_spread_object(/*$$restProps*/ ctx[12]),
    					dirty & /*isOpen*/ 2048 && { isOpen: /*isOpen*/ ctx[11] },
    					dirty & /*isOpen*/ 2048 && { toggle: /*func*/ ctx[15] },
    					dirty & /*className*/ 1 && { class: /*className*/ ctx[0] },
    					dirty & /*disabled*/ 2 && { disabled: /*disabled*/ ctx[1] },
    					dirty & /*direction*/ 4 && { direction: /*direction*/ ctx[2] },
    					dirty & /*group*/ 8 && { group: /*group*/ ctx[3] },
    					dirty & /*nav*/ 16 && { nav: /*nav*/ ctx[4] },
    					dirty & /*active*/ 32 && { active: /*active*/ ctx[5] },
    					dirty & /*addonType*/ 64 && { addonType: /*addonType*/ ctx[6] },
    					dirty & /*size*/ 128 && { size: /*size*/ ctx[7] },
    					dirty & /*inNavbar*/ 256 && { inNavbar: /*inNavbar*/ ctx[8] },
    					dirty & /*setActiveFromChild*/ 512 && {
    						setActiveFromChild: /*setActiveFromChild*/ ctx[9]
    					},
    					dirty & /*dropup*/ 1024 && { dropup: /*dropup*/ ctx[10] }
    				])
    			: {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdown_changes.$$scope = { dirty, ctx };
    			}

    			dropdown.$set(dropdown_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"class","disabled","direction","group","nav","active","addonType","size","inNavbar","setActiveFromChild","dropup","defaultOpen"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UncontrolledDropdown', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { disabled = false } = $$props;
    	let { direction = 'down' } = $$props;
    	let { group = false } = $$props;
    	let { nav = false } = $$props;
    	let { active = false } = $$props;
    	let { addonType = false } = $$props;
    	let { size = '' } = $$props;
    	let { inNavbar = false } = $$props;
    	let { setActiveFromChild = false } = $$props;
    	let { dropup = false } = $$props;
    	let { defaultOpen = false } = $$props;
    	let isOpen = defaultOpen;
    	const func = () => $$invalidate(11, isOpen = !isOpen);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ('disabled' in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
    		if ('direction' in $$new_props) $$invalidate(2, direction = $$new_props.direction);
    		if ('group' in $$new_props) $$invalidate(3, group = $$new_props.group);
    		if ('nav' in $$new_props) $$invalidate(4, nav = $$new_props.nav);
    		if ('active' in $$new_props) $$invalidate(5, active = $$new_props.active);
    		if ('addonType' in $$new_props) $$invalidate(6, addonType = $$new_props.addonType);
    		if ('size' in $$new_props) $$invalidate(7, size = $$new_props.size);
    		if ('inNavbar' in $$new_props) $$invalidate(8, inNavbar = $$new_props.inNavbar);
    		if ('setActiveFromChild' in $$new_props) $$invalidate(9, setActiveFromChild = $$new_props.setActiveFromChild);
    		if ('dropup' in $$new_props) $$invalidate(10, dropup = $$new_props.dropup);
    		if ('defaultOpen' in $$new_props) $$invalidate(13, defaultOpen = $$new_props.defaultOpen);
    		if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Dropdown,
    		className,
    		disabled,
    		direction,
    		group,
    		nav,
    		active,
    		addonType,
    		size,
    		inNavbar,
    		setActiveFromChild,
    		dropup,
    		defaultOpen,
    		isOpen
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
    		if ('disabled' in $$props) $$invalidate(1, disabled = $$new_props.disabled);
    		if ('direction' in $$props) $$invalidate(2, direction = $$new_props.direction);
    		if ('group' in $$props) $$invalidate(3, group = $$new_props.group);
    		if ('nav' in $$props) $$invalidate(4, nav = $$new_props.nav);
    		if ('active' in $$props) $$invalidate(5, active = $$new_props.active);
    		if ('addonType' in $$props) $$invalidate(6, addonType = $$new_props.addonType);
    		if ('size' in $$props) $$invalidate(7, size = $$new_props.size);
    		if ('inNavbar' in $$props) $$invalidate(8, inNavbar = $$new_props.inNavbar);
    		if ('setActiveFromChild' in $$props) $$invalidate(9, setActiveFromChild = $$new_props.setActiveFromChild);
    		if ('dropup' in $$props) $$invalidate(10, dropup = $$new_props.dropup);
    		if ('defaultOpen' in $$props) $$invalidate(13, defaultOpen = $$new_props.defaultOpen);
    		if ('isOpen' in $$props) $$invalidate(11, isOpen = $$new_props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		className,
    		disabled,
    		direction,
    		group,
    		nav,
    		active,
    		addonType,
    		size,
    		inNavbar,
    		setActiveFromChild,
    		dropup,
    		isOpen,
    		$$restProps,
    		defaultOpen,
    		slots,
    		func,
    		$$scope
    	];
    }

    class UncontrolledDropdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {
    			class: 0,
    			disabled: 1,
    			direction: 2,
    			group: 3,
    			nav: 4,
    			active: 5,
    			addonType: 6,
    			size: 7,
    			inNavbar: 8,
    			setActiveFromChild: 9,
    			dropup: 10,
    			defaultOpen: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UncontrolledDropdown",
    			options,
    			id: create_fragment$O.name
    		});
    	}

    	get class() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nav() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nav(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addonType() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addonType(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inNavbar() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inNavbar(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setActiveFromChild() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set setActiveFromChild(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dropup() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dropup(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get defaultOpen() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set defaultOpen(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap$1(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    function parse(str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules/svelte-spa-router/Router.svelte generated by Svelte v3.40.3 */

    const { Error: Error_1, Object: Object_1$1, console: console_1$5 } = globals;

    // (251:0) {:else}
    function create_else_block$8(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(251:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (244:0) {#if componentParams}
    function create_if_block$o(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(244:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$o, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn('Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading');

    	return wrap$1({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf('#/');

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: '/';

    	// Check if there's a querystring
    	const qsPosition = location.indexOf('?');

    	let querystring = '';

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener('hashchange', update, false);

    	return function stop() {
    		window.removeEventListener('hashchange', update, false);
    	};
    });

    const location = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);
    const params = writable(undefined);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == '#' ? '' : '#') + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == '#' ? '' : '#') + location;

    	try {
    		const newState = { ...history.state };
    		delete newState['__svelte_spa_router_scrollX'];
    		delete newState['__svelte_spa_router_scrollY'];
    		window.history.replaceState(newState, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn('Caught exception while replacing the current page. If you\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.');
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event('hashchange'));
    }

    function link(node, opts) {
    	opts = linkOpts(opts);

    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {
    		throw Error('Action "link" can only be used with <a> tags');
    	}

    	updateLink(node, opts);

    	return {
    		update(updated) {
    			updated = linkOpts(updated);
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, opts) {
    	let href = opts.href || node.getAttribute('href');

    	// Destination must start with '/' or '#/'
    	if (href && href.charAt(0) == '/') {
    		// Add # to the href attribute
    		href = '#' + href;
    	} else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {
    		throw Error('Invalid value for "href" attribute: ' + href);
    	}

    	node.setAttribute('href', href);

    	node.addEventListener('click', event => {
    		// Prevent default anchor onclick behaviour
    		event.preventDefault();

    		if (!opts.disabled) {
    			scrollstateHistoryHandler(event.currentTarget.getAttribute('href'));
    		}
    	});
    }

    // Internal function that ensures the argument of the link action is always an object
    function linkOpts(val) {
    	if (val && typeof val == 'string') {
    		return { href: val };
    	} else {
    		return val || {};
    	}
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {string} href - Destination
     */
    function scrollstateHistoryHandler(href) {
    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router', slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = '' } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true)) {
    				throw Error('Invalid component object');
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == 'string' && (path.length < 1 || path.charAt(0) != '/' && path.charAt(0) != '*') || typeof path == 'object' && !(path instanceof RegExp)) {
    				throw Error('Invalid value for "path" argument - strings must start with / or *');
    			}

    			const { pattern, keys } = parse(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == 'object' && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == 'string') {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || '/';
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || '/';
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	let popStateChanged = null;

    	if (restoreScrollState) {
    		popStateChanged = event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.__svelte_spa_router_scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		};

    		// This is removed in the destroy() invocation below
    		window.addEventListener('popstate', popStateChanged);

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.__svelte_spa_router_scrollX, previousScrollState.__svelte_spa_router_scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	const unsubscribeLoc = loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData,
    				params: match && typeof match == 'object' && Object.keys(match).length
    				? match
    				: null
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick('conditionsFailed', detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoading', Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    						component,
    						name: component.name,
    						params: componentParams
    					}));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == 'object' && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    				component,
    				name: component.name,
    				params: componentParams
    			})).then(() => {
    				params.set(componentParams);
    			});

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    		params.set(undefined);
    	});

    	onDestroy(() => {
    		unsubscribeLoc();
    		popStateChanged && window.removeEventListener('popstate', popStateChanged);
    	});

    	const writable_props = ['routes', 'prefix', 'restoreScrollState'];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$5.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		writable,
    		derived,
    		tick,
    		_wrap: wrap$1,
    		wrap,
    		getLocation,
    		loc,
    		location,
    		querystring,
    		params,
    		push,
    		pop,
    		replace,
    		link,
    		updateLink,
    		linkOpts,
    		scrollstateHistoryHandler,
    		onDestroy,
    		createEventDispatcher,
    		afterUpdate,
    		parse,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		popStateChanged,
    		lastLoc,
    		componentObj,
    		unsubscribeLoc
    	});

    	$$self.$inject_state = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ('component' in $$props) $$invalidate(0, component = $$props.component);
    		if ('componentParams' in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('previousScrollState' in $$props) previousScrollState = $$props.previousScrollState;
    		if ('popStateChanged' in $$props) popStateChanged = $$props.popStateChanged;
    		if ('lastLoc' in $$props) lastLoc = $$props.lastLoc;
    		if ('componentObj' in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			history.scrollRestoration = restoreScrollState ? 'manual' : 'auto';
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$N.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Home/Home.svelte generated by Svelte v3.40.3 */

    const file$G = "src/Home/Home.svelte";

    function create_fragment$M(ctx) {
    	let div1;
    	let div0;
    	let h1;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Welcome to Fortress Images";
    			add_location(h1, file$G, 6, 6, 79);
    			attr_dev(div0, "class", "row");
    			add_location(div0, file$G, 5, 4, 55);
    			attr_dev(div1, "class", "container");
    			add_location(div1, file$G, 4, 0, 27);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    const is_company_selected = writable(false);
    const is_product_selected = writable(false);
    const is_user_selected = writable(false);
    const is_Clicked_start = writable(false);
    const is_Clicked_end = writable(false);
    const is_Clicked_cancel = writable(false);
    const company_selection = writable("");
    const product_selection = writable("");
    const user_selection = writable("");
    const company_search_term = writable("");
    const product_search_term = writable("");
    const user_search_term = writable("");
    const next_step = writable("");
    const contaminants = writable("0");
    const no_contaminants = writable("0");
    const collection_search_term = writable("");
    const collection_id = writable("");



    const image_collection_names = writable([]);
    const matching_company_names = writable([]);
    const matching_product_names = writable([]);
    const matching_user_names = writable([]);
    const plain_pngs_paths = writable([]);
    const sobel_jpgs_paths = writable([]);
    const timestamps = writable({});
    const plain_jpgs_paths = writable([]);
    const batch_number = writable("1");
    const batch_collection = writable([]);
    const machine_location = writable("");
    const product_type = writable("");
    const product_container = writable("");
    const product_weight = writable("");
    const contaminant_boolean = writable(false);
    const contaminant_details = writable("");
    const ready_to_end_batch = writable(false);
    const button_alert_change = writable(false);

    const batch_notes = writable("");

    const completed_batches = writable([]);

    const is_clicked_begin_collection = writable(false);
    const is_clicked_end_collection = writable(true);
    const collection_button_alert = writable(false);
    const new_collection_name = writable("");
    const create_mode_dir = writable("/client/public/simulation_image_data");

    const ready_to_end_collection = writable(false);
    const number_of_jobs_left = writable("");
    const process_to_finish = writable("");

    const ready_to_start_new_batch = writable(true);
    const ready_to_work = writable(true);
    const collection_running = writable(false);
    const batches_left_to_process = writable(false);
    const completed_collections = writable([]);
    const send_end_collection_delete_batches = writable(false);

    const fetching_images = writable(false);
    const ready_to_end_batch_boolean = writable(false);
    const completed_collection = writable([]);
    const collection_ids = writable([]);
    const matching_local_collection_ids = writable([]);

    const completed_batches_update_ready = writable(false);
    const showProcessDialog = writable(false); 
    const matching_local_company_names = writable([]);
    const matching_local_product_names = writable([]);
    const matching_local_user_names = writable([]);
    const local_company_selection = writable("");
    const local_product_selection = writable("");
    const local_user_selection = writable("");
    const local_company_search_term = writable("");
    const local_product_search_term = writable("");
    const local_user_search_term = writable("");
    const local_collection_id = writable("");
    const image_quality = writable("jpg");
    const ending_collection = writable(false);
    // export const socket = writable();
    // function create_Collection_selection() {
    // 	const { subscribe, set} = writable("");

    // 	return {
    // 		subscribe,		
    // 		new: () => set(new_collection)
    // 	};
    // }

    // export const collection_selection = create_Collection_selection();

    /* node_modules/smelte/src/components/Icon/Icon.svelte generated by Svelte v3.40.3 */

    const file$F = "node_modules/smelte/src/components/Icon/Icon.svelte";

    function create_fragment$L(ctx) {
    	let i;
    	let i_class_value;
    	let i_style_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			i = element("i");
    			if (default_slot) default_slot.c();
    			attr_dev(i, "aria-hidden", "true");
    			attr_dev(i, "class", i_class_value = "material-icons icon text-xl select-none " + /*$$props*/ ctx[5].class + " duration-200 ease-in" + " svelte-zzky5a");
    			attr_dev(i, "style", i_style_value = /*color*/ ctx[4] ? `color: ${/*color*/ ctx[4]}` : '');
    			toggle_class(i, "reverse", /*reverse*/ ctx[2]);
    			toggle_class(i, "tip", /*tip*/ ctx[3]);
    			toggle_class(i, "text-base", /*small*/ ctx[0]);
    			toggle_class(i, "text-xs", /*xs*/ ctx[1]);
    			add_location(i, file$F, 20, 0, 273);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (default_slot) {
    				default_slot.m(i, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(i, "click", /*click_handler*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*$$props*/ 32 && i_class_value !== (i_class_value = "material-icons icon text-xl select-none " + /*$$props*/ ctx[5].class + " duration-200 ease-in" + " svelte-zzky5a")) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (!current || dirty & /*color*/ 16 && i_style_value !== (i_style_value = /*color*/ ctx[4] ? `color: ${/*color*/ ctx[4]}` : '')) {
    				attr_dev(i, "style", i_style_value);
    			}

    			if (dirty & /*$$props, reverse*/ 36) {
    				toggle_class(i, "reverse", /*reverse*/ ctx[2]);
    			}

    			if (dirty & /*$$props, tip*/ 40) {
    				toggle_class(i, "tip", /*tip*/ ctx[3]);
    			}

    			if (dirty & /*$$props, small*/ 33) {
    				toggle_class(i, "text-base", /*small*/ ctx[0]);
    			}

    			if (dirty & /*$$props, xs*/ 34) {
    				toggle_class(i, "text-xs", /*xs*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, ['default']);
    	let { small = false } = $$props;
    	let { xs = false } = $$props;
    	let { reverse = false } = $$props;
    	let { tip = false } = $$props;
    	let { color = "default" } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('small' in $$new_props) $$invalidate(0, small = $$new_props.small);
    		if ('xs' in $$new_props) $$invalidate(1, xs = $$new_props.xs);
    		if ('reverse' in $$new_props) $$invalidate(2, reverse = $$new_props.reverse);
    		if ('tip' in $$new_props) $$invalidate(3, tip = $$new_props.tip);
    		if ('color' in $$new_props) $$invalidate(4, color = $$new_props.color);
    		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ small, xs, reverse, tip, color });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ('small' in $$props) $$invalidate(0, small = $$new_props.small);
    		if ('xs' in $$props) $$invalidate(1, xs = $$new_props.xs);
    		if ('reverse' in $$props) $$invalidate(2, reverse = $$new_props.reverse);
    		if ('tip' in $$props) $$invalidate(3, tip = $$new_props.tip);
    		if ('color' in $$props) $$invalidate(4, color = $$new_props.color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [small, xs, reverse, tip, color, $$props, $$scope, slots, click_handler];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {
    			small: 0,
    			xs: 1,
    			reverse: 2,
    			tip: 3,
    			color: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get small() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set small(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xs() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xs(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get reverse() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set reverse(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tip() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tip(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const noDepth = ["white", "black", "transparent"];

    function getClass(prop, color, depth, defaultDepth) {
      if (noDepth.includes(color)) {
        return `${prop}-${color}`;
      }
      return `${prop}-${color}-${depth || defaultDepth} `;
    }

    function utils(color, defaultDepth = 500) {
      return {
        bg: depth => getClass("bg", color, depth, defaultDepth),
        border: depth => getClass("border", color, depth, defaultDepth),
        txt: depth => getClass("text", color, depth, defaultDepth),
        caret: depth => getClass("caret", color, depth, defaultDepth)
      };
    }

    class ClassBuilder {
      constructor(classes, defaultClasses) {
        this.defaults =
          (typeof classes === "function" ? classes(defaultClasses) : classes) ||
          defaultClasses;

        this.classes = this.defaults;
      }

      flush() {
        this.classes = this.defaults;

        return this;
      }

      extend(...fns) {
        return this;
      }

      get() {
        return this.classes;
      }

      replace(classes, cond = true) {
        if (cond && classes) {
          this.classes = Object.keys(classes).reduce(
            (acc, from) => acc.replace(new RegExp(from, "g"), classes[from]),
            this.classes
          );
        }

        return this;
      }

      remove(classes, cond = true) {
        if (cond && classes) {
          this.classes = classes
            .split(" ")
            .reduce(
              (acc, cur) => acc.replace(new RegExp(cur, "g"), ""),
              this.classes
            );
        }

        return this;
      }

      add(className, cond = true, defaultValue) {
        if (!cond || !className) return this;

        switch (typeof className) {
          case "string":
          default:
            this.classes += ` ${className} `;
            return this;
          case "function":
            this.classes += ` ${className(defaultValue || this.classes)} `;
            return this;
        }
      }
    }

    const defaultReserved = ["class", "add", "remove", "replace", "value"];

    function filterProps(reserved, props) {
      const r = [...reserved, ...defaultReserved];

      return Object.keys(props).reduce(
        (acc, cur) =>
          cur.includes("$$") || cur.includes("Class") || r.includes(cur)
            ? acc
            : { ...acc, [cur]: props[cur] },
        {}
      );
    }

    // Thanks Lagden! https://svelte.dev/repl/61d9178d2b9944f2aa2bfe31612ab09f?version=3.6.7
    function ripple(color, centered) {
      return function(event) {
        const target = event.currentTarget;
        const circle = document.createElement("span");
        const d = Math.max(target.clientWidth, target.clientHeight);

        const removeCircle = () => {
          circle.remove();
          circle.removeEventListener("animationend", removeCircle);
        };

        circle.addEventListener("animationend", removeCircle);
        circle.style.width = circle.style.height = `${d}px`;
        const rect = target.getBoundingClientRect();

        if (centered) {
          circle.classList.add(
            "absolute",
            "top-0",
            "left-0",
            "ripple-centered",
            `bg-${color}-transDark`
          );
        } else {
          circle.style.left = `${event.clientX - rect.left - d / 2}px`;
          circle.style.top = `${event.clientY - rect.top - d / 2}px`;

          circle.classList.add("ripple-normal", `bg-${color}-trans`);
        }

        circle.classList.add("ripple");

        target.appendChild(circle);
      };
    }

    function r(color = "primary", centered = false) {
      return function(node) {
        const onMouseDown = ripple(color, centered);
        node.addEventListener("mousedown", onMouseDown);

        return {
          onDestroy: () => node.removeEventListener("mousedown", onMouseDown),
        };
      };
    }

    /* node_modules/smelte/src/components/Button/Button.svelte generated by Svelte v3.40.3 */
    const file$E = "node_modules/smelte/src/components/Button/Button.svelte";

    // (153:0) {:else}
    function create_else_block$7(ctx) {
    	let button;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*icon*/ ctx[3] && create_if_block_2$8(ctx);
    	const default_slot_template = /*#slots*/ ctx[34].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

    	let button_levels = [
    		{ class: /*classes*/ ctx[1] },
    		/*props*/ ctx[9],
    		{ type: /*type*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[2] }
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			button = element("button");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			set_attributes(button, button_data);
    			add_location(button, file$E, 153, 2, 4075);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if (if_block) if_block.m(button, null);
    			append_dev(button, t);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*ripple*/ ctx[8].call(null, button)),
    					listen_dev(button, "click", /*click_handler_3*/ ctx[42], false, false, false),
    					listen_dev(button, "click", /*click_handler_1*/ ctx[38], false, false, false),
    					listen_dev(button, "mouseover", /*mouseover_handler_1*/ ctx[39], false, false, false),
    					listen_dev(button, "*", /*_handler_1*/ ctx[40], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(button, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				(!current || dirty[0] & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				/*props*/ ctx[9],
    				(!current || dirty[0] & /*type*/ 64) && { type: /*type*/ ctx[6] },
    				(!current || dirty[0] & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(153:0) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (131:0) {#if href}
    function create_if_block$n(ctx) {
    	let a;
    	let button;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*icon*/ ctx[3] && create_if_block_1$f(ctx);
    	const default_slot_template = /*#slots*/ ctx[34].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

    	let button_levels = [
    		{ class: /*classes*/ ctx[1] },
    		/*props*/ ctx[9],
    		{ type: /*type*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[2] }
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	let a_levels = [{ href: /*href*/ ctx[5] }, /*props*/ ctx[9]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			a = element("a");
    			button = element("button");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			set_attributes(button, button_data);
    			add_location(button, file$E, 135, 4, 3762);
    			set_attributes(a, a_data);
    			add_location(a, file$E, 131, 2, 3725);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, button);
    			if (if_block) if_block.m(button, null);
    			append_dev(button, t);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*ripple*/ ctx[8].call(null, button)),
    					listen_dev(button, "click", /*click_handler_2*/ ctx[41], false, false, false),
    					listen_dev(button, "click", /*click_handler*/ ctx[35], false, false, false),
    					listen_dev(button, "mouseover", /*mouseover_handler*/ ctx[36], false, false, false),
    					listen_dev(button, "*", /*_handler*/ ctx[37], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(button, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				(!current || dirty[0] & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				/*props*/ ctx[9],
    				(!current || dirty[0] & /*type*/ 64) && { type: /*type*/ ctx[6] },
    				(!current || dirty[0] & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] }
    			]));

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty[0] & /*href*/ 32) && { href: /*href*/ ctx[5] },
    				/*props*/ ctx[9]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(131:0) {#if href}",
    		ctx
    	});

    	return block_1;
    }

    // (165:4) {#if icon}
    function create_if_block_2$8(ctx) {
    	let icon_1;
    	let current;

    	icon_1 = new Icon({
    			props: {
    				class: /*iClasses*/ ctx[7],
    				small: /*small*/ ctx[4],
    				$$slots: { default: [create_default_slot_1$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block_1 = {
    		c: function create() {
    			create_component(icon_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_1_changes = {};
    			if (dirty[0] & /*iClasses*/ 128) icon_1_changes.class = /*iClasses*/ ctx[7];
    			if (dirty[0] & /*small*/ 16) icon_1_changes.small = /*small*/ ctx[4];

    			if (dirty[0] & /*icon*/ 8 | dirty[1] & /*$$scope*/ 4096) {
    				icon_1_changes.$$scope = { dirty, ctx };
    			}

    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(165:4) {#if icon}",
    		ctx
    	});

    	return block_1;
    }

    // (166:6) <Icon class={iClasses} {small}>
    function create_default_slot_1$i(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text(/*icon*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*icon*/ 8) set_data_dev(t, /*icon*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_default_slot_1$i.name,
    		type: "slot",
    		source: "(166:6) <Icon class={iClasses} {small}>",
    		ctx
    	});

    	return block_1;
    }

    // (147:6) {#if icon}
    function create_if_block_1$f(ctx) {
    	let icon_1;
    	let current;

    	icon_1 = new Icon({
    			props: {
    				class: /*iClasses*/ ctx[7],
    				small: /*small*/ ctx[4],
    				$$slots: { default: [create_default_slot$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block_1 = {
    		c: function create() {
    			create_component(icon_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_1_changes = {};
    			if (dirty[0] & /*iClasses*/ 128) icon_1_changes.class = /*iClasses*/ ctx[7];
    			if (dirty[0] & /*small*/ 16) icon_1_changes.small = /*small*/ ctx[4];

    			if (dirty[0] & /*icon*/ 8 | dirty[1] & /*$$scope*/ 4096) {
    				icon_1_changes.$$scope = { dirty, ctx };
    			}

    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(147:6) {#if icon}",
    		ctx
    	});

    	return block_1;
    }

    // (148:8) <Icon class={iClasses} {small}>
    function create_default_slot$n(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text(/*icon*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*icon*/ 8) set_data_dev(t, /*icon*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(148:8) <Icon class={iClasses} {small}>",
    		ctx
    	});

    	return block_1;
    }

    function create_fragment$K(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$n, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block_1;
    }

    const classesDefault$9 = 'z-10 py-2 px-4 uppercase text-sm font-medium relative overflow-hidden';
    const basicDefault = 'text-white duration-200 ease-in';
    const outlinedDefault = 'bg-transparent border border-solid';
    const textDefault = 'bg-transparent border-none px-4 hover:bg-transparent';
    const iconDefault = 'p-4 flex items-center select-none';
    const fabDefault = 'hover:bg-transparent';
    const smallDefault = 'pt-1 pb-1 pl-2 pr-2 text-xs';
    const disabledDefault = 'bg-gray-300 text-gray-500 dark:bg-dark-400 pointer-events-none hover:bg-gray-300 cursor-default';
    const elevationDefault = 'hover:shadow shadow';

    function instance$K($$self, $$props, $$invalidate) {
    	let normal;
    	let lighter;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	let { value = false } = $$props;
    	let { outlined = false } = $$props;
    	let { text = false } = $$props;
    	let { block = false } = $$props;
    	let { disabled = false } = $$props;
    	let { icon = null } = $$props;
    	let { small = false } = $$props;
    	let { light = false } = $$props;
    	let { dark = false } = $$props;
    	let { flat = false } = $$props;
    	let { iconClass = "" } = $$props;
    	let { color = "primary" } = $$props;
    	let { href = null } = $$props;
    	let { fab = false } = $$props;
    	let { type = "button" } = $$props;
    	let { remove = "" } = $$props;
    	let { add = "" } = $$props;
    	let { replace = {} } = $$props;
    	let { classes = classesDefault$9 } = $$props;
    	let { basicClasses = basicDefault } = $$props;
    	let { outlinedClasses = outlinedDefault } = $$props;
    	let { textClasses = textDefault } = $$props;
    	let { iconClasses = iconDefault } = $$props;
    	let { fabClasses = fabDefault } = $$props;
    	let { smallClasses = smallDefault } = $$props;
    	let { disabledClasses = disabledDefault } = $$props;
    	let { elevationClasses = elevationDefault } = $$props;
    	fab = fab || text && icon;
    	const basic = !outlined && !text && !fab;
    	const elevation = (basic || icon) && !disabled && !flat && !text;
    	let Classes = i => i;
    	let iClasses = i => i;
    	let shade = 0;
    	const { bg, border, txt } = utils(color);
    	const cb = new ClassBuilder(classes, classesDefault$9);
    	let iconCb;

    	if (icon) {
    		iconCb = new ClassBuilder(iconClass);
    	}

    	const ripple = r(text || fab || outlined ? color : "white");

    	const props = filterProps(
    		[
    			'outlined',
    			'text',
    			'color',
    			'block',
    			'disabled',
    			'icon',
    			'small',
    			'light',
    			'dark',
    			'flat',
    			'add',
    			'remove',
    			'replace'
    		],
    		$$props
    	);

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function _handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function mouseover_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function _handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler_2 = () => $$invalidate(0, value = !value);
    	const click_handler_3 = () => $$invalidate(0, value = !value);

    	$$self.$$set = $$new_props => {
    		$$invalidate(51, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('outlined' in $$new_props) $$invalidate(11, outlined = $$new_props.outlined);
    		if ('text' in $$new_props) $$invalidate(12, text = $$new_props.text);
    		if ('block' in $$new_props) $$invalidate(13, block = $$new_props.block);
    		if ('disabled' in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('icon' in $$new_props) $$invalidate(3, icon = $$new_props.icon);
    		if ('small' in $$new_props) $$invalidate(4, small = $$new_props.small);
    		if ('light' in $$new_props) $$invalidate(14, light = $$new_props.light);
    		if ('dark' in $$new_props) $$invalidate(15, dark = $$new_props.dark);
    		if ('flat' in $$new_props) $$invalidate(16, flat = $$new_props.flat);
    		if ('iconClass' in $$new_props) $$invalidate(17, iconClass = $$new_props.iconClass);
    		if ('color' in $$new_props) $$invalidate(18, color = $$new_props.color);
    		if ('href' in $$new_props) $$invalidate(5, href = $$new_props.href);
    		if ('fab' in $$new_props) $$invalidate(10, fab = $$new_props.fab);
    		if ('type' in $$new_props) $$invalidate(6, type = $$new_props.type);
    		if ('remove' in $$new_props) $$invalidate(19, remove = $$new_props.remove);
    		if ('add' in $$new_props) $$invalidate(20, add = $$new_props.add);
    		if ('replace' in $$new_props) $$invalidate(21, replace = $$new_props.replace);
    		if ('classes' in $$new_props) $$invalidate(1, classes = $$new_props.classes);
    		if ('basicClasses' in $$new_props) $$invalidate(22, basicClasses = $$new_props.basicClasses);
    		if ('outlinedClasses' in $$new_props) $$invalidate(23, outlinedClasses = $$new_props.outlinedClasses);
    		if ('textClasses' in $$new_props) $$invalidate(24, textClasses = $$new_props.textClasses);
    		if ('iconClasses' in $$new_props) $$invalidate(25, iconClasses = $$new_props.iconClasses);
    		if ('fabClasses' in $$new_props) $$invalidate(26, fabClasses = $$new_props.fabClasses);
    		if ('smallClasses' in $$new_props) $$invalidate(27, smallClasses = $$new_props.smallClasses);
    		if ('disabledClasses' in $$new_props) $$invalidate(28, disabledClasses = $$new_props.disabledClasses);
    		if ('elevationClasses' in $$new_props) $$invalidate(29, elevationClasses = $$new_props.elevationClasses);
    		if ('$$scope' in $$new_props) $$invalidate(43, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		utils,
    		ClassBuilder,
    		filterProps,
    		createRipple: r,
    		value,
    		outlined,
    		text,
    		block,
    		disabled,
    		icon,
    		small,
    		light,
    		dark,
    		flat,
    		iconClass,
    		color,
    		href,
    		fab,
    		type,
    		remove,
    		add,
    		replace,
    		classesDefault: classesDefault$9,
    		basicDefault,
    		outlinedDefault,
    		textDefault,
    		iconDefault,
    		fabDefault,
    		smallDefault,
    		disabledDefault,
    		elevationDefault,
    		classes,
    		basicClasses,
    		outlinedClasses,
    		textClasses,
    		iconClasses,
    		fabClasses,
    		smallClasses,
    		disabledClasses,
    		elevationClasses,
    		basic,
    		elevation,
    		Classes,
    		iClasses,
    		shade,
    		bg,
    		border,
    		txt,
    		cb,
    		iconCb,
    		ripple,
    		props,
    		lighter,
    		normal
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(51, $$props = assign(assign({}, $$props), $$new_props));
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('outlined' in $$props) $$invalidate(11, outlined = $$new_props.outlined);
    		if ('text' in $$props) $$invalidate(12, text = $$new_props.text);
    		if ('block' in $$props) $$invalidate(13, block = $$new_props.block);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('icon' in $$props) $$invalidate(3, icon = $$new_props.icon);
    		if ('small' in $$props) $$invalidate(4, small = $$new_props.small);
    		if ('light' in $$props) $$invalidate(14, light = $$new_props.light);
    		if ('dark' in $$props) $$invalidate(15, dark = $$new_props.dark);
    		if ('flat' in $$props) $$invalidate(16, flat = $$new_props.flat);
    		if ('iconClass' in $$props) $$invalidate(17, iconClass = $$new_props.iconClass);
    		if ('color' in $$props) $$invalidate(18, color = $$new_props.color);
    		if ('href' in $$props) $$invalidate(5, href = $$new_props.href);
    		if ('fab' in $$props) $$invalidate(10, fab = $$new_props.fab);
    		if ('type' in $$props) $$invalidate(6, type = $$new_props.type);
    		if ('remove' in $$props) $$invalidate(19, remove = $$new_props.remove);
    		if ('add' in $$props) $$invalidate(20, add = $$new_props.add);
    		if ('replace' in $$props) $$invalidate(21, replace = $$new_props.replace);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    		if ('basicClasses' in $$props) $$invalidate(22, basicClasses = $$new_props.basicClasses);
    		if ('outlinedClasses' in $$props) $$invalidate(23, outlinedClasses = $$new_props.outlinedClasses);
    		if ('textClasses' in $$props) $$invalidate(24, textClasses = $$new_props.textClasses);
    		if ('iconClasses' in $$props) $$invalidate(25, iconClasses = $$new_props.iconClasses);
    		if ('fabClasses' in $$props) $$invalidate(26, fabClasses = $$new_props.fabClasses);
    		if ('smallClasses' in $$props) $$invalidate(27, smallClasses = $$new_props.smallClasses);
    		if ('disabledClasses' in $$props) $$invalidate(28, disabledClasses = $$new_props.disabledClasses);
    		if ('elevationClasses' in $$props) $$invalidate(29, elevationClasses = $$new_props.elevationClasses);
    		if ('Classes' in $$props) Classes = $$new_props.Classes;
    		if ('iClasses' in $$props) $$invalidate(7, iClasses = $$new_props.iClasses);
    		if ('shade' in $$props) $$invalidate(30, shade = $$new_props.shade);
    		if ('iconCb' in $$props) $$invalidate(31, iconCb = $$new_props.iconCb);
    		if ('lighter' in $$props) $$invalidate(32, lighter = $$new_props.lighter);
    		if ('normal' in $$props) $$invalidate(33, normal = $$new_props.normal);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*light, dark, shade*/ 1073790976) {
    			{
    				$$invalidate(30, shade = light ? 200 : 0);
    				$$invalidate(30, shade = dark ? -400 : shade);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*shade*/ 1073741824) {
    			$$invalidate(33, normal = 500 - shade);
    		}

    		if ($$self.$$.dirty[0] & /*shade*/ 1073741824) {
    			$$invalidate(32, lighter = 400 - shade);
    		}

    		$$invalidate(1, classes = cb.flush().add(basicClasses, basic, basicDefault).add(`${bg(normal)} hover:${bg(lighter)}`, basic).add(elevationClasses, elevation, elevationDefault).add(outlinedClasses, outlined, outlinedDefault).add(`${border(lighter)} ${txt(normal)} hover:${bg("trans")} dark-hover:${bg("transDark")}`, outlined).add(`${txt(lighter)}`, text).add(textClasses, text, textDefault).add(iconClasses, icon, iconDefault).remove("py-2", icon).remove(txt(lighter), fab).add(disabledClasses, disabled, disabledDefault).add(smallClasses, small, smallDefault).add("flex items-center justify-center h-8 w-8", small && icon).add("border-solid", outlined).add("rounded-full", icon).add("w-full", block).add("rounded", basic || outlined || text).add("button", !icon).add(fabClasses, fab, fabDefault).add(`hover:${bg("transLight")}`, fab).add($$props.class).remove(remove).replace(replace).add(add).get());

    		if ($$self.$$.dirty[0] & /*fab, iconClass*/ 132096 | $$self.$$.dirty[1] & /*iconCb*/ 1) {
    			if (iconCb) {
    				$$invalidate(7, iClasses = iconCb.flush().add(txt(), fab && !iconClass).get());
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		value,
    		classes,
    		disabled,
    		icon,
    		small,
    		href,
    		type,
    		iClasses,
    		ripple,
    		props,
    		fab,
    		outlined,
    		text,
    		block,
    		light,
    		dark,
    		flat,
    		iconClass,
    		color,
    		remove,
    		add,
    		replace,
    		basicClasses,
    		outlinedClasses,
    		textClasses,
    		iconClasses,
    		fabClasses,
    		smallClasses,
    		disabledClasses,
    		elevationClasses,
    		shade,
    		iconCb,
    		lighter,
    		normal,
    		slots,
    		click_handler,
    		mouseover_handler,
    		_handler,
    		click_handler_1,
    		mouseover_handler_1,
    		_handler_1,
    		click_handler_2,
    		click_handler_3,
    		$$scope
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$K,
    			create_fragment$K,
    			safe_not_equal,
    			{
    				value: 0,
    				outlined: 11,
    				text: 12,
    				block: 13,
    				disabled: 2,
    				icon: 3,
    				small: 4,
    				light: 14,
    				dark: 15,
    				flat: 16,
    				iconClass: 17,
    				color: 18,
    				href: 5,
    				fab: 10,
    				type: 6,
    				remove: 19,
    				add: 20,
    				replace: 21,
    				classes: 1,
    				basicClasses: 22,
    				outlinedClasses: 23,
    				textClasses: 24,
    				iconClasses: 25,
    				fabClasses: 26,
    				smallClasses: 27,
    				disabledClasses: 28,
    				elevationClasses: 29
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get value() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlined() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlined(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get block() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set block(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get small() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set small(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get light() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set light(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dark() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dark(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flat() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flat(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconClass() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconClass(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fab() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fab(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get remove() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set remove(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get add() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set add(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get basicClasses() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set basicClasses(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlinedClasses() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlinedClasses(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get textClasses() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set textClasses(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconClasses() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconClasses(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fabClasses() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fabClasses(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallClasses() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallClasses(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabledClasses() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabledClasses(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get elevationClasses() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set elevationClasses(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Card/Card.svelte generated by Svelte v3.40.3 */
    const file$D = "node_modules/smelte/src/components/Card/Card.svelte";
    const get_actions_slot_changes$1 = dirty => ({});
    const get_actions_slot_context$1 = ctx => ({});
    const get_text_slot_changes = dirty => ({});
    const get_text_slot_context = ctx => ({});
    const get_media_slot_changes = dirty => ({});
    const get_media_slot_context = ctx => ({});
    const get_title_slot_changes$1 = dirty => ({});
    const get_title_slot_context$1 = ctx => ({});

    function create_fragment$J(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[4].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[3], get_title_slot_context$1);
    	const media_slot_template = /*#slots*/ ctx[4].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[3], get_media_slot_context);
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	const text_slot_template = /*#slots*/ ctx[4].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[3], get_text_slot_context);
    	const actions_slot_template = /*#slots*/ ctx[4].actions;
    	const actions_slot = create_slot(actions_slot_template, ctx, /*$$scope*/ ctx[3], get_actions_slot_context$1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (title_slot) title_slot.c();
    			t0 = space();
    			if (media_slot) media_slot.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (text_slot) text_slot.c();
    			t3 = space();
    			if (actions_slot) actions_slot.c();
    			attr_dev(div, "class", /*c*/ ctx[0]);
    			add_location(div, file$D, 18, 0, 440);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t0);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			append_dev(div, t1);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t2);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (actions_slot) {
    				actions_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[3], dirty, get_title_slot_changes$1),
    						get_title_slot_context$1
    					);
    				}
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[3], dirty, get_media_slot_changes),
    						get_media_slot_context
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[3], dirty, get_text_slot_changes),
    						get_text_slot_context
    					);
    				}
    			}

    			if (actions_slot) {
    				if (actions_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						actions_slot,
    						actions_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(actions_slot_template, /*$$scope*/ ctx[3], dirty, get_actions_slot_changes$1),
    						get_actions_slot_context$1
    					);
    				}
    			}

    			if (!current || dirty & /*c*/ 1) {
    				attr_dev(div, "class", /*c*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			transition_in(media_slot, local);
    			transition_in(default_slot, local);
    			transition_in(text_slot, local);
    			transition_in(actions_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			transition_out(media_slot, local);
    			transition_out(default_slot, local);
    			transition_out(text_slot, local);
    			transition_out(actions_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    			if (media_slot) media_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			if (text_slot) text_slot.d(detaching);
    			if (actions_slot) actions_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const classesDefault$8 = "rounded inline-flex flex-col overflow-hidden duration-200 ease-in";

    function instance$J($$self, $$props, $$invalidate) {
    	let c;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card', slots, ['title','media','default','text','actions']);
    	let { hover = true } = $$props;
    	let { classes = classesDefault$8 } = $$props;
    	const cb = new ClassBuilder(classes, classesDefault$8);

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('hover' in $$new_props) $$invalidate(1, hover = $$new_props.hover);
    		if ('classes' in $$new_props) $$invalidate(2, classes = $$new_props.classes);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ClassBuilder,
    		classesDefault: classesDefault$8,
    		hover,
    		classes,
    		cb,
    		c
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ('hover' in $$props) $$invalidate(1, hover = $$new_props.hover);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    		if ('c' in $$props) $$invalidate(0, c = $$new_props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(0, c = cb.flush().add(`shadow-sm hover:shadow`, hover).add(classes, true, classesDefault$8).add($$props.class).get());
    	};

    	$$props = exclude_internal_props($$props);
    	return [c, hover, classes, $$scope, slots];
    }

    class Card$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, { hover: 1, classes: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get hover() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hover(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Card/Title.svelte generated by Svelte v3.40.3 */
    const file$C = "node_modules/smelte/src/components/Card/Title.svelte";

    function create_fragment$I(ctx) {
    	let div4;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div3;
    	let div1;
    	let t1;
    	let t2;
    	let div2;
    	let t3;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div3 = element("div");
    			div1 = element("div");
    			t1 = text(/*title*/ ctx[0]);
    			t2 = space();
    			div2 = element("div");
    			t3 = text(/*subheader*/ ctx[1]);
    			attr_dev(img, "class", "rounded-full");
    			attr_dev(img, "width", "44");
    			attr_dev(img, "height", "44");
    			if (!src_url_equal(img.src, img_src_value = /*avatar*/ ctx[2])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "avatar");
    			toggle_class(img, "hidden", !/*avatar*/ ctx[2]);
    			add_location(img, file$C, 24, 4, 472);
    			add_location(div0, file$C, 23, 2, 462);
    			attr_dev(div1, "class", "font-medium text-lg");
    			toggle_class(div1, "hidden", !/*title*/ ctx[0]);
    			add_location(div1, file$C, 33, 4, 648);
    			attr_dev(div2, "class", "text-sm text-gray-600 pt-0");
    			toggle_class(div2, "hidden", !/*subheader*/ ctx[1]);
    			add_location(div2, file$C, 34, 4, 721);
    			attr_dev(div3, "class", "pl-4 py-2");
    			add_location(div3, file$C, 32, 2, 620);
    			attr_dev(div4, "class", /*c*/ ctx[3]);
    			add_location(div4, file$C, 22, 0, 444);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div0, img);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, t1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, t3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*avatar*/ 4 && !src_url_equal(img.src, img_src_value = /*avatar*/ ctx[2])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*avatar*/ 4) {
    				toggle_class(img, "hidden", !/*avatar*/ ctx[2]);
    			}

    			if (dirty & /*title*/ 1) set_data_dev(t1, /*title*/ ctx[0]);

    			if (dirty & /*title*/ 1) {
    				toggle_class(div1, "hidden", !/*title*/ ctx[0]);
    			}

    			if (dirty & /*subheader*/ 2) set_data_dev(t3, /*subheader*/ ctx[1]);

    			if (dirty & /*subheader*/ 2) {
    				toggle_class(div2, "hidden", !/*subheader*/ ctx[1]);
    			}

    			if (dirty & /*c*/ 8) {
    				attr_dev(div4, "class", /*c*/ ctx[3]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const classesDefault$7 = "flex px-4 py-2 items-center";

    function instance$I($$self, $$props, $$invalidate) {
    	let c;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Title', slots, []);
    	const hover = true;
    	let { title = "" } = $$props;
    	let { subheader = "" } = $$props;
    	let { avatar = "" } = $$props;
    	let { classes = classesDefault$7 } = $$props;
    	const cb = new ClassBuilder(classes, classesDefault$7);

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('title' in $$new_props) $$invalidate(0, title = $$new_props.title);
    		if ('subheader' in $$new_props) $$invalidate(1, subheader = $$new_props.subheader);
    		if ('avatar' in $$new_props) $$invalidate(2, avatar = $$new_props.avatar);
    		if ('classes' in $$new_props) $$invalidate(5, classes = $$new_props.classes);
    	};

    	$$self.$capture_state = () => ({
    		ClassBuilder,
    		hover,
    		title,
    		subheader,
    		avatar,
    		classesDefault: classesDefault$7,
    		classes,
    		cb,
    		c
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ('title' in $$props) $$invalidate(0, title = $$new_props.title);
    		if ('subheader' in $$props) $$invalidate(1, subheader = $$new_props.subheader);
    		if ('avatar' in $$props) $$invalidate(2, avatar = $$new_props.avatar);
    		if ('classes' in $$props) $$invalidate(5, classes = $$new_props.classes);
    		if ('c' in $$props) $$invalidate(3, c = $$new_props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(3, c = cb.flush().add(classes, true, classesDefault$7).add($$props.class).get());
    	};

    	$$props = exclude_internal_props($$props);
    	return [title, subheader, avatar, c, hover, classes];
    }

    class Title extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
    			hover: 4,
    			title: 0,
    			subheader: 1,
    			avatar: 2,
    			classes: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Title",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get hover() {
    		return this.$$.ctx[4];
    	}

    	set hover(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subheader() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subheader(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get avatar() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set avatar(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Card = {
      Card: Card$1,
      Title
    };

    /* node_modules/smelte/src/components/Chip/Chip.svelte generated by Svelte v3.40.3 */
    const file$B = "node_modules/smelte/src/components/Chip/Chip.svelte";

    // (76:0) {#if value}
    function create_if_block$m(ctx) {
    	let span1;
    	let button;
    	let t0;
    	let span0;
    	let t1;
    	let span1_class_value;
    	let span1_outro;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*icon*/ ctx[2] && create_if_block_2$7(ctx);
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
    	let if_block1 = /*removable*/ ctx[1] && create_if_block_1$e(ctx);
    	let button_levels = [{ class: /*classes*/ ctx[6] }, /*props*/ ctx[11]];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			button = element("button");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			span0 = element("span");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(span0, "class", "px-2 text-sm");
    			add_location(span0, file$B, 88, 6, 1996);
    			set_attributes(button, button_data);
    			toggle_class(button, "svelte-ixci48", true);
    			add_location(button, file$B, 77, 4, 1757);
    			attr_dev(span1, "class", span1_class_value = "" + (/*c*/ ctx[4] + " mx-1 inline-block" + " svelte-ixci48"));
    			add_location(span1, file$B, 76, 2, 1686);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, button);
    			if (if_block0) if_block0.m(button, null);
    			append_dev(button, t0);
    			append_dev(button, span0);

    			if (default_slot) {
    				default_slot.m(span0, null);
    			}

    			append_dev(button, t1);
    			if (if_block1) if_block1.m(button, null);
    			if (button.autofocus) button.focus();
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler*/ ctx[19], false, false, false),
    					action_destroyer(/*ripple*/ ctx[7].call(null, button)),
    					listen_dev(button, "click", /*select*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*icon*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(button, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[20],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*removable*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*removable*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$e(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(button, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
    				/*props*/ ctx[11]
    			]));

    			toggle_class(button, "svelte-ixci48", true);

    			if (!current || dirty & /*c*/ 16 && span1_class_value !== (span1_class_value = "" + (/*c*/ ctx[4] + " mx-1 inline-block" + " svelte-ixci48"))) {
    				attr_dev(span1, "class", span1_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			transition_in(if_block1);
    			if (span1_outro) span1_outro.end(1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			transition_out(if_block1);
    			span1_outro = create_out_transition(span1, scale, { duration: 100 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    			if (if_block0) if_block0.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (detaching && span1_outro) span1_outro.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(76:0) {#if value}",
    		ctx
    	});

    	return block;
    }

    // (84:6) {#if icon}
    function create_if_block_2$7(ctx) {
    	let icon_1;
    	let current;

    	icon_1 = new Icon({
    			props: {
    				small: true,
    				class: /*selected*/ ctx[0]
    				? /*txt*/ ctx[10](400)
    				: 'text-gray-600',
    				$$slots: { default: [create_default_slot_1$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_1_changes = {};

    			if (dirty & /*selected*/ 1) icon_1_changes.class = /*selected*/ ctx[0]
    			? /*txt*/ ctx[10](400)
    			: 'text-gray-600';

    			if (dirty & /*$$scope, icon*/ 1048580) {
    				icon_1_changes.$$scope = { dirty, ctx };
    			}

    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(84:6) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (85:8) <Icon small class={selected ? txt(400) : 'text-gray-600'}>
    function create_default_slot_1$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*icon*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*icon*/ 4) set_data_dev(t, /*icon*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$h.name,
    		type: "slot",
    		source: "(85:8) <Icon small class={selected ? txt(400) : 'text-gray-600'}>",
    		ctx
    	});

    	return block;
    }

    // (92:6) {#if removable}
    function create_if_block_1$e(ctx) {
    	let span;
    	let icon_1;
    	let span_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	icon_1 = new Icon({
    			props: {
    				class: "text-white dark:text-white",
    				xs: true,
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon_1.$$.fragment);
    			attr_dev(span, "class", span_class_value = "rounded-full p-1/2 inline-flex items-center cursor-pointer " + /*iconClass*/ ctx[5] + " svelte-ixci48");
    			add_location(span, file$B, 92, 8, 2085);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon_1, span, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", stop_propagation(/*close*/ ctx[8]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const icon_1_changes = {};

    			if (dirty & /*$$scope*/ 1048576) {
    				icon_1_changes.$$scope = { dirty, ctx };
    			}

    			icon_1.$set(icon_1_changes);

    			if (!current || dirty & /*iconClass*/ 32 && span_class_value !== (span_class_value = "rounded-full p-1/2 inline-flex items-center cursor-pointer " + /*iconClass*/ ctx[5] + " svelte-ixci48")) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon_1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(92:6) {#if removable}",
    		ctx
    	});

    	return block;
    }

    // (96:10) <Icon class="text-white dark:text-white" xs>
    function create_default_slot$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("clear");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(96:10) <Icon class=\\\"text-white dark:text-white\\\" xs>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*value*/ ctx[3] && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*value*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*value*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let ripple;
    	let classes;
    	let iconClass;
    	let c;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Chip', slots, ['default']);
    	let { removable = false } = $$props;
    	let { icon = "" } = $$props;
    	let { outlined = false } = $$props;
    	let { selected = false } = $$props;
    	let { selectable = true } = $$props;
    	let { color = "primary" } = $$props;
    	let { remove = "" } = $$props;
    	let { add = "" } = $$props;
    	let { replace = {} } = $$props;
    	let value = true;
    	const dispatch = createEventDispatcher();

    	function close() {
    		dispatch("close");
    		$$invalidate(3, value = false);
    	}

    	function select() {
    		if (!selectable) return;
    		$$invalidate(0, selected = true);
    	}

    	const { bg, txt, border } = utils(color);
    	const cb = new ClassBuilder();
    	const props = filterProps(['removable', 'icon', 'outlined', 'selected', 'selectable', 'color'], $$props);

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(25, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('removable' in $$new_props) $$invalidate(1, removable = $$new_props.removable);
    		if ('icon' in $$new_props) $$invalidate(2, icon = $$new_props.icon);
    		if ('outlined' in $$new_props) $$invalidate(12, outlined = $$new_props.outlined);
    		if ('selected' in $$new_props) $$invalidate(0, selected = $$new_props.selected);
    		if ('selectable' in $$new_props) $$invalidate(13, selectable = $$new_props.selectable);
    		if ('color' in $$new_props) $$invalidate(14, color = $$new_props.color);
    		if ('remove' in $$new_props) $$invalidate(15, remove = $$new_props.remove);
    		if ('add' in $$new_props) $$invalidate(16, add = $$new_props.add);
    		if ('replace' in $$new_props) $$invalidate(17, replace = $$new_props.replace);
    		if ('$$scope' in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		scale,
    		createRipple: r,
    		utils,
    		ClassBuilder,
    		filterProps,
    		Icon,
    		removable,
    		icon,
    		outlined,
    		selected,
    		selectable,
    		color,
    		remove,
    		add,
    		replace,
    		value,
    		dispatch,
    		close,
    		select,
    		bg,
    		txt,
    		border,
    		cb,
    		props,
    		c,
    		iconClass,
    		classes,
    		ripple
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(25, $$props = assign(assign({}, $$props), $$new_props));
    		if ('removable' in $$props) $$invalidate(1, removable = $$new_props.removable);
    		if ('icon' in $$props) $$invalidate(2, icon = $$new_props.icon);
    		if ('outlined' in $$props) $$invalidate(12, outlined = $$new_props.outlined);
    		if ('selected' in $$props) $$invalidate(0, selected = $$new_props.selected);
    		if ('selectable' in $$props) $$invalidate(13, selectable = $$new_props.selectable);
    		if ('color' in $$props) $$invalidate(14, color = $$new_props.color);
    		if ('remove' in $$props) $$invalidate(15, remove = $$new_props.remove);
    		if ('add' in $$props) $$invalidate(16, add = $$new_props.add);
    		if ('replace' in $$props) $$invalidate(17, replace = $$new_props.replace);
    		if ('value' in $$props) $$invalidate(3, value = $$new_props.value);
    		if ('c' in $$props) $$invalidate(4, c = $$new_props.c);
    		if ('iconClass' in $$props) $$invalidate(5, iconClass = $$new_props.iconClass);
    		if ('classes' in $$props) $$invalidate(6, classes = $$new_props.classes);
    		if ('ripple' in $$props) $$invalidate(7, ripple = $$new_props.ripple);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*color*/ 16384) {
    			$$invalidate(7, ripple = r(color));
    		}

    		if ($$self.$$.dirty & /*outlined, selected, remove, replace, add*/ 233473) {
    			$$invalidate(6, classes = cb.flush().add('relative overflow-hidden flex items-center rounded-full px-2 py-1').add('bg-transparent border', outlined).add('border-gray-400 border-solid hover:bg-gray-100 dark-hover:bg-dark-400 bg-gray-300 dark:bg-dark-600', !selected).add(`${border()} dark:${border('800')} ${txt()} ${bg(100)} hover:${bg(50)}`, selected).remove(remove).replace(replace).add(add).get());
    		}

    		if ($$self.$$.dirty & /*selected*/ 1) {
    			$$invalidate(5, iconClass = selected
    			? `hover:${bg(300)} ${bg(400)}`
    			: "hover:bg-gray-400 bg-gray-500 dark:bg-gray-800");
    		}

    		$$invalidate(4, c = cb.flush().add($$props.class).get());
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		selected,
    		removable,
    		icon,
    		value,
    		c,
    		iconClass,
    		classes,
    		ripple,
    		close,
    		select,
    		txt,
    		props,
    		outlined,
    		selectable,
    		color,
    		remove,
    		add,
    		replace,
    		slots,
    		click_handler,
    		$$scope
    	];
    }

    class Chip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {
    			removable: 1,
    			icon: 2,
    			outlined: 12,
    			selected: 0,
    			selectable: 13,
    			color: 14,
    			remove: 15,
    			add: 16,
    			replace: 17
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Chip",
    			options,
    			id: create_fragment$H.name
    		});
    	}

    	get removable() {
    		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set removable(value) {
    		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlined() {
    		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlined(value) {
    		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectable() {
    		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectable(value) {
    		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get remove() {
    		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set remove(value) {
    		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get add() {
    		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set add(value) {
    		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Util/Scrim.svelte generated by Svelte v3.40.3 */
    const file$A = "node_modules/smelte/src/components/Util/Scrim.svelte";

    function create_fragment$G(ctx) {
    	let div;
    	let div_intro;
    	let div_outro;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "bg-black fixed top-0 left-0 z-10 w-full h-full");
    			set_style(div, "opacity", /*opacity*/ ctx[0]);
    			add_location(div, file$A, 9, 0, 262);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (!current || dirty & /*opacity*/ 1) {
    				set_style(div, "opacity", /*opacity*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				div_intro = create_in_transition(div, fade, /*inProps*/ ctx[1]);
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, fade, /*outProps*/ ctx[2]);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_outro) div_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Scrim', slots, []);
    	let { opacity = 0.5 } = $$props;
    	let { inProps = { duration: 200, easing: quadIn } } = $$props;
    	let { outProps = { duration: 200, easing: quadOut } } = $$props;
    	const writable_props = ['opacity', 'inProps', 'outProps'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Scrim> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('opacity' in $$props) $$invalidate(0, opacity = $$props.opacity);
    		if ('inProps' in $$props) $$invalidate(1, inProps = $$props.inProps);
    		if ('outProps' in $$props) $$invalidate(2, outProps = $$props.outProps);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		quadOut,
    		quadIn,
    		opacity,
    		inProps,
    		outProps
    	});

    	$$self.$inject_state = $$props => {
    		if ('opacity' in $$props) $$invalidate(0, opacity = $$props.opacity);
    		if ('inProps' in $$props) $$invalidate(1, inProps = $$props.inProps);
    		if ('outProps' in $$props) $$invalidate(2, outProps = $$props.outProps);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [opacity, inProps, outProps, click_handler];
    }

    class Scrim$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { opacity: 0, inProps: 1, outProps: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Scrim",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get opacity() {
    		throw new Error("<Scrim>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Scrim>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inProps() {
    		throw new Error("<Scrim>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inProps(value) {
    		throw new Error("<Scrim>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outProps() {
    		throw new Error("<Scrim>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outProps(value) {
    		throw new Error("<Scrim>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const Scrim = Scrim$1;

    /* node_modules/smelte/src/components/Dialog/Dialog.svelte generated by Svelte v3.40.3 */
    const file$z = "node_modules/smelte/src/components/Dialog/Dialog.svelte";
    const get_actions_slot_changes = dirty => ({});
    const get_actions_slot_context = ctx => ({});
    const get_title_slot_changes = dirty => ({});
    const get_title_slot_context = ctx => ({});

    // (45:0) {#if value}
    function create_if_block$l(ctx) {
    	let div4;
    	let scrim;
    	let t0;
    	let div3;
    	let div2;
    	let div0;
    	let t1;
    	let t2;
    	let div1;
    	let div2_intro;
    	let current;

    	scrim = new Scrim({
    			props: { opacity: /*opacity*/ ctx[1] },
    			$$inline: true
    		});

    	scrim.$on("click", /*click_handler*/ ctx[12]);
    	const title_slot_template = /*#slots*/ ctx[11].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[10], get_title_slot_context);
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
    	const actions_slot_template = /*#slots*/ ctx[11].actions;
    	const actions_slot = create_slot(actions_slot_template, ctx, /*$$scope*/ ctx[10], get_actions_slot_context);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			create_component(scrim.$$.fragment);
    			t0 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			if (title_slot) title_slot.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			div1 = element("div");
    			if (actions_slot) actions_slot.c();
    			attr_dev(div0, "class", /*t*/ ctx[5]);
    			add_location(div0, file$z, 51, 8, 1518);
    			attr_dev(div1, "class", /*a*/ ctx[4]);
    			add_location(div1, file$z, 55, 8, 1606);
    			attr_dev(div2, "class", /*c*/ ctx[6]);
    			add_location(div2, file$z, 48, 6, 1451);
    			attr_dev(div3, "class", "h-full w-full absolute flex items-center justify-center");
    			add_location(div3, file$z, 47, 4, 1375);
    			attr_dev(div4, "class", "fixed w-full h-full top-0 left-0 z-30");
    			add_location(div4, file$z, 45, 2, 1247);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			mount_component(scrim, div4, null);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div0);

    			if (title_slot) {
    				title_slot.m(div0, null);
    			}

    			append_dev(div2, t1);

    			if (default_slot) {
    				default_slot.m(div2, null);
    			}

    			append_dev(div2, t2);
    			append_dev(div2, div1);

    			if (actions_slot) {
    				actions_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const scrim_changes = {};
    			if (dirty & /*opacity*/ 2) scrim_changes.opacity = /*opacity*/ ctx[1];
    			scrim.$set(scrim_changes);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[10], dirty, get_title_slot_changes),
    						get_title_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*t*/ 32) {
    				attr_dev(div0, "class", /*t*/ ctx[5]);
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
    						null
    					);
    				}
    			}

    			if (actions_slot) {
    				if (actions_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						actions_slot,
    						actions_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(actions_slot_template, /*$$scope*/ ctx[10], dirty, get_actions_slot_changes),
    						get_actions_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*a*/ 16) {
    				attr_dev(div1, "class", /*a*/ ctx[4]);
    			}

    			if (!current || dirty & /*c*/ 64) {
    				attr_dev(div2, "class", /*c*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scrim.$$.fragment, local);
    			transition_in(title_slot, local);
    			transition_in(default_slot, local);
    			transition_in(actions_slot, local);

    			if (!div2_intro) {
    				add_render_callback(() => {
    					div2_intro = create_in_transition(div2, scale, /*transitionProps*/ ctx[3]);
    					div2_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scrim.$$.fragment, local);
    			transition_out(title_slot, local);
    			transition_out(default_slot, local);
    			transition_out(actions_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(scrim);
    			if (title_slot) title_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			if (actions_slot) actions_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(45:0) {#if value}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*value*/ ctx[0] && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*value*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*value*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const classesDefault$6 = "items-center z-50 rounded bg-white dark:bg-dark-400 p-4 shadow";
    const titleClassesDefault = "text-lg font-bold pb-4";
    const actionsClassesDefault = "flex w-full justify-end pt-4";

    function instance$F($$self, $$props, $$invalidate) {
    	let c;
    	let t;
    	let a;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dialog', slots, ['title','default','actions']);
    	let { value } = $$props;
    	let { classes = classesDefault$6 } = $$props;
    	let { titleClasses = titleClassesDefault } = $$props;
    	let { actionsClasses = actionsClassesDefault } = $$props;
    	let { opacity = 0.5 } = $$props;
    	let { persistent = false } = $$props;

    	let { transitionProps = {
    		duration: 150,
    		easing: quadIn,
    		delay: 150
    	} } = $$props;

    	const cb = new ClassBuilder(classes, classesDefault$6);
    	const tcb = new ClassBuilder(titleClasses, titleClassesDefault);
    	const acb = new ClassBuilder(actionsClasses, actionsClassesDefault);
    	const click_handler = () => !persistent && $$invalidate(0, value = false);

    	$$self.$$set = $$new_props => {
    		$$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('classes' in $$new_props) $$invalidate(7, classes = $$new_props.classes);
    		if ('titleClasses' in $$new_props) $$invalidate(8, titleClasses = $$new_props.titleClasses);
    		if ('actionsClasses' in $$new_props) $$invalidate(9, actionsClasses = $$new_props.actionsClasses);
    		if ('opacity' in $$new_props) $$invalidate(1, opacity = $$new_props.opacity);
    		if ('persistent' in $$new_props) $$invalidate(2, persistent = $$new_props.persistent);
    		if ('transitionProps' in $$new_props) $$invalidate(3, transitionProps = $$new_props.transitionProps);
    		if ('$$scope' in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		scale,
    		onMount,
    		quadIn,
    		Scrim,
    		ClassBuilder,
    		classesDefault: classesDefault$6,
    		titleClassesDefault,
    		actionsClassesDefault,
    		value,
    		classes,
    		titleClasses,
    		actionsClasses,
    		opacity,
    		persistent,
    		transitionProps,
    		cb,
    		tcb,
    		acb,
    		a,
    		t,
    		c
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(16, $$props = assign(assign({}, $$props), $$new_props));
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('classes' in $$props) $$invalidate(7, classes = $$new_props.classes);
    		if ('titleClasses' in $$props) $$invalidate(8, titleClasses = $$new_props.titleClasses);
    		if ('actionsClasses' in $$props) $$invalidate(9, actionsClasses = $$new_props.actionsClasses);
    		if ('opacity' in $$props) $$invalidate(1, opacity = $$new_props.opacity);
    		if ('persistent' in $$props) $$invalidate(2, persistent = $$new_props.persistent);
    		if ('transitionProps' in $$props) $$invalidate(3, transitionProps = $$new_props.transitionProps);
    		if ('a' in $$props) $$invalidate(4, a = $$new_props.a);
    		if ('t' in $$props) $$invalidate(5, t = $$new_props.t);
    		if ('c' in $$props) $$invalidate(6, c = $$new_props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(6, c = cb.flush().add(classes, true, classesDefault$6).add($$props.class).get());

    		if ($$self.$$.dirty & /*titleClasses*/ 256) {
    			$$invalidate(5, t = tcb.flush().add(titleClasses, true, actionsClassesDefault).get());
    		}

    		if ($$self.$$.dirty & /*actionsClasses*/ 512) {
    			$$invalidate(4, a = acb.flush().add(actionsClasses, true, actionsClassesDefault).get());
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		value,
    		opacity,
    		persistent,
    		transitionProps,
    		a,
    		t,
    		c,
    		classes,
    		titleClasses,
    		actionsClasses,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class Dialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
    			value: 0,
    			classes: 7,
    			titleClasses: 8,
    			actionsClasses: 9,
    			opacity: 1,
    			persistent: 2,
    			transitionProps: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dialog",
    			options,
    			id: create_fragment$F.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
    			console.warn("<Dialog> was created without expected prop 'value'");
    		}
    	}

    	get value() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleClasses() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleClasses(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get actionsClasses() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionsClasses(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get persistent() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set persistent(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionProps() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionProps(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-waypoint/src/Waypoint.svelte generated by Svelte v3.40.3 */
    const file$y = "node_modules/svelte-waypoint/src/Waypoint.svelte";

    // (139:2) {#if visible}
    function create_if_block$k(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(139:2) {#if visible}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*visible*/ ctx[3] && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", div_class_value = "wrapper " + /*className*/ ctx[2] + " " + /*c*/ ctx[0] + " svelte-142y8oi");
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			add_location(div, file$y, 137, 0, 3091);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*waypoint*/ ctx[4].call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*visible*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*visible*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$k(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*className, c*/ 5 && div_class_value !== (div_class_value = "wrapper " + /*className*/ ctx[2] + " " + /*c*/ ctx[0] + " svelte-142y8oi")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function throttleFn(fn, time) {
    	let last, deferTimer;

    	return () => {
    		const now = +new Date();

    		if (last && now < last + time) {
    			// hold on to it
    			clearTimeout(deferTimer);

    			deferTimer = setTimeout(
    				function () {
    					last = now;
    					fn();
    				},
    				time
    			);
    		} else {
    			last = now;
    			fn();
    		}
    	};
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Waypoint', slots, ['default']);
    	const dispatch = createEventDispatcher();
    	let { offset = 0 } = $$props;
    	let { throttle = 250 } = $$props;
    	let { c = '' } = $$props;
    	let { style = '' } = $$props;
    	let { once = true } = $$props;
    	let { threshold = 1.0 } = $$props;
    	let { disabled = false } = $$props;
    	let { class: className = "" } = $$props;
    	let visible = disabled;
    	let wasVisible = false;
    	let intersecting = false;

    	let removeHandlers = () => {
    		
    	};

    	function callEvents(wasVisible, observer, node) {
    		if (visible && !wasVisible) {
    			dispatch('enter');
    			return;
    		}

    		if (wasVisible && !intersecting) {
    			dispatch('leave');
    		}

    		if (once && wasVisible && !intersecting) {
    			removeHandlers();
    		}
    	}

    	function waypoint(node) {
    		if (!window || disabled) return;

    		if (window.IntersectionObserver && window.IntersectionObserverEntry) {
    			const observer = new IntersectionObserver(([{ isIntersecting }]) => {
    					wasVisible = visible;
    					intersecting = isIntersecting;

    					if (wasVisible && once && !isIntersecting) {
    						callEvents(wasVisible);
    						return;
    					}

    					$$invalidate(3, visible = isIntersecting);
    					callEvents(wasVisible);
    				},
    			{ rootMargin: offset + 'px', threshold });

    			observer.observe(node);
    			removeHandlers = () => observer.unobserve(node);
    			return removeHandlers;
    		}

    		function checkIsVisible() {
    			// Kudos https://github.com/twobin/react-lazyload/blob/master/src/index.jsx#L93
    			if (!(node.offsetWidth || node.offsetHeight || node.getClientRects().length)) return;

    			let top;
    			let height;

    			try {
    				({ top, height } = node.getBoundingClientRect());
    			} catch(e) {
    				({ top, height } = defaultBoundingClientRect);
    			}

    			const windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;
    			wasVisible = visible;
    			intersecting = top - offset <= windowInnerHeight && top + height + offset >= 0;

    			if (wasVisible && once && !isIntersecting) {
    				callEvents(wasVisible, observer);
    				return;
    			}

    			$$invalidate(3, visible = intersecting);
    			callEvents(wasVisible);
    		}

    		checkIsVisible();
    		const throttled = throttleFn(checkIsVisible, throttle);
    		window.addEventListener('scroll', throttled);
    		window.addEventListener('resize', throttled);

    		removeHandlers = () => {
    			window.removeEventListener('scroll', throttled);
    			window.removeEventListener('resize', throttled);
    		};

    		return removeHandlers;
    	}

    	const writable_props = ['offset', 'throttle', 'c', 'style', 'once', 'threshold', 'disabled', 'class'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Waypoint> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('offset' in $$props) $$invalidate(5, offset = $$props.offset);
    		if ('throttle' in $$props) $$invalidate(6, throttle = $$props.throttle);
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('once' in $$props) $$invalidate(7, once = $$props.once);
    		if ('threshold' in $$props) $$invalidate(8, threshold = $$props.threshold);
    		if ('disabled' in $$props) $$invalidate(9, disabled = $$props.disabled);
    		if ('class' in $$props) $$invalidate(2, className = $$props.class);
    		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onDestroy,
    		dispatch,
    		offset,
    		throttle,
    		c,
    		style,
    		once,
    		threshold,
    		disabled,
    		className,
    		visible,
    		wasVisible,
    		intersecting,
    		removeHandlers,
    		throttleFn,
    		callEvents,
    		waypoint
    	});

    	$$self.$inject_state = $$props => {
    		if ('offset' in $$props) $$invalidate(5, offset = $$props.offset);
    		if ('throttle' in $$props) $$invalidate(6, throttle = $$props.throttle);
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('once' in $$props) $$invalidate(7, once = $$props.once);
    		if ('threshold' in $$props) $$invalidate(8, threshold = $$props.threshold);
    		if ('disabled' in $$props) $$invalidate(9, disabled = $$props.disabled);
    		if ('className' in $$props) $$invalidate(2, className = $$props.className);
    		if ('visible' in $$props) $$invalidate(3, visible = $$props.visible);
    		if ('wasVisible' in $$props) wasVisible = $$props.wasVisible;
    		if ('intersecting' in $$props) intersecting = $$props.intersecting;
    		if ('removeHandlers' in $$props) removeHandlers = $$props.removeHandlers;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		c,
    		style,
    		className,
    		visible,
    		waypoint,
    		offset,
    		throttle,
    		once,
    		threshold,
    		disabled,
    		$$scope,
    		slots
    	];
    }

    class Waypoint extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {
    			offset: 5,
    			throttle: 6,
    			c: 0,
    			style: 1,
    			once: 7,
    			threshold: 8,
    			disabled: 9,
    			class: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Waypoint",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get offset() {
    		throw new Error("<Waypoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set offset(value) {
    		throw new Error("<Waypoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get throttle() {
    		throw new Error("<Waypoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set throttle(value) {
    		throw new Error("<Waypoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get c() {
    		throw new Error("<Waypoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set c(value) {
    		throw new Error("<Waypoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Waypoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Waypoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get once() {
    		throw new Error("<Waypoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set once(value) {
    		throw new Error("<Waypoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get threshold() {
    		throw new Error("<Waypoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set threshold(value) {
    		throw new Error("<Waypoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Waypoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Waypoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Waypoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Waypoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Image/Image.svelte generated by Svelte v3.40.3 */
    const file$x = "node_modules/smelte/src/components/Image/Image.svelte";
    const get_loading_slot_changes = dirty => ({});
    const get_loading_slot_context = ctx => ({});

    // (33:20) 
    function create_if_block_2$6(ctx) {
    	let current;
    	const loading_slot_template = /*#slots*/ ctx[9].loading;
    	const loading_slot = create_slot(loading_slot_template, ctx, /*$$scope*/ ctx[10], get_loading_slot_context);

    	const block = {
    		c: function create() {
    			if (loading_slot) loading_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (loading_slot) {
    				loading_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (loading_slot) {
    				if (loading_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						loading_slot,
    						loading_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(loading_slot_template, /*$$scope*/ ctx[10], dirty, get_loading_slot_changes),
    						get_loading_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (loading_slot) loading_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(33:20) ",
    		ctx
    	});

    	return block;
    }

    // (31:22) 
    function create_if_block_1$d(ctx) {
    	let img;
    	let img_class_value;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", img_class_value = /*$$props*/ ctx[8].class);
    			if (!src_url_equal(img.src, img_src_value = /*thumbnail*/ ctx[4])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", /*alt*/ ctx[0]);
    			attr_dev(img, "width", /*width*/ ctx[1]);
    			attr_dev(img, "height", /*height*/ ctx[2]);
    			add_location(img, file$x, 31, 4, 648);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$$props*/ 256 && img_class_value !== (img_class_value = /*$$props*/ ctx[8].class)) {
    				attr_dev(img, "class", img_class_value);
    			}

    			if (dirty & /*thumbnail*/ 16 && !src_url_equal(img.src, img_src_value = /*thumbnail*/ ctx[4])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*alt*/ 1) {
    				attr_dev(img, "alt", /*alt*/ ctx[0]);
    			}

    			if (dirty & /*width*/ 2) {
    				attr_dev(img, "width", /*width*/ ctx[1]);
    			}

    			if (dirty & /*height*/ 4) {
    				attr_dev(img, "height", /*height*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(31:22) ",
    		ctx
    	});

    	return block;
    }

    // (29:2) {#if loaded}
    function create_if_block$j(ctx) {
    	let img;
    	let img_class_value;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", img_class_value = /*$$props*/ ctx[8].class);
    			if (!src_url_equal(img.src, img_src_value = /*src*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", /*alt*/ ctx[0]);
    			attr_dev(img, "width", /*width*/ ctx[1]);
    			attr_dev(img, "height", /*height*/ ctx[2]);
    			add_location(img, file$x, 29, 4, 562);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$$props*/ 256 && img_class_value !== (img_class_value = /*$$props*/ ctx[8].class)) {
    				attr_dev(img, "class", img_class_value);
    			}

    			if (dirty & /*src*/ 8 && !src_url_equal(img.src, img_src_value = /*src*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*alt*/ 1) {
    				attr_dev(img, "alt", /*alt*/ ctx[0]);
    			}

    			if (dirty & /*width*/ 2) {
    				attr_dev(img, "width", /*width*/ ctx[1]);
    			}

    			if (dirty & /*height*/ 4) {
    				attr_dev(img, "height", /*height*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(29:2) {#if loaded}",
    		ctx
    	});

    	return block;
    }

    // (28:0) <Waypoint class={$$props.class} once on:enter={load} style="height: {height}px" offset="0">
    function create_default_slot$l(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$j, create_if_block_1$d, create_if_block_2$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loaded*/ ctx[5]) return 0;
    		if (/*thumbnail*/ ctx[4]) return 1;
    		if (/*loading*/ ctx[6]) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(28:0) <Waypoint class={$$props.class} once on:enter={load} style=\\\"height: {height}px\\\" offset=\\\"0\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let waypoint;
    	let current;

    	waypoint = new Waypoint({
    			props: {
    				class: /*$$props*/ ctx[8].class,
    				once: true,
    				style: "height: " + /*height*/ ctx[2] + "px",
    				offset: "0",
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	waypoint.$on("enter", /*load*/ ctx[7]);

    	const block = {
    		c: function create() {
    			create_component(waypoint.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(waypoint, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const waypoint_changes = {};
    			if (dirty & /*$$props*/ 256) waypoint_changes.class = /*$$props*/ ctx[8].class;
    			if (dirty & /*height*/ 4) waypoint_changes.style = "height: " + /*height*/ ctx[2] + "px";

    			if (dirty & /*$$scope, $$props, src, alt, width, height, loaded, thumbnail, loading*/ 1407) {
    				waypoint_changes.$$scope = { dirty, ctx };
    			}

    			waypoint.$set(waypoint_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(waypoint.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(waypoint.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(waypoint, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Image', slots, ['loading']);
    	let { alt = "" } = $$props;
    	let { width = "" } = $$props;
    	let { height = "" } = $$props;
    	let { src = "" } = $$props;
    	let { thumbnail = "" } = $$props;
    	let loaded = false;
    	let loading = false;

    	function load() {
    		const img = new Image();
    		img.src = src;
    		$$invalidate(6, loading = true);

    		img.onload = () => {
    			$$invalidate(6, loading = false);
    			$$invalidate(5, loaded = true);
    		};
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('alt' in $$new_props) $$invalidate(0, alt = $$new_props.alt);
    		if ('width' in $$new_props) $$invalidate(1, width = $$new_props.width);
    		if ('height' in $$new_props) $$invalidate(2, height = $$new_props.height);
    		if ('src' in $$new_props) $$invalidate(3, src = $$new_props.src);
    		if ('thumbnail' in $$new_props) $$invalidate(4, thumbnail = $$new_props.thumbnail);
    		if ('$$scope' in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Waypoint,
    		fade,
    		alt,
    		width,
    		height,
    		src,
    		thumbnail,
    		loaded,
    		loading,
    		load
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ('alt' in $$props) $$invalidate(0, alt = $$new_props.alt);
    		if ('width' in $$props) $$invalidate(1, width = $$new_props.width);
    		if ('height' in $$props) $$invalidate(2, height = $$new_props.height);
    		if ('src' in $$props) $$invalidate(3, src = $$new_props.src);
    		if ('thumbnail' in $$props) $$invalidate(4, thumbnail = $$new_props.thumbnail);
    		if ('loaded' in $$props) $$invalidate(5, loaded = $$new_props.loaded);
    		if ('loading' in $$props) $$invalidate(6, loading = $$new_props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		alt,
    		width,
    		height,
    		src,
    		thumbnail,
    		loaded,
    		loading,
    		load,
    		$$props,
    		slots,
    		$$scope
    	];
    }

    class Image_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
    			alt: 0,
    			width: 1,
    			height: 2,
    			src: 3,
    			thumbnail: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Image_1",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get alt() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set alt(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get src() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set src(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get thumbnail() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set thumbnail(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/TextField/Label.svelte generated by Svelte v3.40.3 */
    const file$w = "node_modules/smelte/src/components/TextField/Label.svelte";

    function create_fragment$C(ctx) {
    	let label;
    	let label_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[16].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

    	let label_levels = [
    		{
    			class: label_class_value = "" + (/*lClasses*/ ctx[0] + " " + /*$$props*/ ctx[2].class)
    		},
    		/*props*/ ctx[1]
    	];

    	let label_data = {};

    	for (let i = 0; i < label_levels.length; i += 1) {
    		label_data = assign(label_data, label_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			label = element("label");
    			if (default_slot) default_slot.c();
    			set_attributes(label, label_data);
    			toggle_class(label, "svelte-r33x2y", true);
    			add_location(label, file$w, 72, 0, 1606);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);

    			if (default_slot) {
    				default_slot.m(label, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[15],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(label, label_data = get_spread_update(label_levels, [
    				(!current || dirty & /*lClasses, $$props*/ 5 && label_class_value !== (label_class_value = "" + (/*lClasses*/ ctx[0] + " " + /*$$props*/ ctx[2].class))) && { class: label_class_value },
    				/*props*/ ctx[1]
    			]));

    			toggle_class(label, "svelte-r33x2y", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Label', slots, ['default']);
    	let { focused = false } = $$props;
    	let { error = false } = $$props;
    	let { outlined = false } = $$props;
    	let { labelOnTop = false } = $$props;
    	let { prepend = false } = $$props;
    	let { color = "primary" } = $$props;
    	let { bgColor = "white" } = $$props;
    	let { dense = false } = $$props;
    	let labelDefault = `pt-4 absolute top-0 label-transition block pb-2 px-4 pointer-events-none cursor-text`;
    	let { add = "" } = $$props;
    	let { remove = "" } = $$props;
    	let { replace = "" } = $$props;
    	let { labelClasses = labelDefault } = $$props;
    	const { border, txt } = utils(color);
    	const l = new ClassBuilder(labelClasses, labelDefault);
    	let lClasses = i => i;
    	const props = filterProps(['focused', 'error', 'outlined', 'labelOnTop', 'prepend', 'color', 'dense'], $$props);

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('focused' in $$new_props) $$invalidate(3, focused = $$new_props.focused);
    		if ('error' in $$new_props) $$invalidate(4, error = $$new_props.error);
    		if ('outlined' in $$new_props) $$invalidate(5, outlined = $$new_props.outlined);
    		if ('labelOnTop' in $$new_props) $$invalidate(6, labelOnTop = $$new_props.labelOnTop);
    		if ('prepend' in $$new_props) $$invalidate(7, prepend = $$new_props.prepend);
    		if ('color' in $$new_props) $$invalidate(8, color = $$new_props.color);
    		if ('bgColor' in $$new_props) $$invalidate(9, bgColor = $$new_props.bgColor);
    		if ('dense' in $$new_props) $$invalidate(10, dense = $$new_props.dense);
    		if ('add' in $$new_props) $$invalidate(11, add = $$new_props.add);
    		if ('remove' in $$new_props) $$invalidate(12, remove = $$new_props.remove);
    		if ('replace' in $$new_props) $$invalidate(13, replace = $$new_props.replace);
    		if ('labelClasses' in $$new_props) $$invalidate(14, labelClasses = $$new_props.labelClasses);
    		if ('$$scope' in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		utils,
    		ClassBuilder,
    		filterProps,
    		focused,
    		error,
    		outlined,
    		labelOnTop,
    		prepend,
    		color,
    		bgColor,
    		dense,
    		labelDefault,
    		add,
    		remove,
    		replace,
    		labelClasses,
    		border,
    		txt,
    		l,
    		lClasses,
    		props
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ('focused' in $$props) $$invalidate(3, focused = $$new_props.focused);
    		if ('error' in $$props) $$invalidate(4, error = $$new_props.error);
    		if ('outlined' in $$props) $$invalidate(5, outlined = $$new_props.outlined);
    		if ('labelOnTop' in $$props) $$invalidate(6, labelOnTop = $$new_props.labelOnTop);
    		if ('prepend' in $$props) $$invalidate(7, prepend = $$new_props.prepend);
    		if ('color' in $$props) $$invalidate(8, color = $$new_props.color);
    		if ('bgColor' in $$props) $$invalidate(9, bgColor = $$new_props.bgColor);
    		if ('dense' in $$props) $$invalidate(10, dense = $$new_props.dense);
    		if ('labelDefault' in $$props) labelDefault = $$new_props.labelDefault;
    		if ('add' in $$props) $$invalidate(11, add = $$new_props.add);
    		if ('remove' in $$props) $$invalidate(12, remove = $$new_props.remove);
    		if ('replace' in $$props) $$invalidate(13, replace = $$new_props.replace);
    		if ('labelClasses' in $$props) $$invalidate(14, labelClasses = $$new_props.labelClasses);
    		if ('lClasses' in $$props) $$invalidate(0, lClasses = $$new_props.lClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*focused, error, labelOnTop, outlined, bgColor, prepend, dense, add, remove, replace*/ 16120) {
    			$$invalidate(0, lClasses = l.flush().add(txt(), focused && !error).add('text-error-500', focused && error).add('label-top text-xs', labelOnTop).add('text-xs', focused).remove('pt-4 pb-2 px-4 px-1 pt-0', labelOnTop && outlined).add(`ml-3 p-1 pt-0 mt-0 bg-${bgColor} dark:bg-dark-500`, labelOnTop && outlined).remove('px-4', prepend).add('pr-4 pl-10', prepend).remove('pt-4', dense).add('pt-3', dense).add(add).remove(remove).replace(replace).get());
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		lClasses,
    		props,
    		$$props,
    		focused,
    		error,
    		outlined,
    		labelOnTop,
    		prepend,
    		color,
    		bgColor,
    		dense,
    		add,
    		remove,
    		replace,
    		labelClasses,
    		$$scope,
    		slots
    	];
    }

    class Label$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
    			focused: 3,
    			error: 4,
    			outlined: 5,
    			labelOnTop: 6,
    			prepend: 7,
    			color: 8,
    			bgColor: 9,
    			dense: 10,
    			add: 11,
    			remove: 12,
    			replace: 13,
    			labelClasses: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Label",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get focused() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focused(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get error() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlined() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlined(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelOnTop() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelOnTop(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prepend() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prepend(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bgColor() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bgColor(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dense() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dense(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get add() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set add(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get remove() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set remove(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelClasses() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelClasses(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/TextField/Hint.svelte generated by Svelte v3.40.3 */
    const file$v = "node_modules/smelte/src/components/TextField/Hint.svelte";

    function create_fragment$B(ctx) {
    	let div;
    	let html_tag;
    	let raw_value = (/*hint*/ ctx[1] || '') + "";
    	let t0;
    	let t1_value = (/*error*/ ctx[0] || '') + "";
    	let t1;
    	let div_transition;
    	let current;

    	const block = {
    		c: function create() {
    			div = element("div");
    			html_tag = new HtmlTag();
    			t0 = space();
    			t1 = text(t1_value);
    			html_tag.a = t0;
    			attr_dev(div, "class", /*classes*/ ctx[3]);
    			add_location(div, file$v, 35, 0, 787);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			html_tag.m(raw_value, div);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*hint*/ 2) && raw_value !== (raw_value = (/*hint*/ ctx[1] || '') + "")) html_tag.p(raw_value);
    			if ((!current || dirty & /*error*/ 1) && t1_value !== (t1_value = (/*error*/ ctx[0] || '') + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*classes*/ 8) {
    				attr_dev(div, "class", /*classes*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fly, /*transitionProps*/ ctx[2], true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, fly, /*transitionProps*/ ctx[2], false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Hint', slots, []);
    	let classesDefault = "text-xs py-1 pl-4 absolute left-0";
    	let { error = false } = $$props;
    	let { hint = "" } = $$props;
    	let { add = "" } = $$props;
    	let { remove = "" } = $$props;
    	let { replace = "" } = $$props;
    	let { transitionProps = { y: -10, duration: 100, easing: quadOut } } = $$props;
    	const l = new ClassBuilder($$props.class, classesDefault);
    	let Classes = i => i;
    	const props = filterProps(['error', 'hint'], $$props);

    	$$self.$$set = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('error' in $$new_props) $$invalidate(0, error = $$new_props.error);
    		if ('hint' in $$new_props) $$invalidate(1, hint = $$new_props.hint);
    		if ('add' in $$new_props) $$invalidate(4, add = $$new_props.add);
    		if ('remove' in $$new_props) $$invalidate(5, remove = $$new_props.remove);
    		if ('replace' in $$new_props) $$invalidate(6, replace = $$new_props.replace);
    		if ('transitionProps' in $$new_props) $$invalidate(2, transitionProps = $$new_props.transitionProps);
    	};

    	$$self.$capture_state = () => ({
    		utils,
    		ClassBuilder,
    		filterProps,
    		fly,
    		quadOut,
    		classesDefault,
    		error,
    		hint,
    		add,
    		remove,
    		replace,
    		transitionProps,
    		l,
    		Classes,
    		props,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    		if ('classesDefault' in $$props) classesDefault = $$new_props.classesDefault;
    		if ('error' in $$props) $$invalidate(0, error = $$new_props.error);
    		if ('hint' in $$props) $$invalidate(1, hint = $$new_props.hint);
    		if ('add' in $$props) $$invalidate(4, add = $$new_props.add);
    		if ('remove' in $$props) $$invalidate(5, remove = $$new_props.remove);
    		if ('replace' in $$props) $$invalidate(6, replace = $$new_props.replace);
    		if ('transitionProps' in $$props) $$invalidate(2, transitionProps = $$new_props.transitionProps);
    		if ('Classes' in $$props) Classes = $$new_props.Classes;
    		if ('classes' in $$props) $$invalidate(3, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*error, hint, add, remove, replace*/ 115) {
    			$$invalidate(3, classes = l.flush().add('text-error-500', error).add('text-gray-600', hint).add(add).remove(remove).replace(replace).get());
    		}
    	};

    	$$props = exclude_internal_props($$props);
    	return [error, hint, transitionProps, classes, add, remove, replace];
    }

    class Hint extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
    			error: 0,
    			hint: 1,
    			add: 4,
    			remove: 5,
    			replace: 6,
    			transitionProps: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Hint",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get error() {
    		throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hint() {
    		throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hint(value) {
    		throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get add() {
    		throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set add(value) {
    		throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get remove() {
    		throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set remove(value) {
    		throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionProps() {
    		throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionProps(value) {
    		throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/TextField/Underline.svelte generated by Svelte v3.40.3 */
    const file$u = "node_modules/smelte/src/components/TextField/Underline.svelte";

    function create_fragment$A(ctx) {
    	let div1;
    	let div0;
    	let div0_class_value;
    	let div1_class_value;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", div0_class_value = "" + (null_to_empty(/*classes*/ ctx[2]) + " svelte-xd9zs6"));
    			set_style(div0, "height", "2px");
    			set_style(div0, "transition", "width .2s ease");
    			add_location(div0, file$u, 61, 2, 1133);
    			attr_dev(div1, "class", div1_class_value = "line absolute bottom-0 left-0 w-full bg-gray-600 " + /*$$props*/ ctx[3].class + " svelte-xd9zs6");
    			toggle_class(div1, "hidden", /*noUnderline*/ ctx[0] || /*outlined*/ ctx[1]);
    			add_location(div1, file$u, 58, 0, 1009);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*classes*/ 4 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*classes*/ ctx[2]) + " svelte-xd9zs6"))) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (dirty & /*$$props*/ 8 && div1_class_value !== (div1_class_value = "line absolute bottom-0 left-0 w-full bg-gray-600 " + /*$$props*/ ctx[3].class + " svelte-xd9zs6")) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (dirty & /*$$props, noUnderline, outlined*/ 11) {
    				toggle_class(div1, "hidden", /*noUnderline*/ ctx[0] || /*outlined*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Underline', slots, []);
    	let { noUnderline = false } = $$props;
    	let { outlined = false } = $$props;
    	let { focused = false } = $$props;
    	let { error = false } = $$props;
    	let { color = "primary" } = $$props;
    	let defaultClasses = `mx-auto w-0`;
    	let { add = "" } = $$props;
    	let { remove = "" } = $$props;
    	let { replace = "" } = $$props;
    	let { lineClasses = defaultClasses } = $$props;
    	const { bg, border, txt, caret } = utils(color);
    	const l = new ClassBuilder(lineClasses, defaultClasses);
    	let Classes = i => i;
    	const props = filterProps(['focused', 'error', 'outlined', 'labelOnTop', 'prepend', 'bgcolor', 'color'], $$props);

    	$$self.$$set = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('noUnderline' in $$new_props) $$invalidate(0, noUnderline = $$new_props.noUnderline);
    		if ('outlined' in $$new_props) $$invalidate(1, outlined = $$new_props.outlined);
    		if ('focused' in $$new_props) $$invalidate(4, focused = $$new_props.focused);
    		if ('error' in $$new_props) $$invalidate(5, error = $$new_props.error);
    		if ('color' in $$new_props) $$invalidate(6, color = $$new_props.color);
    		if ('add' in $$new_props) $$invalidate(7, add = $$new_props.add);
    		if ('remove' in $$new_props) $$invalidate(8, remove = $$new_props.remove);
    		if ('replace' in $$new_props) $$invalidate(9, replace = $$new_props.replace);
    		if ('lineClasses' in $$new_props) $$invalidate(10, lineClasses = $$new_props.lineClasses);
    	};

    	$$self.$capture_state = () => ({
    		utils,
    		ClassBuilder,
    		filterProps,
    		noUnderline,
    		outlined,
    		focused,
    		error,
    		color,
    		defaultClasses,
    		add,
    		remove,
    		replace,
    		lineClasses,
    		bg,
    		border,
    		txt,
    		caret,
    		l,
    		Classes,
    		props,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    		if ('noUnderline' in $$props) $$invalidate(0, noUnderline = $$new_props.noUnderline);
    		if ('outlined' in $$props) $$invalidate(1, outlined = $$new_props.outlined);
    		if ('focused' in $$props) $$invalidate(4, focused = $$new_props.focused);
    		if ('error' in $$props) $$invalidate(5, error = $$new_props.error);
    		if ('color' in $$props) $$invalidate(6, color = $$new_props.color);
    		if ('defaultClasses' in $$props) defaultClasses = $$new_props.defaultClasses;
    		if ('add' in $$props) $$invalidate(7, add = $$new_props.add);
    		if ('remove' in $$props) $$invalidate(8, remove = $$new_props.remove);
    		if ('replace' in $$props) $$invalidate(9, replace = $$new_props.replace);
    		if ('lineClasses' in $$props) $$invalidate(10, lineClasses = $$new_props.lineClasses);
    		if ('Classes' in $$props) Classes = $$new_props.Classes;
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*focused, error, add, remove, replace*/ 944) {
    			$$invalidate(2, classes = l.flush().add(txt(), focused && !error).add('bg-error-500', error).add('w-full', focused || error).add(bg(), focused).add(add).remove(remove).replace(replace).get());
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		noUnderline,
    		outlined,
    		classes,
    		$$props,
    		focused,
    		error,
    		color,
    		add,
    		remove,
    		replace,
    		lineClasses
    	];
    }

    class Underline extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
    			noUnderline: 0,
    			outlined: 1,
    			focused: 4,
    			error: 5,
    			color: 6,
    			add: 7,
    			remove: 8,
    			replace: 9,
    			lineClasses: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Underline",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get noUnderline() {
    		throw new Error("<Underline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noUnderline(value) {
    		throw new Error("<Underline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlined() {
    		throw new Error("<Underline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlined(value) {
    		throw new Error("<Underline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focused() {
    		throw new Error("<Underline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focused(value) {
    		throw new Error("<Underline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get error() {
    		throw new Error("<Underline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<Underline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Underline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Underline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get add() {
    		throw new Error("<Underline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set add(value) {
    		throw new Error("<Underline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get remove() {
    		throw new Error("<Underline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set remove(value) {
    		throw new Error("<Underline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Underline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Underline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lineClasses() {
    		throw new Error("<Underline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lineClasses(value) {
    		throw new Error("<Underline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/TextField/TextField.svelte generated by Svelte v3.40.3 */
    const file$t = "node_modules/smelte/src/components/TextField/TextField.svelte";
    const get_prepend_slot_changes = dirty => ({});
    const get_prepend_slot_context = ctx => ({});
    const get_append_slot_changes = dirty => ({});
    const get_append_slot_context = ctx => ({});
    const get_label_slot_changes$1 = dirty => ({});
    const get_label_slot_context$1 = ctx => ({});

    // (139:2) {#if label}
    function create_if_block_6$3(ctx) {
    	let current;
    	const label_slot_template = /*#slots*/ ctx[40].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[69], get_label_slot_context$1);
    	const label_slot_or_fallback = label_slot || fallback_block_2(ctx);

    	const block = {
    		c: function create() {
    			if (label_slot_or_fallback) label_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (label_slot_or_fallback) {
    				label_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[2] & /*$$scope*/ 128)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[69],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[69])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[69], dirty, get_label_slot_changes$1),
    						get_label_slot_context$1
    					);
    				}
    			} else {
    				if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & /*labelOnTop, focused, error, outlined, prepend, color, bgColor, dense, label*/ 33952078)) {
    					label_slot_or_fallback.p(ctx, !current ? [-1, -1, -1] : dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (label_slot_or_fallback) label_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(139:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    // (141:4) <Label       {labelOnTop}       {focused}       {error}       {outlined}       {prepend}       {color}       {bgColor}       dense={dense && !outlined}     >
    function create_default_slot_2$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*label*/ 8) set_data_dev(t, /*label*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$f.name,
    		type: "slot",
    		source: "(141:4) <Label       {labelOnTop}       {focused}       {error}       {outlined}       {prepend}       {color}       {bgColor}       dense={dense && !outlined}     >",
    		ctx
    	});

    	return block;
    }

    // (140:21)      
    function fallback_block_2(ctx) {
    	let label_1;
    	let current;

    	label_1 = new Label$1({
    			props: {
    				labelOnTop: /*labelOnTop*/ ctx[25],
    				focused: /*focused*/ ctx[1],
    				error: /*error*/ ctx[6],
    				outlined: /*outlined*/ ctx[2],
    				prepend: /*prepend*/ ctx[8],
    				color: /*color*/ ctx[17],
    				bgColor: /*bgColor*/ ctx[18],
    				dense: /*dense*/ ctx[12] && !/*outlined*/ ctx[2],
    				$$slots: { default: [create_default_slot_2$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_1_changes = {};
    			if (dirty[0] & /*labelOnTop*/ 33554432) label_1_changes.labelOnTop = /*labelOnTop*/ ctx[25];
    			if (dirty[0] & /*focused*/ 2) label_1_changes.focused = /*focused*/ ctx[1];
    			if (dirty[0] & /*error*/ 64) label_1_changes.error = /*error*/ ctx[6];
    			if (dirty[0] & /*outlined*/ 4) label_1_changes.outlined = /*outlined*/ ctx[2];
    			if (dirty[0] & /*prepend*/ 256) label_1_changes.prepend = /*prepend*/ ctx[8];
    			if (dirty[0] & /*color*/ 131072) label_1_changes.color = /*color*/ ctx[17];
    			if (dirty[0] & /*bgColor*/ 262144) label_1_changes.bgColor = /*bgColor*/ ctx[18];
    			if (dirty[0] & /*dense, outlined*/ 4100) label_1_changes.dense = /*dense*/ ctx[12] && !/*outlined*/ ctx[2];

    			if (dirty[0] & /*label*/ 8 | dirty[2] & /*$$scope*/ 128) {
    				label_1_changes.$$scope = { dirty, ctx };
    			}

    			label_1.$set(label_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2.name,
    		type: "fallback",
    		source: "(140:21)      ",
    		ctx
    	});

    	return block;
    }

    // (191:36) 
    function create_if_block_5$3(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			input.readOnly = true;
    			attr_dev(input, "class", /*iClasses*/ ctx[24]);
    			input.disabled = /*disabled*/ ctx[20];
    			input.value = /*value*/ ctx[0];
    			add_location(input, file$t, 191, 4, 4933);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*change_handler_2*/ ctx[57], false, false, false),
    					listen_dev(input, "input", /*input_handler_2*/ ctx[58], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_2*/ ctx[59], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_2*/ ctx[60], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_2*/ ctx[61], false, false, false),
    					listen_dev(input, "click", /*click_handler_2*/ ctx[62], false, false, false),
    					listen_dev(input, "blur", /*blur_handler_2*/ ctx[63], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_2*/ ctx[64], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*iClasses*/ 16777216) {
    				attr_dev(input, "class", /*iClasses*/ ctx[24]);
    			}

    			if (dirty[0] & /*disabled*/ 1048576) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[20]);
    			}

    			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				prop_dev(input, "value", /*value*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(191:36) ",
    		ctx
    	});

    	return block;
    }

    // (172:32) 
    function create_if_block_4$4(ctx) {
    	let textarea_1;
    	let textarea_1_placeholder_value;
    	let mounted;
    	let dispose;

    	let textarea_1_levels = [
    		{ rows: /*rows*/ ctx[10] },
    		{ "aria-label": /*label*/ ctx[3] },
    		{ class: /*iClasses*/ ctx[24] },
    		{ disabled: /*disabled*/ ctx[20] },
    		/*props*/ ctx[29],
    		{
    			placeholder: textarea_1_placeholder_value = !/*value*/ ctx[0] ? /*placeholder*/ ctx[4] : ""
    		}
    	];

    	let textarea_1_data = {};

    	for (let i = 0; i < textarea_1_levels.length; i += 1) {
    		textarea_1_data = assign(textarea_1_data, textarea_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			textarea_1 = element("textarea");
    			set_attributes(textarea_1, textarea_1_data);
    			add_location(textarea_1, file$t, 172, 4, 4535);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea_1, anchor);
    			if (textarea_1.autofocus) textarea_1.focus();
    			set_input_value(textarea_1, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea_1, "change", /*change_handler_1*/ ctx[49], false, false, false),
    					listen_dev(textarea_1, "input", /*input_handler_1*/ ctx[50], false, false, false),
    					listen_dev(textarea_1, "keydown", /*keydown_handler_1*/ ctx[51], false, false, false),
    					listen_dev(textarea_1, "keypress", /*keypress_handler_1*/ ctx[52], false, false, false),
    					listen_dev(textarea_1, "keyup", /*keyup_handler_1*/ ctx[53], false, false, false),
    					listen_dev(textarea_1, "click", /*click_handler_1*/ ctx[54], false, false, false),
    					listen_dev(textarea_1, "focus", /*focus_handler_1*/ ctx[55], false, false, false),
    					listen_dev(textarea_1, "blur", /*blur_handler_1*/ ctx[56], false, false, false),
    					listen_dev(textarea_1, "input", /*textarea_1_input_handler*/ ctx[66]),
    					listen_dev(textarea_1, "focus", /*toggleFocused*/ ctx[28], false, false, false),
    					listen_dev(textarea_1, "blur", /*toggleFocused*/ ctx[28], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(textarea_1, textarea_1_data = get_spread_update(textarea_1_levels, [
    				dirty[0] & /*rows*/ 1024 && { rows: /*rows*/ ctx[10] },
    				dirty[0] & /*label*/ 8 && { "aria-label": /*label*/ ctx[3] },
    				dirty[0] & /*iClasses*/ 16777216 && { class: /*iClasses*/ ctx[24] },
    				dirty[0] & /*disabled*/ 1048576 && { disabled: /*disabled*/ ctx[20] },
    				/*props*/ ctx[29],
    				dirty[0] & /*value, placeholder*/ 17 && textarea_1_placeholder_value !== (textarea_1_placeholder_value = !/*value*/ ctx[0] ? /*placeholder*/ ctx[4] : "") && {
    					placeholder: textarea_1_placeholder_value
    				}
    			]));

    			if (dirty[0] & /*value*/ 1) {
    				set_input_value(textarea_1, /*value*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea_1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(172:32) ",
    		ctx
    	});

    	return block;
    }

    // (154:2) {#if (!textarea && !select) || autocomplete}
    function create_if_block_3$4(ctx) {
    	let input;
    	let input_placeholder_value;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		{ "aria-label": /*label*/ ctx[3] },
    		{ class: /*iClasses*/ ctx[24] },
    		{ disabled: /*disabled*/ ctx[20] },
    		/*props*/ ctx[29],
    		{
    			placeholder: input_placeholder_value = !/*value*/ ctx[0] ? /*placeholder*/ ctx[4] : ""
    		}
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$t, 154, 4, 4157);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "focus", /*toggleFocused*/ ctx[28], false, false, false),
    					listen_dev(input, "blur", /*toggleFocused*/ ctx[28], false, false, false),
    					listen_dev(input, "blur", /*blur_handler*/ ctx[41], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[65]),
    					listen_dev(input, "change", /*change_handler*/ ctx[42], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[43], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler*/ ctx[44], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler*/ ctx[45], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler*/ ctx[46], false, false, false),
    					listen_dev(input, "click", /*click_handler*/ ctx[47], false, false, false),
    					listen_dev(input, "focus", /*focus_handler*/ ctx[48], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*label*/ 8 && { "aria-label": /*label*/ ctx[3] },
    				dirty[0] & /*iClasses*/ 16777216 && { class: /*iClasses*/ ctx[24] },
    				dirty[0] & /*disabled*/ 1048576 && { disabled: /*disabled*/ ctx[20] },
    				/*props*/ ctx[29],
    				dirty[0] & /*value, placeholder*/ 17 && input_placeholder_value !== (input_placeholder_value = !/*value*/ ctx[0] ? /*placeholder*/ ctx[4] : "") && { placeholder: input_placeholder_value }
    			]));

    			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(154:2) {#if (!textarea && !select) || autocomplete}",
    		ctx
    	});

    	return block;
    }

    // (207:2) {#if append}
    function create_if_block_2$5(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const append_slot_template = /*#slots*/ ctx[40].append;
    	const append_slot = create_slot(append_slot_template, ctx, /*$$scope*/ ctx[69], get_append_slot_context);
    	const append_slot_or_fallback = append_slot || fallback_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (append_slot_or_fallback) append_slot_or_fallback.c();
    			attr_dev(div, "class", /*aClasses*/ ctx[22]);
    			add_location(div, file$t, 207, 4, 5167);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (append_slot_or_fallback) {
    				append_slot_or_fallback.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler_3*/ ctx[67], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (append_slot) {
    				if (append_slot.p && (!current || dirty[2] & /*$$scope*/ 128)) {
    					update_slot_base(
    						append_slot,
    						append_slot_template,
    						ctx,
    						/*$$scope*/ ctx[69],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[69])
    						: get_slot_changes(append_slot_template, /*$$scope*/ ctx[69], dirty, get_append_slot_changes),
    						get_append_slot_context
    					);
    				}
    			} else {
    				if (append_slot_or_fallback && append_slot_or_fallback.p && (!current || dirty[0] & /*appendReverse, focused, iconClass, append*/ 557186)) {
    					append_slot_or_fallback.p(ctx, !current ? [-1, -1, -1] : dirty);
    				}
    			}

    			if (!current || dirty[0] & /*aClasses*/ 4194304) {
    				attr_dev(div, "class", /*aClasses*/ ctx[22]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(append_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(append_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (append_slot_or_fallback) append_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(207:2) {#if append}",
    		ctx
    	});

    	return block;
    }

    // (213:8) <Icon           reverse={appendReverse}           class="{focused ? txt() : ""} {iconClass}"         >
    function create_default_slot_1$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*append*/ ctx[7]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*append*/ 128) set_data_dev(t, /*append*/ ctx[7]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(213:8) <Icon           reverse={appendReverse}           class=\\\"{focused ? txt() : \\\"\\\"} {iconClass}\\\"         >",
    		ctx
    	});

    	return block;
    }

    // (212:26)          
    function fallback_block_1$1(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				reverse: /*appendReverse*/ ctx[15],
    				class: "" + ((/*focused*/ ctx[1] ? /*txt*/ ctx[27]() : "") + " " + /*iconClass*/ ctx[19]),
    				$$slots: { default: [create_default_slot_1$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty[0] & /*appendReverse*/ 32768) icon_changes.reverse = /*appendReverse*/ ctx[15];
    			if (dirty[0] & /*focused, iconClass*/ 524290) icon_changes.class = "" + ((/*focused*/ ctx[1] ? /*txt*/ ctx[27]() : "") + " " + /*iconClass*/ ctx[19]);

    			if (dirty[0] & /*append*/ 128 | dirty[2] & /*$$scope*/ 128) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1$1.name,
    		type: "fallback",
    		source: "(212:26)          ",
    		ctx
    	});

    	return block;
    }

    // (223:2) {#if prepend}
    function create_if_block_1$c(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const prepend_slot_template = /*#slots*/ ctx[40].prepend;
    	const prepend_slot = create_slot(prepend_slot_template, ctx, /*$$scope*/ ctx[69], get_prepend_slot_context);
    	const prepend_slot_or_fallback = prepend_slot || fallback_block$5(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (prepend_slot_or_fallback) prepend_slot_or_fallback.c();
    			attr_dev(div, "class", /*pClasses*/ ctx[23]);
    			add_location(div, file$t, 223, 4, 5476);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (prepend_slot_or_fallback) {
    				prepend_slot_or_fallback.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler_4*/ ctx[68], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (prepend_slot) {
    				if (prepend_slot.p && (!current || dirty[2] & /*$$scope*/ 128)) {
    					update_slot_base(
    						prepend_slot,
    						prepend_slot_template,
    						ctx,
    						/*$$scope*/ ctx[69],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[69])
    						: get_slot_changes(prepend_slot_template, /*$$scope*/ ctx[69], dirty, get_prepend_slot_changes),
    						get_prepend_slot_context
    					);
    				}
    			} else {
    				if (prepend_slot_or_fallback && prepend_slot_or_fallback.p && (!current || dirty[0] & /*prependReverse, focused, iconClass, prepend*/ 590082)) {
    					prepend_slot_or_fallback.p(ctx, !current ? [-1, -1, -1] : dirty);
    				}
    			}

    			if (!current || dirty[0] & /*pClasses*/ 8388608) {
    				attr_dev(div, "class", /*pClasses*/ ctx[23]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prepend_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prepend_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (prepend_slot_or_fallback) prepend_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(223:2) {#if prepend}",
    		ctx
    	});

    	return block;
    }

    // (229:8) <Icon           reverse={prependReverse}           class="{focused ? txt() : ""} {iconClass}"         >
    function create_default_slot$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*prepend*/ ctx[8]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*prepend*/ 256) set_data_dev(t, /*prepend*/ ctx[8]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(229:8) <Icon           reverse={prependReverse}           class=\\\"{focused ? txt() : \\\"\\\"} {iconClass}\\\"         >",
    		ctx
    	});

    	return block;
    }

    // (228:27)          
    function fallback_block$5(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				reverse: /*prependReverse*/ ctx[16],
    				class: "" + ((/*focused*/ ctx[1] ? /*txt*/ ctx[27]() : "") + " " + /*iconClass*/ ctx[19]),
    				$$slots: { default: [create_default_slot$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty[0] & /*prependReverse*/ 65536) icon_changes.reverse = /*prependReverse*/ ctx[16];
    			if (dirty[0] & /*focused, iconClass*/ 524290) icon_changes.class = "" + ((/*focused*/ ctx[1] ? /*txt*/ ctx[27]() : "") + " " + /*iconClass*/ ctx[19]);

    			if (dirty[0] & /*prepend*/ 256 | dirty[2] & /*$$scope*/ 128) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$5.name,
    		type: "fallback",
    		source: "(228:27)          ",
    		ctx
    	});

    	return block;
    }

    // (246:2) {#if showHint}
    function create_if_block$i(ctx) {
    	let hint_1;
    	let current;

    	hint_1 = new Hint({
    			props: {
    				error: /*error*/ ctx[6],
    				hint: /*hint*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hint_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hint_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hint_1_changes = {};
    			if (dirty[0] & /*error*/ 64) hint_1_changes.error = /*error*/ ctx[6];
    			if (dirty[0] & /*hint*/ 32) hint_1_changes.hint = /*hint*/ ctx[5];
    			hint_1.$set(hint_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hint_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hint_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hint_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(246:2) {#if showHint}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let underline;
    	let t4;
    	let current;
    	let if_block0 = /*label*/ ctx[3] && create_if_block_6$3(ctx);

    	function select_block_type(ctx, dirty) {
    		if (!/*textarea*/ ctx[9] && !/*select*/ ctx[11] || /*autocomplete*/ ctx[13]) return create_if_block_3$4;
    		if (/*textarea*/ ctx[9] && !/*select*/ ctx[11]) return create_if_block_4$4;
    		if (/*select*/ ctx[11] && !/*autocomplete*/ ctx[13]) return create_if_block_5$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type && current_block_type(ctx);
    	let if_block2 = /*append*/ ctx[7] && create_if_block_2$5(ctx);
    	let if_block3 = /*prepend*/ ctx[8] && create_if_block_1$c(ctx);

    	underline = new Underline({
    			props: {
    				noUnderline: /*noUnderline*/ ctx[14],
    				outlined: /*outlined*/ ctx[2],
    				focused: /*focused*/ ctx[1],
    				error: /*error*/ ctx[6],
    				color: /*color*/ ctx[17]
    			},
    			$$inline: true
    		});

    	let if_block4 = /*showHint*/ ctx[26] && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			create_component(underline.$$.fragment);
    			t4 = space();
    			if (if_block4) if_block4.c();
    			attr_dev(div, "class", /*wClasses*/ ctx[21]);
    			add_location(div, file$t, 137, 0, 3851);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			mount_component(underline, div, null);
    			append_dev(div, t4);
    			if (if_block4) if_block4.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*label*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*label*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_6$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if (if_block1) if_block1.d(1);
    				if_block1 = current_block_type && current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			}

    			if (/*append*/ ctx[7]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*append*/ 128) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$5(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*prepend*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*prepend*/ 256) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1$c(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			const underline_changes = {};
    			if (dirty[0] & /*noUnderline*/ 16384) underline_changes.noUnderline = /*noUnderline*/ ctx[14];
    			if (dirty[0] & /*outlined*/ 4) underline_changes.outlined = /*outlined*/ ctx[2];
    			if (dirty[0] & /*focused*/ 2) underline_changes.focused = /*focused*/ ctx[1];
    			if (dirty[0] & /*error*/ 64) underline_changes.error = /*error*/ ctx[6];
    			if (dirty[0] & /*color*/ 131072) underline_changes.color = /*color*/ ctx[17];
    			underline.$set(underline_changes);

    			if (/*showHint*/ ctx[26]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*showHint*/ 67108864) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block$i(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, null);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*wClasses*/ 2097152) {
    				attr_dev(div, "class", /*wClasses*/ ctx[21]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(underline.$$.fragment, local);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(underline.$$.fragment, local);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();

    			if (if_block1) {
    				if_block1.d();
    			}

    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			destroy_component(underline);
    			if (if_block4) if_block4.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const inputDefault = "pb-2 pt-6 px-4 rounded-t text-black dark:text-gray-100 w-full";
    const classesDefault$5 = "mt-2 mb-6 relative text-gray-600 dark:text-gray-100";
    const appendDefault = "absolute right-0 top-0 pb-2 pr-4 pt-4 text-gray-700 z-10";
    const prependDefault = "absolute left-0 top-0 pb-2 pl-2 pt-4 text-xs text-gray-700 z-10";

    function instance$z($$self, $$props, $$invalidate) {
    	let showHint;
    	let labelOnTop;
    	let iClasses;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextField', slots, ['label','append','prepend']);
    	let { outlined = false } = $$props;
    	let { value = null } = $$props;
    	let { label = "" } = $$props;
    	let { placeholder = "" } = $$props;
    	let { hint = "" } = $$props;
    	let { error = false } = $$props;
    	let { append = "" } = $$props;
    	let { prepend = "" } = $$props;
    	let { persistentHint = false } = $$props;
    	let { textarea = false } = $$props;
    	let { rows = 5 } = $$props;
    	let { select = false } = $$props;
    	let { dense = false } = $$props;
    	let { autocomplete = false } = $$props;
    	let { noUnderline = false } = $$props;
    	let { appendReverse = false } = $$props;
    	let { prependReverse = false } = $$props;
    	let { color = "primary" } = $$props;
    	let { bgColor = "white" } = $$props;
    	let { iconClass = "" } = $$props;
    	let { disabled = false } = $$props;
    	let { add = "" } = $$props;
    	let { remove = "" } = $$props;
    	let { replace = "" } = $$props;
    	let { inputClasses = inputDefault } = $$props;
    	let { classes = classesDefault$5 } = $$props;
    	let { appendClasses = appendDefault } = $$props;
    	let { prependClasses = prependDefault } = $$props;
    	const { bg, border, txt, caret } = utils(color);
    	const cb = new ClassBuilder(inputClasses, inputDefault);
    	const ccb = new ClassBuilder(classes, classesDefault$5);
    	const acb = new ClassBuilder(appendClasses, appendDefault);
    	const pcb = new ClassBuilder(prependClasses, prependDefault);

    	let { extend = () => {
    		
    	} } = $$props;

    	let { focused = false } = $$props;
    	let wClasses = i => i;
    	let aClasses = i => i;
    	let pClasses = i => i;

    	function toggleFocused() {
    		$$invalidate(1, focused = !focused);
    	}

    	const props = filterProps(
    		[
    			'outlined',
    			'label',
    			'placeholder',
    			'hint',
    			'error',
    			'append',
    			'prepend',
    			'persistentHint',
    			'textarea',
    			'rows',
    			'select',
    			'autocomplete',
    			'noUnderline',
    			'appendReverse',
    			'prependReverse',
    			'color',
    			'bgColor',
    			'disabled',
    			'replace',
    			'remove',
    			'small'
    		],
    		$$props
    	);

    	const dispatch = createEventDispatcher();

    	function blur_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	function textarea_1_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	const click_handler_3 = () => dispatch("click-append");
    	const click_handler_4 = () => dispatch("click-prepend");

    	$$self.$$set = $$new_props => {
    		$$invalidate(77, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('outlined' in $$new_props) $$invalidate(2, outlined = $$new_props.outlined);
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('label' in $$new_props) $$invalidate(3, label = $$new_props.label);
    		if ('placeholder' in $$new_props) $$invalidate(4, placeholder = $$new_props.placeholder);
    		if ('hint' in $$new_props) $$invalidate(5, hint = $$new_props.hint);
    		if ('error' in $$new_props) $$invalidate(6, error = $$new_props.error);
    		if ('append' in $$new_props) $$invalidate(7, append = $$new_props.append);
    		if ('prepend' in $$new_props) $$invalidate(8, prepend = $$new_props.prepend);
    		if ('persistentHint' in $$new_props) $$invalidate(31, persistentHint = $$new_props.persistentHint);
    		if ('textarea' in $$new_props) $$invalidate(9, textarea = $$new_props.textarea);
    		if ('rows' in $$new_props) $$invalidate(10, rows = $$new_props.rows);
    		if ('select' in $$new_props) $$invalidate(11, select = $$new_props.select);
    		if ('dense' in $$new_props) $$invalidate(12, dense = $$new_props.dense);
    		if ('autocomplete' in $$new_props) $$invalidate(13, autocomplete = $$new_props.autocomplete);
    		if ('noUnderline' in $$new_props) $$invalidate(14, noUnderline = $$new_props.noUnderline);
    		if ('appendReverse' in $$new_props) $$invalidate(15, appendReverse = $$new_props.appendReverse);
    		if ('prependReverse' in $$new_props) $$invalidate(16, prependReverse = $$new_props.prependReverse);
    		if ('color' in $$new_props) $$invalidate(17, color = $$new_props.color);
    		if ('bgColor' in $$new_props) $$invalidate(18, bgColor = $$new_props.bgColor);
    		if ('iconClass' in $$new_props) $$invalidate(19, iconClass = $$new_props.iconClass);
    		if ('disabled' in $$new_props) $$invalidate(20, disabled = $$new_props.disabled);
    		if ('add' in $$new_props) $$invalidate(32, add = $$new_props.add);
    		if ('remove' in $$new_props) $$invalidate(33, remove = $$new_props.remove);
    		if ('replace' in $$new_props) $$invalidate(34, replace = $$new_props.replace);
    		if ('inputClasses' in $$new_props) $$invalidate(35, inputClasses = $$new_props.inputClasses);
    		if ('classes' in $$new_props) $$invalidate(36, classes = $$new_props.classes);
    		if ('appendClasses' in $$new_props) $$invalidate(37, appendClasses = $$new_props.appendClasses);
    		if ('prependClasses' in $$new_props) $$invalidate(38, prependClasses = $$new_props.prependClasses);
    		if ('extend' in $$new_props) $$invalidate(39, extend = $$new_props.extend);
    		if ('focused' in $$new_props) $$invalidate(1, focused = $$new_props.focused);
    		if ('$$scope' in $$new_props) $$invalidate(69, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		utils,
    		ClassBuilder,
    		filterProps,
    		Icon,
    		Label: Label$1,
    		Hint,
    		Underline,
    		outlined,
    		value,
    		label,
    		placeholder,
    		hint,
    		error,
    		append,
    		prepend,
    		persistentHint,
    		textarea,
    		rows,
    		select,
    		dense,
    		autocomplete,
    		noUnderline,
    		appendReverse,
    		prependReverse,
    		color,
    		bgColor,
    		iconClass,
    		disabled,
    		inputDefault,
    		classesDefault: classesDefault$5,
    		appendDefault,
    		prependDefault,
    		add,
    		remove,
    		replace,
    		inputClasses,
    		classes,
    		appendClasses,
    		prependClasses,
    		bg,
    		border,
    		txt,
    		caret,
    		cb,
    		ccb,
    		acb,
    		pcb,
    		extend,
    		focused,
    		wClasses,
    		aClasses,
    		pClasses,
    		toggleFocused,
    		props,
    		dispatch,
    		iClasses,
    		labelOnTop,
    		showHint
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(77, $$props = assign(assign({}, $$props), $$new_props));
    		if ('outlined' in $$props) $$invalidate(2, outlined = $$new_props.outlined);
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('label' in $$props) $$invalidate(3, label = $$new_props.label);
    		if ('placeholder' in $$props) $$invalidate(4, placeholder = $$new_props.placeholder);
    		if ('hint' in $$props) $$invalidate(5, hint = $$new_props.hint);
    		if ('error' in $$props) $$invalidate(6, error = $$new_props.error);
    		if ('append' in $$props) $$invalidate(7, append = $$new_props.append);
    		if ('prepend' in $$props) $$invalidate(8, prepend = $$new_props.prepend);
    		if ('persistentHint' in $$props) $$invalidate(31, persistentHint = $$new_props.persistentHint);
    		if ('textarea' in $$props) $$invalidate(9, textarea = $$new_props.textarea);
    		if ('rows' in $$props) $$invalidate(10, rows = $$new_props.rows);
    		if ('select' in $$props) $$invalidate(11, select = $$new_props.select);
    		if ('dense' in $$props) $$invalidate(12, dense = $$new_props.dense);
    		if ('autocomplete' in $$props) $$invalidate(13, autocomplete = $$new_props.autocomplete);
    		if ('noUnderline' in $$props) $$invalidate(14, noUnderline = $$new_props.noUnderline);
    		if ('appendReverse' in $$props) $$invalidate(15, appendReverse = $$new_props.appendReverse);
    		if ('prependReverse' in $$props) $$invalidate(16, prependReverse = $$new_props.prependReverse);
    		if ('color' in $$props) $$invalidate(17, color = $$new_props.color);
    		if ('bgColor' in $$props) $$invalidate(18, bgColor = $$new_props.bgColor);
    		if ('iconClass' in $$props) $$invalidate(19, iconClass = $$new_props.iconClass);
    		if ('disabled' in $$props) $$invalidate(20, disabled = $$new_props.disabled);
    		if ('add' in $$props) $$invalidate(32, add = $$new_props.add);
    		if ('remove' in $$props) $$invalidate(33, remove = $$new_props.remove);
    		if ('replace' in $$props) $$invalidate(34, replace = $$new_props.replace);
    		if ('inputClasses' in $$props) $$invalidate(35, inputClasses = $$new_props.inputClasses);
    		if ('classes' in $$props) $$invalidate(36, classes = $$new_props.classes);
    		if ('appendClasses' in $$props) $$invalidate(37, appendClasses = $$new_props.appendClasses);
    		if ('prependClasses' in $$props) $$invalidate(38, prependClasses = $$new_props.prependClasses);
    		if ('extend' in $$props) $$invalidate(39, extend = $$new_props.extend);
    		if ('focused' in $$props) $$invalidate(1, focused = $$new_props.focused);
    		if ('wClasses' in $$props) $$invalidate(21, wClasses = $$new_props.wClasses);
    		if ('aClasses' in $$props) $$invalidate(22, aClasses = $$new_props.aClasses);
    		if ('pClasses' in $$props) $$invalidate(23, pClasses = $$new_props.pClasses);
    		if ('iClasses' in $$props) $$invalidate(24, iClasses = $$new_props.iClasses);
    		if ('labelOnTop' in $$props) $$invalidate(25, labelOnTop = $$new_props.labelOnTop);
    		if ('showHint' in $$props) $$invalidate(26, showHint = $$new_props.showHint);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*error, hint, focused*/ 98 | $$self.$$.dirty[1] & /*persistentHint*/ 1) {
    			$$invalidate(26, showHint = error || (persistentHint ? hint : focused && hint));
    		}

    		if ($$self.$$.dirty[0] & /*placeholder, focused, value*/ 19) {
    			$$invalidate(25, labelOnTop = placeholder || focused || (value || value === 0));
    		}

    		$$invalidate(24, iClasses = cb.flush().remove('pt-6 pb-2', outlined).add('border rounded bg-transparent py-4 duration-200 ease-in', outlined).add('border-error-500 caret-error-500', error).remove(caret(), error).add(caret(), !error).add(border(), outlined && focused && !error).add('bg-gray-100 dark:bg-dark-600', !outlined).add('bg-gray-300 dark:bg-dark-200', focused && !outlined).remove('px-4', prepend).add('pr-4 pl-10', prepend).add(add).remove('pt-6 pb-2', dense && !outlined).add('pt-4 pb-1', dense && !outlined).remove('bg-gray-100', disabled).add('bg-gray-50', disabled).add('cursor-pointer', select && !autocomplete).add($$props.class).remove(remove).replace(replace).extend(extend).get());

    		if ($$self.$$.dirty[0] & /*select, autocomplete, dense, outlined, error, disabled*/ 1062980) {
    			$$invalidate(21, wClasses = ccb.flush().add('select', select || autocomplete).add('dense', dense && !outlined).remove('mb-6 mt-2', dense && !outlined).add('mb-4 mt-1', dense).replace({ 'text-gray-600': 'text-error-500' }, error).add('text-gray-200', disabled).get());
    		}
    	};

    	$$invalidate(22, aClasses = acb.flush().get());
    	$$invalidate(23, pClasses = pcb.flush().get());
    	$$props = exclude_internal_props($$props);

    	return [
    		value,
    		focused,
    		outlined,
    		label,
    		placeholder,
    		hint,
    		error,
    		append,
    		prepend,
    		textarea,
    		rows,
    		select,
    		dense,
    		autocomplete,
    		noUnderline,
    		appendReverse,
    		prependReverse,
    		color,
    		bgColor,
    		iconClass,
    		disabled,
    		wClasses,
    		aClasses,
    		pClasses,
    		iClasses,
    		labelOnTop,
    		showHint,
    		txt,
    		toggleFocused,
    		props,
    		dispatch,
    		persistentHint,
    		add,
    		remove,
    		replace,
    		inputClasses,
    		classes,
    		appendClasses,
    		prependClasses,
    		extend,
    		slots,
    		blur_handler,
    		change_handler,
    		input_handler,
    		keydown_handler,
    		keypress_handler,
    		keyup_handler,
    		click_handler,
    		focus_handler,
    		change_handler_1,
    		input_handler_1,
    		keydown_handler_1,
    		keypress_handler_1,
    		keyup_handler_1,
    		click_handler_1,
    		focus_handler_1,
    		blur_handler_1,
    		change_handler_2,
    		input_handler_2,
    		keydown_handler_2,
    		keypress_handler_2,
    		keyup_handler_2,
    		click_handler_2,
    		blur_handler_2,
    		focus_handler_2,
    		input_input_handler,
    		textarea_1_input_handler,
    		click_handler_3,
    		click_handler_4,
    		$$scope
    	];
    }

    class TextField extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$z,
    			create_fragment$z,
    			safe_not_equal,
    			{
    				outlined: 2,
    				value: 0,
    				label: 3,
    				placeholder: 4,
    				hint: 5,
    				error: 6,
    				append: 7,
    				prepend: 8,
    				persistentHint: 31,
    				textarea: 9,
    				rows: 10,
    				select: 11,
    				dense: 12,
    				autocomplete: 13,
    				noUnderline: 14,
    				appendReverse: 15,
    				prependReverse: 16,
    				color: 17,
    				bgColor: 18,
    				iconClass: 19,
    				disabled: 20,
    				add: 32,
    				remove: 33,
    				replace: 34,
    				inputClasses: 35,
    				classes: 36,
    				appendClasses: 37,
    				prependClasses: 38,
    				extend: 39,
    				focused: 1
    			},
    			null,
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextField",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get outlined() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlined(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hint() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hint(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get error() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get append() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set append(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prepend() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prepend(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get persistentHint() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set persistentHint(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get textarea() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set textarea(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get select() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set select(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dense() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dense(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autocomplete() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autocomplete(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noUnderline() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noUnderline(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get appendReverse() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set appendReverse(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prependReverse() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prependReverse(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bgColor() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bgColor(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconClass() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconClass(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get add() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set add(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get remove() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set remove(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputClasses() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputClasses(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get appendClasses() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set appendClasses(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prependClasses() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prependClasses(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extend() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extend(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focused() {
    		throw new Error("<TextField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focused(value) {
    		throw new Error("<TextField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Checkbox/Label.svelte generated by Svelte v3.40.3 */
    const file$s = "node_modules/smelte/src/components/Checkbox/Label.svelte";

    // (27:8) {label}
    function fallback_block$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$4.name,
    		type: "fallback",
    		source: "(27:8) {label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let label_1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	const default_slot_or_fallback = default_slot || fallback_block$4(ctx);
    	let label_1_levels = [{ "aria-hidden": "true" }, /*$$props*/ ctx[2], { class: /*c*/ ctx[1] }];
    	let label_1_data = {};

    	for (let i = 0; i < label_1_levels.length; i += 1) {
    		label_1_data = assign(label_1_data, label_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(label_1, label_1_data);
    			add_location(label_1, file$s, 21, 0, 520);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(label_1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*label*/ 1)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
    				{ "aria-hidden": "true" },
    				dirty & /*$$props*/ 4 && /*$$props*/ ctx[2],
    				(!current || dirty & /*c*/ 2) && { class: /*c*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const classesDefault$4 = "pl-2 cursor-pointer 'text-gray-700 dark:text-gray-300'";

    function instance$y($$self, $$props, $$invalidate) {
    	let c;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Label', slots, ['default']);
    	let { classes = classesDefault$4 } = $$props;
    	let { label = "" } = $$props;
    	let { disabled = false } = $$props;
    	let { disabledClasses = "text-gray-500 dark:text-gray-600" } = $$props;
    	const cb = new ClassBuilder(classes, classesDefault$4);

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('classes' in $$new_props) $$invalidate(3, classes = $$new_props.classes);
    		if ('label' in $$new_props) $$invalidate(0, label = $$new_props.label);
    		if ('disabled' in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
    		if ('disabledClasses' in $$new_props) $$invalidate(5, disabledClasses = $$new_props.disabledClasses);
    		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ClassBuilder,
    		classesDefault: classesDefault$4,
    		classes,
    		label,
    		disabled,
    		disabledClasses,
    		cb,
    		c
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ('classes' in $$props) $$invalidate(3, classes = $$new_props.classes);
    		if ('label' in $$props) $$invalidate(0, label = $$new_props.label);
    		if ('disabled' in $$props) $$invalidate(4, disabled = $$new_props.disabled);
    		if ('disabledClasses' in $$props) $$invalidate(5, disabledClasses = $$new_props.disabledClasses);
    		if ('c' in $$props) $$invalidate(1, c = $$new_props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(1, c = cb.flush().add(classes, true, classesDefault$4).add(disabledClasses, disabled).add($$props.class).get());
    	};

    	$$props = exclude_internal_props($$props);
    	return [label, c, $$props, classes, disabled, disabledClasses, $$scope, slots];
    }

    class Label extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
    			classes: 3,
    			label: 0,
    			disabled: 4,
    			disabledClasses: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Label",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get classes() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabledClasses() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabledClasses(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Ripple/Ripple.svelte generated by Svelte v3.40.3 */
    const file$r = "node_modules/smelte/src/components/Ripple/Ripple.svelte";

    function create_fragment$x(ctx) {
    	let span;
    	let span_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			attr_dev(span, "class", span_class_value = "z-40 " + /*$$props*/ ctx[3].class + " p-2 rounded-full flex items-center justify-center top-0 left-0 " + (/*noHover*/ ctx[0] ? "" : /*hoverClass*/ ctx[1]) + " svelte-1o8z87d");
    			add_location(span, file$r, 15, 0, 293);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*ripple*/ ctx[2].call(null, span));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*$$props, noHover, hoverClass*/ 11 && span_class_value !== (span_class_value = "z-40 " + /*$$props*/ ctx[3].class + " p-2 rounded-full flex items-center justify-center top-0 left-0 " + (/*noHover*/ ctx[0] ? "" : /*hoverClass*/ ctx[1]) + " svelte-1o8z87d")) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let ripple;
    	let hoverClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ripple', slots, ['default']);
    	let { color = "primary" } = $$props;
    	let { noHover = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('color' in $$new_props) $$invalidate(4, color = $$new_props.color);
    		if ('noHover' in $$new_props) $$invalidate(0, noHover = $$new_props.noHover);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		color,
    		noHover,
    		createRipple: r,
    		hoverClass,
    		ripple
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    		if ('color' in $$props) $$invalidate(4, color = $$new_props.color);
    		if ('noHover' in $$props) $$invalidate(0, noHover = $$new_props.noHover);
    		if ('hoverClass' in $$props) $$invalidate(1, hoverClass = $$new_props.hoverClass);
    		if ('ripple' in $$props) $$invalidate(2, ripple = $$new_props.ripple);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*color*/ 16) {
    			$$invalidate(2, ripple = r(color, true));
    		}

    		if ($$self.$$.dirty & /*color*/ 16) {
    			$$invalidate(1, hoverClass = `hover:bg-${color}-transLight`);
    		}
    	};

    	$$props = exclude_internal_props($$props);
    	return [noHover, hoverClass, ripple, $$props, color, $$scope, slots];
    }

    class Ripple extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, { color: 4, noHover: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ripple",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get color() {
    		throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHover() {
    		throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHover(value) {
    		throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/RadioButton/RadioButton.svelte generated by Svelte v3.40.3 */
    const file$q = "node_modules/smelte/src/components/RadioButton/RadioButton.svelte";
    const get_label_slot_changes = dirty => ({});
    const get_label_slot_context = ctx => ({});

    // (54:6) {:else}
    function create_else_block$6(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				small: /*small*/ ctx[6],
    				class: /*disabled*/ ctx[3]
    				? 'text-gray-500 dark:text-gray-600'
    				: 'text-gray-600',
    				$$slots: { default: [create_default_slot_2$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty & /*small*/ 64) icon_changes.small = /*small*/ ctx[6];

    			if (dirty & /*disabled*/ 8) icon_changes.class = /*disabled*/ ctx[3]
    			? 'text-gray-500 dark:text-gray-600'
    			: 'text-gray-600';

    			if (dirty & /*$$scope*/ 8192) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(54:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (50:6) {#if selected === value}
    function create_if_block$h(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				small: /*small*/ ctx[6],
    				class: "text-" + (/*disabled*/ ctx[3] ? 'gray' : /*color*/ ctx[2]) + "-500",
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty & /*small*/ 64) icon_changes.small = /*small*/ ctx[6];
    			if (dirty & /*disabled, color*/ 12) icon_changes.class = "text-" + (/*disabled*/ ctx[3] ? 'gray' : /*color*/ ctx[2]) + "-500";

    			if (dirty & /*$$scope*/ 8192) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(50:6) {#if selected === value}",
    		ctx
    	});

    	return block;
    }

    // (55:8) <Icon {small} class={disabled ? 'text-gray-500 dark:text-gray-600' : 'text-gray-600'}>
    function create_default_slot_2$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("radio_button_unchecked");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$e.name,
    		type: "slot",
    		source: "(55:8) <Icon {small} class={disabled ? 'text-gray-500 dark:text-gray-600' : 'text-gray-600'}>",
    		ctx
    	});

    	return block;
    }

    // (51:8) <Icon {small} class="text-{disabled ? 'gray' : color}-500">
    function create_default_slot_1$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("radio_button_checked");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(51:8) <Icon {small} class=\\\"text-{disabled ? 'gray' : color}-500\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:4) <Ripple color={rippleColor}>
    function create_default_slot$j(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$h, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*selected*/ ctx[0] === /*value*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(49:4) <Ripple color={rippleColor}>",
    		ctx
    	});

    	return block;
    }

    // (61:21)      
    function fallback_block$3(ctx) {
    	let label_1;
    	let current;

    	label_1 = new Label({
    			props: {
    				disabled: /*disabled*/ ctx[3],
    				label: /*label*/ ctx[1],
    				class: /*labelClasses*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_1_changes = {};
    			if (dirty & /*disabled*/ 8) label_1_changes.disabled = /*disabled*/ ctx[3];
    			if (dirty & /*label*/ 2) label_1_changes.label = /*label*/ ctx[1];
    			if (dirty & /*labelClasses*/ 128) label_1_changes.class = /*labelClasses*/ ctx[7];
    			label_1.$set(label_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$3.name,
    		type: "fallback",
    		source: "(61:21)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let div1;
    	let input;
    	let input_selected_value;
    	let t0;
    	let div0;
    	let ripple;
    	let t1;
    	let current;
    	let mounted;
    	let dispose;

    	ripple = new Ripple({
    			props: {
    				color: /*rippleColor*/ ctx[8],
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const label_slot_template = /*#slots*/ ctx[12].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[13], get_label_slot_context);
    	const label_slot_or_fallback = label_slot || fallback_block$3(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			input = element("input");
    			t0 = space();
    			div0 = element("div");
    			create_component(ripple.$$.fragment);
    			t1 = space();
    			if (label_slot_or_fallback) label_slot_or_fallback.c();
    			attr_dev(input, "aria-label", /*label*/ ctx[1]);
    			attr_dev(input, "class", "hidden");
    			attr_dev(input, "type", "radio");
    			attr_dev(input, "role", "radio");
    			input.disabled = /*disabled*/ ctx[3];
    			attr_dev(input, "name", /*name*/ ctx[4]);
    			attr_dev(input, "selected", input_selected_value = /*selected*/ ctx[0] === /*value*/ ctx[5]);
    			add_location(input, file$q, 39, 2, 875);
    			attr_dev(div0, "class", "relative");
    			add_location(div0, file$q, 47, 2, 1023);
    			attr_dev(div1, "class", /*c*/ ctx[9]);
    			add_location(div1, file$q, 36, 0, 835);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, input);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			mount_component(ripple, div0, null);
    			append_dev(div1, t1);

    			if (label_slot_or_fallback) {
    				label_slot_or_fallback.m(div1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*select*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*label*/ 2) {
    				attr_dev(input, "aria-label", /*label*/ ctx[1]);
    			}

    			if (!current || dirty & /*disabled*/ 8) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[3]);
    			}

    			if (!current || dirty & /*name*/ 16) {
    				attr_dev(input, "name", /*name*/ ctx[4]);
    			}

    			if (!current || dirty & /*selected, value*/ 33 && input_selected_value !== (input_selected_value = /*selected*/ ctx[0] === /*value*/ ctx[5])) {
    				attr_dev(input, "selected", input_selected_value);
    			}

    			const ripple_changes = {};
    			if (dirty & /*rippleColor*/ 256) ripple_changes.color = /*rippleColor*/ ctx[8];

    			if (dirty & /*$$scope, small, disabled, color, selected, value*/ 8301) {
    				ripple_changes.$$scope = { dirty, ctx };
    			}

    			ripple.$set(ripple_changes);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[13], dirty, get_label_slot_changes),
    						get_label_slot_context
    					);
    				}
    			} else {
    				if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & /*disabled, label, labelClasses*/ 138)) {
    					label_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			if (!current || dirty & /*c*/ 512) {
    				attr_dev(div1, "class", /*c*/ ctx[9]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			transition_in(label_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			transition_out(label_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(ripple);
    			if (label_slot_or_fallback) label_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const classesDefault$3 = "inline-flex block items-center mb-2 cursor-pointer z-0";

    function instance$w($$self, $$props, $$invalidate) {
    	let c;
    	let rippleColor;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RadioButton', slots, ['label']);
    	let { selected = "" } = $$props;
    	let { label = "" } = $$props;
    	let { color = "primary" } = $$props;
    	let { disabled = false } = $$props;
    	let { name = "" } = $$props;
    	let { value = "" } = $$props;
    	let { classes = classesDefault$3 } = $$props;
    	let { small = false } = $$props;
    	let { labelClasses = i => i } = $$props;

    	function select() {
    		if (disabled) return;
    		$$invalidate(0, selected = value);
    	}

    	const cb = new ClassBuilder(classes, classesDefault$3);

    	$$self.$$set = $$new_props => {
    		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('selected' in $$new_props) $$invalidate(0, selected = $$new_props.selected);
    		if ('label' in $$new_props) $$invalidate(1, label = $$new_props.label);
    		if ('color' in $$new_props) $$invalidate(2, color = $$new_props.color);
    		if ('disabled' in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ('name' in $$new_props) $$invalidate(4, name = $$new_props.name);
    		if ('value' in $$new_props) $$invalidate(5, value = $$new_props.value);
    		if ('classes' in $$new_props) $$invalidate(11, classes = $$new_props.classes);
    		if ('small' in $$new_props) $$invalidate(6, small = $$new_props.small);
    		if ('labelClasses' in $$new_props) $$invalidate(7, labelClasses = $$new_props.labelClasses);
    		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		Ripple,
    		Label,
    		ClassBuilder,
    		classesDefault: classesDefault$3,
    		selected,
    		label,
    		color,
    		disabled,
    		name,
    		value,
    		classes,
    		small,
    		labelClasses,
    		select,
    		cb,
    		rippleColor,
    		c
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    		if ('selected' in $$props) $$invalidate(0, selected = $$new_props.selected);
    		if ('label' in $$props) $$invalidate(1, label = $$new_props.label);
    		if ('color' in $$props) $$invalidate(2, color = $$new_props.color);
    		if ('disabled' in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ('name' in $$props) $$invalidate(4, name = $$new_props.name);
    		if ('value' in $$props) $$invalidate(5, value = $$new_props.value);
    		if ('classes' in $$props) $$invalidate(11, classes = $$new_props.classes);
    		if ('small' in $$props) $$invalidate(6, small = $$new_props.small);
    		if ('labelClasses' in $$props) $$invalidate(7, labelClasses = $$new_props.labelClasses);
    		if ('rippleColor' in $$props) $$invalidate(8, rippleColor = $$new_props.rippleColor);
    		if ('c' in $$props) $$invalidate(9, c = $$new_props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(9, c = cb.flush().add(classes, true, classesDefault$3).add($$props.class).get());

    		if ($$self.$$.dirty & /*value, disabled, color*/ 44) {
    			$$invalidate(8, rippleColor = value && !disabled ? color : 'gray');
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		selected,
    		label,
    		color,
    		disabled,
    		name,
    		value,
    		small,
    		labelClasses,
    		rippleColor,
    		c,
    		select,
    		classes,
    		slots,
    		$$scope
    	];
    }

    class RadioButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
    			selected: 0,
    			label: 1,
    			color: 2,
    			disabled: 3,
    			name: 4,
    			value: 5,
    			classes: 11,
    			small: 6,
    			labelClasses: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RadioButton",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get selected() {
    		throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get small() {
    		throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set small(value) {
    		throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelClasses() {
    		throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelClasses(value) {
    		throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/RadioButton/RadioButtonGroup.svelte generated by Svelte v3.40.3 */
    const file$p = "node_modules/smelte/src/components/RadioButton/RadioButtonGroup.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes = dirty => ({ item: dirty & /*items*/ 2 });
    const get_default_slot_context = ctx => ({ item: /*item*/ ctx[14] });

    // (26:17)        
    function fallback_block$2(ctx) {
    	let radiobutton;
    	let updating_selected;
    	let t;
    	let current;

    	const radiobutton_spread_levels = [
    		{ class: /*buttonClasses*/ ctx[6] },
    		/*item*/ ctx[14],
    		{ color: /*color*/ ctx[4] },
    		{ small: /*small*/ ctx[5] },
    		{
    			name: /*name*/ ctx[2] || `radio-${Math.random()}`
    		},
    		{ disabled: /*disabled*/ ctx[3] }
    	];

    	function radiobutton_selected_binding(value) {
    		/*radiobutton_selected_binding*/ ctx[11](value);
    	}

    	let radiobutton_props = {};

    	for (let i = 0; i < radiobutton_spread_levels.length; i += 1) {
    		radiobutton_props = assign(radiobutton_props, radiobutton_spread_levels[i]);
    	}

    	if (/*selected*/ ctx[0] !== void 0) {
    		radiobutton_props.selected = /*selected*/ ctx[0];
    	}

    	radiobutton = new RadioButton({ props: radiobutton_props, $$inline: true });
    	binding_callbacks.push(() => bind(radiobutton, 'selected', radiobutton_selected_binding));

    	const block = {
    		c: function create() {
    			create_component(radiobutton.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(radiobutton, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const radiobutton_changes = (dirty & /*buttonClasses, items, color, small, name, Math, disabled*/ 126)
    			? get_spread_update(radiobutton_spread_levels, [
    					dirty & /*buttonClasses*/ 64 && { class: /*buttonClasses*/ ctx[6] },
    					dirty & /*items*/ 2 && get_spread_object(/*item*/ ctx[14]),
    					dirty & /*color*/ 16 && { color: /*color*/ ctx[4] },
    					dirty & /*small*/ 32 && { small: /*small*/ ctx[5] },
    					dirty & /*name, Math*/ 4 && {
    						name: /*name*/ ctx[2] || `radio-${Math.random()}`
    					},
    					dirty & /*disabled*/ 8 && { disabled: /*disabled*/ ctx[3] }
    				])
    			: {};

    			if (!updating_selected && dirty & /*selected*/ 1) {
    				updating_selected = true;
    				radiobutton_changes.selected = /*selected*/ ctx[0];
    				add_flush_callback(() => updating_selected = false);
    			}

    			radiobutton.$set(radiobutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(radiobutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(radiobutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(radiobutton, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(26:17)        ",
    		ctx
    	});

    	return block;
    }

    // (25:2) {#each items as item}
    function create_each_block$4(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context);
    	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, items*/ 514)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*buttonClasses, items, color, small, name, disabled, selected*/ 127)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(25:2) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let div;
    	let current;
    	let each_value = /*items*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", /*c*/ ctx[7]);
    			add_location(div, file$p, 23, 0, 592);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*buttonClasses, items, color, small, name, Math, disabled, selected, $$scope*/ 639) {
    				each_value = /*items*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*c*/ 128) {
    				attr_dev(div, "class", /*c*/ ctx[7]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const classesDefault$2 = "flex flex-col mb-4 cursor-pointer";

    function instance$v($$self, $$props, $$invalidate) {
    	let c;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RadioButtonGroup', slots, ['default']);
    	let { classes = classesDefault$2 } = $$props;
    	let { items = [] } = $$props;
    	let { selected = "" } = $$props;
    	let { name = "" } = $$props;
    	let { disabled = false } = $$props;
    	let { color = "primary" } = $$props;
    	let { small = false } = $$props;
    	let { buttonClasses = "inline-flex block items-center mb-2 cursor-pointer z-0" } = $$props;
    	const cb = new ClassBuilder(classes, classesDefault$2);

    	function radiobutton_selected_binding(value) {
    		selected = value;
    		$$invalidate(0, selected);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('classes' in $$new_props) $$invalidate(8, classes = $$new_props.classes);
    		if ('items' in $$new_props) $$invalidate(1, items = $$new_props.items);
    		if ('selected' in $$new_props) $$invalidate(0, selected = $$new_props.selected);
    		if ('name' in $$new_props) $$invalidate(2, name = $$new_props.name);
    		if ('disabled' in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ('color' in $$new_props) $$invalidate(4, color = $$new_props.color);
    		if ('small' in $$new_props) $$invalidate(5, small = $$new_props.small);
    		if ('buttonClasses' in $$new_props) $$invalidate(6, buttonClasses = $$new_props.buttonClasses);
    		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		RadioButton,
    		ClassBuilder,
    		classesDefault: classesDefault$2,
    		classes,
    		items,
    		selected,
    		name,
    		disabled,
    		color,
    		small,
    		buttonClasses,
    		cb,
    		c
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    		if ('classes' in $$props) $$invalidate(8, classes = $$new_props.classes);
    		if ('items' in $$props) $$invalidate(1, items = $$new_props.items);
    		if ('selected' in $$props) $$invalidate(0, selected = $$new_props.selected);
    		if ('name' in $$props) $$invalidate(2, name = $$new_props.name);
    		if ('disabled' in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ('color' in $$props) $$invalidate(4, color = $$new_props.color);
    		if ('small' in $$props) $$invalidate(5, small = $$new_props.small);
    		if ('buttonClasses' in $$props) $$invalidate(6, buttonClasses = $$new_props.buttonClasses);
    		if ('c' in $$props) $$invalidate(7, c = $$new_props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(7, c = cb.flush().add($$props.class).get());
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		selected,
    		items,
    		name,
    		disabled,
    		color,
    		small,
    		buttonClasses,
    		c,
    		classes,
    		$$scope,
    		slots,
    		radiobutton_selected_binding
    	];
    }

    class RadioButtonGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
    			classes: 8,
    			items: 1,
    			selected: 0,
    			name: 2,
    			disabled: 3,
    			color: 4,
    			small: 5,
    			buttonClasses: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RadioButtonGroup",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get classes() {
    		throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get small() {
    		throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set small(value) {
    		throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get buttonClasses() {
    		throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttonClasses(value) {
    		throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/ProgressLinear/ProgressLinear.svelte generated by Svelte v3.40.3 */
    const file$o = "node_modules/smelte/src/components/ProgressLinear/ProgressLinear.svelte";

    function create_fragment$u(ctx) {
    	let div2;
    	let div0;
    	let div0_class_value;
    	let div0_style_value;
    	let t;
    	let div1;
    	let div1_class_value;
    	let div2_class_value;
    	let div2_transition;
    	let current;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", div0_class_value = "bg-" + /*color*/ ctx[2] + "-500 h-1 absolute" + " svelte-mguqwa");

    			attr_dev(div0, "style", div0_style_value = /*progress*/ ctx[1]
    			? `width: ${/*progress*/ ctx[1]}%`
    			: "");

    			toggle_class(div0, "inc", !/*progress*/ ctx[1]);
    			toggle_class(div0, "transition", /*progress*/ ctx[1]);
    			add_location(div0, file$o, 56, 2, 987);
    			attr_dev(div1, "class", div1_class_value = "bg-" + /*color*/ ctx[2] + "-500 h-1 absolute dec" + " svelte-mguqwa");
    			toggle_class(div1, "hidden", /*progress*/ ctx[1]);
    			add_location(div1, file$o, 61, 2, 1145);
    			attr_dev(div2, "class", div2_class_value = "top-0 left-0 w-full h-1 bg-" + /*color*/ ctx[2] + "-100 overflow-hidden relative" + " svelte-mguqwa");
    			toggle_class(div2, "fixed", /*app*/ ctx[0]);
    			toggle_class(div2, "z-50", /*app*/ ctx[0]);
    			toggle_class(div2, "hidden", /*app*/ ctx[0] && !/*initialized*/ ctx[3]);
    			add_location(div2, file$o, 50, 0, 790);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*color*/ 4 && div0_class_value !== (div0_class_value = "bg-" + /*color*/ ctx[2] + "-500 h-1 absolute" + " svelte-mguqwa")) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (!current || dirty & /*progress*/ 2 && div0_style_value !== (div0_style_value = /*progress*/ ctx[1]
    			? `width: ${/*progress*/ ctx[1]}%`
    			: "")) {
    				attr_dev(div0, "style", div0_style_value);
    			}

    			if (dirty & /*color, progress*/ 6) {
    				toggle_class(div0, "inc", !/*progress*/ ctx[1]);
    			}

    			if (dirty & /*color, progress*/ 6) {
    				toggle_class(div0, "transition", /*progress*/ ctx[1]);
    			}

    			if (!current || dirty & /*color*/ 4 && div1_class_value !== (div1_class_value = "bg-" + /*color*/ ctx[2] + "-500 h-1 absolute dec" + " svelte-mguqwa")) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (dirty & /*color, progress*/ 6) {
    				toggle_class(div1, "hidden", /*progress*/ ctx[1]);
    			}

    			if (!current || dirty & /*color*/ 4 && div2_class_value !== (div2_class_value = "top-0 left-0 w-full h-1 bg-" + /*color*/ ctx[2] + "-100 overflow-hidden relative" + " svelte-mguqwa")) {
    				attr_dev(div2, "class", div2_class_value);
    			}

    			if (dirty & /*color, app*/ 5) {
    				toggle_class(div2, "fixed", /*app*/ ctx[0]);
    			}

    			if (dirty & /*color, app*/ 5) {
    				toggle_class(div2, "z-50", /*app*/ ctx[0]);
    			}

    			if (dirty & /*color, app, initialized*/ 13) {
    				toggle_class(div2, "hidden", /*app*/ ctx[0] && !/*initialized*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 300 }, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 300 }, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching && div2_transition) div2_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ProgressLinear', slots, []);
    	let { app = false } = $$props;
    	let { progress = 0 } = $$props;
    	let { color = "primary" } = $$props;
    	let initialized = false;

    	onMount(() => {
    		if (!app) return;

    		setTimeout(
    			() => {
    				$$invalidate(3, initialized = true);
    			},
    			200
    		);
    	});

    	const writable_props = ['app', 'progress', 'color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ProgressLinear> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('app' in $$props) $$invalidate(0, app = $$props.app);
    		if ('progress' in $$props) $$invalidate(1, progress = $$props.progress);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		slide,
    		app,
    		progress,
    		color,
    		initialized
    	});

    	$$self.$inject_state = $$props => {
    		if ('app' in $$props) $$invalidate(0, app = $$props.app);
    		if ('progress' in $$props) $$invalidate(1, progress = $$props.progress);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('initialized' in $$props) $$invalidate(3, initialized = $$props.initialized);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [app, progress, color, initialized];
    }

    class ProgressLinear extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, { app: 0, progress: 1, color: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ProgressLinear",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get app() {
    		throw new Error("<ProgressLinear>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set app(value) {
    		throw new Error("<ProgressLinear>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get progress() {
    		throw new Error("<ProgressLinear>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set progress(value) {
    		throw new Error("<ProgressLinear>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ProgressLinear>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ProgressLinear>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Slider/Slider.svelte generated by Svelte v3.40.3 */
    const file$n = "node_modules/smelte/src/components/Slider/Slider.svelte";

    function create_fragment$t(ctx) {
    	let label_1;
    	let t0;
    	let t1;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			t0 = text(/*label*/ ctx[1]);
    			t1 = space();
    			input = element("input");
    			add_location(label_1, file$n, 53, 0, 1244);
    			attr_dev(input, "type", "range");
    			attr_dev(input, "class", /*c*/ ctx[7]);
    			attr_dev(input, "min", /*min*/ ctx[3]);
    			attr_dev(input, "max", /*max*/ ctx[4]);
    			attr_dev(input, "step", /*step*/ ctx[5]);
    			input.disabled = /*disabled*/ ctx[2];
    			attr_dev(input, "style", /*style*/ ctx[6]);
    			add_location(input, file$n, 54, 0, 1267);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*applyColor*/ ctx[8].call(null, input)),
    					listen_dev(input, "change", /*input_change_input_handler*/ ctx[13]),
    					listen_dev(input, "input", /*input_change_input_handler*/ ctx[13]),
    					listen_dev(input, "change", /*change_handler*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);

    			if (dirty & /*c*/ 128) {
    				attr_dev(input, "class", /*c*/ ctx[7]);
    			}

    			if (dirty & /*min*/ 8) {
    				attr_dev(input, "min", /*min*/ ctx[3]);
    			}

    			if (dirty & /*max*/ 16) {
    				attr_dev(input, "max", /*max*/ ctx[4]);
    			}

    			if (dirty & /*step*/ 32) {
    				attr_dev(input, "step", /*step*/ ctx[5]);
    			}

    			if (dirty & /*disabled*/ 4) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (dirty & /*style*/ 64) {
    				attr_dev(input, "style", /*style*/ ctx[6]);
    			}

    			if (dirty & /*value*/ 1) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let c;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Slider', slots, []);
    	let { value = 0 } = $$props;
    	let { label = "" } = $$props;
    	let { color = "primary" } = $$props;
    	let { disabled = false } = $$props;
    	let { min = 0 } = $$props;
    	let { max = 100 } = $$props;
    	let { step = null } = $$props;
    	const classesDefault = `bg-${color}-50 w-full rounded cursor-pointer`;
    	let { classes = classesDefault } = $$props;
    	let toPercent;
    	const cb = new ClassBuilder(classes, classesDefault);
    	const getColor = c => `var(${c})`;
    	let style;

    	function applyColor(node) {
    		if (typeof window === "undefined") return false;
    		let c = getColor(`--color-${color}-500`);
    		node.style.setProperty('--bg', c);
    		node.style.setProperty('--bg-focus', c);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_change_input_handler() {
    		value = to_number(this.value);
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('label' in $$new_props) $$invalidate(1, label = $$new_props.label);
    		if ('color' in $$new_props) $$invalidate(9, color = $$new_props.color);
    		if ('disabled' in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('min' in $$new_props) $$invalidate(3, min = $$new_props.min);
    		if ('max' in $$new_props) $$invalidate(4, max = $$new_props.max);
    		if ('step' in $$new_props) $$invalidate(5, step = $$new_props.step);
    		if ('classes' in $$new_props) $$invalidate(10, classes = $$new_props.classes);
    	};

    	$$self.$capture_state = () => ({
    		ClassBuilder,
    		Ripple,
    		value,
    		label,
    		color,
    		disabled,
    		min,
    		max,
    		step,
    		classesDefault,
    		classes,
    		toPercent,
    		cb,
    		getColor,
    		style,
    		applyColor,
    		c
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('label' in $$props) $$invalidate(1, label = $$new_props.label);
    		if ('color' in $$props) $$invalidate(9, color = $$new_props.color);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('min' in $$props) $$invalidate(3, min = $$new_props.min);
    		if ('max' in $$props) $$invalidate(4, max = $$new_props.max);
    		if ('step' in $$props) $$invalidate(5, step = $$new_props.step);
    		if ('classes' in $$props) $$invalidate(10, classes = $$new_props.classes);
    		if ('toPercent' in $$props) $$invalidate(11, toPercent = $$new_props.toPercent);
    		if ('style' in $$props) $$invalidate(6, style = $$new_props.style);
    		if ('c' in $$props) $$invalidate(7, c = $$new_props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*max, min*/ 24) {
    			{
    				let factor = 100.0 / (max - min);
    				$$invalidate(11, toPercent = v => (v - min) * factor);
    			}
    		}

    		$$invalidate(7, c = cb.flush().add(classes, true, classesDefault).add($$props.class).get());

    		if ($$self.$$.dirty & /*color, toPercent, value, disabled*/ 2565) {
    			{
    				let c1 = getColor(`--color-${color}-500`);
    				let c2 = getColor(`--color-${color}-200`);
    				let cv = toPercent(value);

    				$$invalidate(6, style = disabled
    				? ""
    				: `background: linear-gradient(to right, ${c1} 0%, ${c1} ${cv}%, ${c2} ${cv}%, ${c2} 100%); --bg: ${c1}; --bg-focus: ${c1}`);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		value,
    		label,
    		disabled,
    		min,
    		max,
    		step,
    		style,
    		c,
    		applyColor,
    		color,
    		classes,
    		toPercent,
    		change_handler,
    		input_change_input_handler
    	];
    }

    class Slider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
    			value: 0,
    			label: 1,
    			color: 9,
    			disabled: 2,
    			min: 3,
    			max: 4,
    			step: 5,
    			classes: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Slider",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get value() {
    		throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function withColor(color, store) {
      return message =>
        store.update(u => [
          ...u,
          {
            message,
            ts: new Date(),
            color,
            toString() {
              return message;
            }
          }
        ]);
    }

    function notificationQueue() {
      const store = writable([]);

      return {
        subscribe: store.subscribe,

        notify: withColor("gray", store),
        error: withColor("error", store),
        alert: withColor("alert", store),

        remove: i =>
          store.update(u => {
            u.splice(i, 1);
            return u;
          })
      };
    }

    /* node_modules/smelte/src/components/Snackbar/Notifications.svelte generated by Svelte v3.40.3 */

    notificationQueue();

    /* node_modules/smelte/src/components/Tabs/TabButton.svelte generated by Svelte v3.40.3 */
    const file$m = "node_modules/smelte/src/components/Tabs/TabButton.svelte";

    // (57:0) {:else}
    function create_else_block$5(ctx) {
    	let li;
    	let div1;
    	let t;
    	let div0;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*icon*/ ctx[1] && create_if_block_2$4(ctx);
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

    	const block = {
    		c: function create() {
    			li = element("li");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			div0 = element("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			add_location(div0, file$m, 68, 6, 1528);
    			attr_dev(div1, "class", /*tabClasses*/ ctx[5]);
    			add_location(div1, file$m, 63, 4, 1408);
    			attr_dev(li, "class", /*c*/ ctx[7]);
    			add_location(li, file$m, 57, 2, 1318);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div0, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*ripple*/ ctx[8].call(null, li)),
    					listen_dev(li, "click", /*click_handler_2*/ ctx[15], false, false, false),
    					listen_dev(li, "click", /*click_handler_1*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*icon*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*text*/ 8)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			if (!current || dirty & /*tabClasses*/ 32) {
    				attr_dev(div1, "class", /*tabClasses*/ ctx[5]);
    			}

    			if (!current || dirty & /*c*/ 128) {
    				attr_dev(li, "class", /*c*/ ctx[7]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (if_block) if_block.d();
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(57:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (40:0) {#if to}
    function create_if_block$g(ctx) {
    	let a;
    	let div1;
    	let t;
    	let div0;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*icon*/ ctx[1] && create_if_block_1$b(ctx);
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

    	const block = {
    		c: function create() {
    			a = element("a");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			div0 = element("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			add_location(div0, file$m, 51, 6, 1243);
    			attr_dev(div1, "class", /*tabClasses*/ ctx[5]);
    			add_location(div1, file$m, 46, 4, 1123);
    			attr_dev(a, "href", /*to*/ ctx[4]);
    			attr_dev(a, "class", /*c*/ ctx[7]);
    			add_location(a, file$m, 40, 2, 1056);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div0, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*ripple*/ ctx[8].call(null, a)),
    					listen_dev(a, "click", /*click_handler*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*icon*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*text*/ 8)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			if (!current || dirty & /*tabClasses*/ 32) {
    				attr_dev(div1, "class", /*tabClasses*/ ctx[5]);
    			}

    			if (!current || dirty & /*to*/ 16) {
    				attr_dev(a, "href", /*to*/ ctx[4]);
    			}

    			if (!current || dirty & /*c*/ 128) {
    				attr_dev(a, "class", /*c*/ ctx[7]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block) if_block.d();
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(40:0) {#if to}",
    		ctx
    	});

    	return block;
    }

    // (65:6) {#if icon}
    function create_if_block_2$4(ctx) {
    	let icon_1;
    	let current;

    	icon_1 = new Icon({
    			props: {
    				class: "mb-1",
    				color: /*textColor*/ ctx[6],
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_1_changes = {};
    			if (dirty & /*textColor*/ 64) icon_1_changes.color = /*textColor*/ ctx[6];

    			if (dirty & /*$$scope, icon*/ 65538) {
    				icon_1_changes.$$scope = { dirty, ctx };
    			}

    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(65:6) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (66:8) <Icon class="mb-1" color={textColor}>
    function create_default_slot_1$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*icon*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*icon*/ 2) set_data_dev(t, /*icon*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(66:8) <Icon class=\\\"mb-1\\\" color={textColor}>",
    		ctx
    	});

    	return block;
    }

    // (70:14) {text}
    function fallback_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*text*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 8) set_data_dev(t, /*text*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(70:14) {text}",
    		ctx
    	});

    	return block;
    }

    // (48:6) {#if icon}
    function create_if_block_1$b(ctx) {
    	let icon_1;
    	let current;

    	icon_1 = new Icon({
    			props: {
    				class: "mb-1",
    				color: /*textColor*/ ctx[6],
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_1_changes = {};
    			if (dirty & /*textColor*/ 64) icon_1_changes.color = /*textColor*/ ctx[6];

    			if (dirty & /*$$scope, icon*/ 65538) {
    				icon_1_changes.$$scope = { dirty, ctx };
    			}

    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(48:6) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (49:8) <Icon class="mb-1" color={textColor}>
    function create_default_slot$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*icon*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*icon*/ 2) set_data_dev(t, /*icon*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(49:8) <Icon class=\\\"mb-1\\\" color={textColor}>",
    		ctx
    	});

    	return block;
    }

    // (53:14) {text}
    function fallback_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*text*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 8) set_data_dev(t, /*text*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(53:14) {text}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$g, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*to*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const classesDefault$1 = "duration-100 relative overflow-hidden text-center w-full h-full p-4 cursor-pointer flex mx-auto items-center text-sm h-full";

    function instance$s($$self, $$props, $$invalidate) {
    	let textColor;
    	let c;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabButton', slots, ['default']);
    	let { classes = classesDefault$1 } = $$props;
    	let { icon = "" } = $$props;
    	let { id = "" } = $$props;
    	let { text = "" } = $$props;
    	let { to = "" } = $$props;
    	let { selected = "" } = $$props;
    	let { color = "primary" } = $$props;
    	let { notSelectedColor = "white" } = $$props;
    	let { tabClasses = "flex flex-col items-center content-center mx-auto" } = $$props;
    	const ripple = r(color);
    	const { txt, bg } = utils(color);
    	const notSelected = utils(notSelectedColor);
    	const cb = new ClassBuilder(classes, classesDefault$1);

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler_2 = () => $$invalidate(0, selected = id);

    	$$self.$$set = $$new_props => {
    		$$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('classes' in $$new_props) $$invalidate(9, classes = $$new_props.classes);
    		if ('icon' in $$new_props) $$invalidate(1, icon = $$new_props.icon);
    		if ('id' in $$new_props) $$invalidate(2, id = $$new_props.id);
    		if ('text' in $$new_props) $$invalidate(3, text = $$new_props.text);
    		if ('to' in $$new_props) $$invalidate(4, to = $$new_props.to);
    		if ('selected' in $$new_props) $$invalidate(0, selected = $$new_props.selected);
    		if ('color' in $$new_props) $$invalidate(10, color = $$new_props.color);
    		if ('notSelectedColor' in $$new_props) $$invalidate(11, notSelectedColor = $$new_props.notSelectedColor);
    		if ('tabClasses' in $$new_props) $$invalidate(5, tabClasses = $$new_props.tabClasses);
    		if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		createRipple: r,
    		utils,
    		ClassBuilder,
    		classesDefault: classesDefault$1,
    		classes,
    		icon,
    		id,
    		text,
    		to,
    		selected,
    		color,
    		notSelectedColor,
    		tabClasses,
    		ripple,
    		txt,
    		bg,
    		notSelected,
    		cb,
    		textColor,
    		c
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    		if ('classes' in $$props) $$invalidate(9, classes = $$new_props.classes);
    		if ('icon' in $$props) $$invalidate(1, icon = $$new_props.icon);
    		if ('id' in $$props) $$invalidate(2, id = $$new_props.id);
    		if ('text' in $$props) $$invalidate(3, text = $$new_props.text);
    		if ('to' in $$props) $$invalidate(4, to = $$new_props.to);
    		if ('selected' in $$props) $$invalidate(0, selected = $$new_props.selected);
    		if ('color' in $$props) $$invalidate(10, color = $$new_props.color);
    		if ('notSelectedColor' in $$props) $$invalidate(11, notSelectedColor = $$new_props.notSelectedColor);
    		if ('tabClasses' in $$props) $$invalidate(5, tabClasses = $$new_props.tabClasses);
    		if ('textColor' in $$props) $$invalidate(6, textColor = $$new_props.textColor);
    		if ('c' in $$props) $$invalidate(7, c = $$new_props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selected, id*/ 5) {
    			$$invalidate(6, textColor = selected === id ? txt() : notSelected.txt());
    		}

    		$$invalidate(7, c = cb.flush().add($$props.class).add("uppercase", icon).add(textColor).add(`hover:bg-${color}-transLight hover:${txt(900)}`).get());
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		selected,
    		icon,
    		id,
    		text,
    		to,
    		tabClasses,
    		textColor,
    		c,
    		ripple,
    		classes,
    		color,
    		notSelectedColor,
    		slots,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		$$scope
    	];
    }

    class TabButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
    			classes: 9,
    			icon: 1,
    			id: 2,
    			text: 3,
    			to: 4,
    			selected: 0,
    			color: 10,
    			notSelectedColor: 11,
    			tabClasses: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabButton",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get classes() {
    		throw new Error("<TabButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<TabButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<TabButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<TabButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<TabButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<TabButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<TabButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<TabButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get to() {
    		throw new Error("<TabButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set to(value) {
    		throw new Error("<TabButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<TabButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<TabButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<TabButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<TabButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get notSelectedColor() {
    		throw new Error("<TabButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notSelectedColor(value) {
    		throw new Error("<TabButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabClasses() {
    		throw new Error("<TabButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabClasses(value) {
    		throw new Error("<TabButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Tabs/Tab.svelte generated by Svelte v3.40.3 */

    // (6:0) {#if selected === id}
    function create_if_block$f(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(6:0) {#if selected === id}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*selected*/ ctx[0] === /*id*/ ctx[1] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*selected*/ ctx[0] === /*id*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*selected, id*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tab', slots, ['default']);
    	let { selected = undefined } = $$props;
    	let { id = null } = $$props;
    	const writable_props = ['selected', 'id'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tab> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ selected, id });

    	$$self.$inject_state = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selected, id, $$scope, slots];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, { selected: 0, id: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get selected() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Tabs/Indicator.svelte generated by Svelte v3.40.3 */
    const file$l = "node_modules/smelte/src/components/Tabs/Indicator.svelte";

    function create_fragment$q(ctx) {
    	let div;
    	let div_transition;
    	let current;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "absolute bottom-0 left-0 transition " + /*bg*/ ctx[2](700));
    			set_style(div, "width", /*width*/ ctx[0] + "px");
    			set_style(div, "left", /*left*/ ctx[1] + "px");
    			set_style(div, "height", "2px");
    			toggle_class(div, "hidden", /*left*/ ctx[1] < 0);
    			add_location(div, file$l, 11, 0, 223);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*width*/ 1) {
    				set_style(div, "width", /*width*/ ctx[0] + "px");
    			}

    			if (!current || dirty & /*left*/ 2) {
    				set_style(div, "left", /*left*/ ctx[1] + "px");
    			}

    			if (dirty & /*left*/ 2) {
    				toggle_class(div, "hidden", /*left*/ ctx[1] < 0);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Indicator', slots, []);
    	let { width = 0 } = $$props;
    	let { left = 0 } = $$props;
    	let { color = "primary" } = $$props;
    	const { bg } = utils(color);
    	const writable_props = ['width', 'left', 'color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Indicator> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('left' in $$props) $$invalidate(1, left = $$props.left);
    		if ('color' in $$props) $$invalidate(3, color = $$props.color);
    	};

    	$$self.$capture_state = () => ({ slide, utils, width, left, color, bg });

    	$$self.$inject_state = $$props => {
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('left' in $$props) $$invalidate(1, left = $$props.left);
    		if ('color' in $$props) $$invalidate(3, color = $$props.color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, left, bg, color];
    }

    class Indicator extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { width: 0, left: 1, color: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Indicator",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get width() {
    		throw new Error("<Indicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Indicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get left() {
    		throw new Error("<Indicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<Indicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Indicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Indicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Tabs/Tabs.svelte generated by Svelte v3.40.3 */
    const file$k = "node_modules/smelte/src/components/Tabs/Tabs.svelte";
    const get_content_slot_changes = dirty => ({ selected: dirty & /*selected*/ 1 });
    const get_content_slot_context = ctx => ({ selected: /*selected*/ ctx[0] });

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	child_ctx[23] = i;
    	return child_ctx;
    }

    const get_item_slot_changes = dirty => ({
    	color: dirty & /*color*/ 8,
    	item: dirty & /*items*/ 2
    });

    const get_item_slot_context = ctx => ({
    	color: /*color*/ ctx[3],
    	item: /*item*/ ctx[21]
    });

    // (69:6) <TabButton         class={tabButtonClasses}         bind:selected         {...item}         {color}         {notSelectedColor}       >
    function create_default_slot$h(ctx) {
    	let t_value = /*item*/ ctx[21].text + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items*/ 2 && t_value !== (t_value = /*item*/ ctx[21].text + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(69:6) <TabButton         class={tabButtonClasses}         bind:selected         {...item}         {color}         {notSelectedColor}       >",
    		ctx
    	});

    	return block;
    }

    // (68:37)        
    function fallback_block(ctx) {
    	let tabbutton;
    	let updating_selected;
    	let current;

    	const tabbutton_spread_levels = [
    		{ class: /*tabButtonClasses*/ ctx[6] },
    		/*item*/ ctx[21],
    		{ color: /*color*/ ctx[3] },
    		{
    			notSelectedColor: /*notSelectedColor*/ ctx[4]
    		}
    	];

    	function tabbutton_selected_binding(value) {
    		/*tabbutton_selected_binding*/ ctx[14](value);
    	}

    	let tabbutton_props = {
    		$$slots: { default: [create_default_slot$h] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < tabbutton_spread_levels.length; i += 1) {
    		tabbutton_props = assign(tabbutton_props, tabbutton_spread_levels[i]);
    	}

    	if (/*selected*/ ctx[0] !== void 0) {
    		tabbutton_props.selected = /*selected*/ ctx[0];
    	}

    	tabbutton = new TabButton({ props: tabbutton_props, $$inline: true });
    	binding_callbacks.push(() => bind(tabbutton, 'selected', tabbutton_selected_binding));

    	const block = {
    		c: function create() {
    			create_component(tabbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tabbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabbutton_changes = (dirty & /*tabButtonClasses, items, color, notSelectedColor*/ 90)
    			? get_spread_update(tabbutton_spread_levels, [
    					dirty & /*tabButtonClasses*/ 64 && { class: /*tabButtonClasses*/ ctx[6] },
    					dirty & /*items*/ 2 && get_spread_object(/*item*/ ctx[21]),
    					dirty & /*color*/ 8 && { color: /*color*/ ctx[3] },
    					dirty & /*notSelectedColor*/ 16 && {
    						notSelectedColor: /*notSelectedColor*/ ctx[4]
    					}
    				])
    			: {};

    			if (dirty & /*$$scope, items*/ 65538) {
    				tabbutton_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_selected && dirty & /*selected*/ 1) {
    				updating_selected = true;
    				tabbutton_changes.selected = /*selected*/ ctx[0];
    				add_flush_callback(() => updating_selected = false);
    			}

    			tabbutton.$set(tabbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tabbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(68:37)        ",
    		ctx
    	});

    	return block;
    }

    // (67:2) {#each items as item, i}
    function create_each_block$3(ctx) {
    	let current;
    	const item_slot_template = /*#slots*/ ctx[13].item;
    	const item_slot = create_slot(item_slot_template, ctx, /*$$scope*/ ctx[16], get_item_slot_context);
    	const item_slot_or_fallback = item_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			if (item_slot_or_fallback) item_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (item_slot_or_fallback) {
    				item_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (item_slot) {
    				if (item_slot.p && (!current || dirty & /*$$scope, color, items*/ 65546)) {
    					update_slot_base(
    						item_slot,
    						item_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(item_slot_template, /*$$scope*/ ctx[16], dirty, get_item_slot_changes),
    						get_item_slot_context
    					);
    				}
    			} else {
    				if (item_slot_or_fallback && item_slot_or_fallback.p && (!current || dirty & /*tabButtonClasses, items, color, notSelectedColor, selected*/ 91)) {
    					item_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(item_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(item_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (item_slot_or_fallback) item_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(67:2) {#each items as item, i}",
    		ctx
    	});

    	return block;
    }

    // (78:2) {#if indicator && offset !== null}
    function create_if_block_1$a(ctx) {
    	let indicator_1;
    	let current;

    	indicator_1 = new Indicator({
    			props: {
    				color: /*color*/ ctx[3],
    				width: /*indicatorWidth*/ ctx[8],
    				left: /*offset*/ ctx[9]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(indicator_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(indicator_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const indicator_1_changes = {};
    			if (dirty & /*color*/ 8) indicator_1_changes.color = /*color*/ ctx[3];
    			if (dirty & /*indicatorWidth*/ 256) indicator_1_changes.width = /*indicatorWidth*/ ctx[8];
    			if (dirty & /*offset*/ 512) indicator_1_changes.left = /*offset*/ ctx[9];
    			indicator_1.$set(indicator_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indicator_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indicator_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(indicator_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(78:2) {#if indicator && offset !== null}",
    		ctx
    	});

    	return block;
    }

    // (82:0) {#if loading}
    function create_if_block$e(ctx) {
    	let progresslinear;
    	let current;

    	progresslinear = new ProgressLinear({
    			props: { color: /*color*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(progresslinear.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(progresslinear, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const progresslinear_changes = {};
    			if (dirty & /*color*/ 8) progresslinear_changes.color = /*color*/ ctx[3];
    			progresslinear.$set(progresslinear_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(progresslinear.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(progresslinear.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(progresslinear, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(82:0) {#if loading}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let current;
    	let each_value = /*items*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block0 = /*indicator*/ ctx[2] && /*offset*/ ctx[9] !== null && create_if_block_1$a(ctx);
    	let if_block1 = /*loading*/ ctx[5] && create_if_block$e(ctx);
    	const content_slot_template = /*#slots*/ ctx[13].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[16], get_content_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (content_slot) content_slot.c();
    			attr_dev(div, "class", /*c*/ ctx[10]);
    			add_location(div, file$k, 63, 0, 1651);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			/*div_binding*/ ctx[15](div);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t2, anchor);

    			if (content_slot) {
    				content_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*tabButtonClasses, items, color, notSelectedColor, selected, $$scope*/ 65627) {
    				each_value = /*items*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, t0);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*indicator*/ ctx[2] && /*offset*/ ctx[9] !== null) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*indicator, offset*/ 516) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$a(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*c*/ 1024) {
    				attr_dev(div, "class", /*c*/ ctx[10]);
    			}

    			if (/*loading*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*loading*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$e(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t2.parentNode, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty & /*$$scope, selected*/ 65537)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[16], dirty, get_content_slot_changes),
    						get_content_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(content_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(content_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (if_block0) if_block0.d();
    			/*div_binding*/ ctx[15](null);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (content_slot) content_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const classesDefault = "y-0 h-full items-center relative mx-auto z-20";

    function instance$p($$self, $$props, $$invalidate) {
    	let c;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabs', slots, ['item','content']);
    	let { selected = null } = $$props;
    	let { navigation = false } = $$props;
    	let { items = [] } = $$props;
    	let { indicator = true } = $$props;
    	let { color = "white" } = $$props;
    	let { notSelectedColor = "white" } = $$props;
    	let { loading = false } = $$props;
    	let { tabButtonClasses = i => i } = $$props;
    	let node;
    	let indicatorWidth = 0;
    	let indicatorOffset = 0;
    	let offset = null;

    	function calcIndicator() {
    		$$invalidate(8, indicatorWidth = node ? node.offsetWidth / items.length : 0);
    		let left = 0;

    		if (selected && items.findIndex(i => selected.includes(i.to || i.id)) !== -1) {
    			const longestMatch = items.map((item, index) => [index, item]).filter(([index, item]) => selected.includes(item.to || item.id)).sort(([index1, item1], [index2, item2]) => (item2.to || item2.id).length - (item1.to || item1.id).length)[0];

    			if (longestMatch) {
    				left = longestMatch[0];
    				$$invalidate(9, offset = left * indicatorWidth);
    			}
    		} else {
    			$$invalidate(9, offset = null);
    		}
    	}

    	onMount(() => calcIndicator());
    	let { classes = classesDefault } = $$props;
    	const cb = new ClassBuilder(classes, classesDefault);

    	function tabbutton_selected_binding(value) {
    		selected = value;
    		$$invalidate(0, selected);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			node = $$value;
    			$$invalidate(7, node);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('selected' in $$new_props) $$invalidate(0, selected = $$new_props.selected);
    		if ('navigation' in $$new_props) $$invalidate(11, navigation = $$new_props.navigation);
    		if ('items' in $$new_props) $$invalidate(1, items = $$new_props.items);
    		if ('indicator' in $$new_props) $$invalidate(2, indicator = $$new_props.indicator);
    		if ('color' in $$new_props) $$invalidate(3, color = $$new_props.color);
    		if ('notSelectedColor' in $$new_props) $$invalidate(4, notSelectedColor = $$new_props.notSelectedColor);
    		if ('loading' in $$new_props) $$invalidate(5, loading = $$new_props.loading);
    		if ('tabButtonClasses' in $$new_props) $$invalidate(6, tabButtonClasses = $$new_props.tabButtonClasses);
    		if ('classes' in $$new_props) $$invalidate(12, classes = $$new_props.classes);
    		if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		ClassBuilder,
    		Indicator,
    		ProgressLinear,
    		TabButton,
    		selected,
    		navigation,
    		items,
    		indicator,
    		color,
    		notSelectedColor,
    		loading,
    		tabButtonClasses,
    		node,
    		indicatorWidth,
    		indicatorOffset,
    		offset,
    		calcIndicator,
    		classesDefault,
    		classes,
    		cb,
    		c
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
    		if ('selected' in $$props) $$invalidate(0, selected = $$new_props.selected);
    		if ('navigation' in $$props) $$invalidate(11, navigation = $$new_props.navigation);
    		if ('items' in $$props) $$invalidate(1, items = $$new_props.items);
    		if ('indicator' in $$props) $$invalidate(2, indicator = $$new_props.indicator);
    		if ('color' in $$props) $$invalidate(3, color = $$new_props.color);
    		if ('notSelectedColor' in $$props) $$invalidate(4, notSelectedColor = $$new_props.notSelectedColor);
    		if ('loading' in $$props) $$invalidate(5, loading = $$new_props.loading);
    		if ('tabButtonClasses' in $$props) $$invalidate(6, tabButtonClasses = $$new_props.tabButtonClasses);
    		if ('node' in $$props) $$invalidate(7, node = $$new_props.node);
    		if ('indicatorWidth' in $$props) $$invalidate(8, indicatorWidth = $$new_props.indicatorWidth);
    		if ('indicatorOffset' in $$props) indicatorOffset = $$new_props.indicatorOffset;
    		if ('offset' in $$props) $$invalidate(9, offset = $$new_props.offset);
    		if ('classes' in $$props) $$invalidate(12, classes = $$new_props.classes);
    		if ('c' in $$props) $$invalidate(10, c = $$new_props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selected*/ 1) {
    			calcIndicator();
    		}

    		$$invalidate(10, c = cb.flush().add($$props.class).add('hidden md:flex w-full max-w-2xl', navigation).add('flex', !navigation).get());
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		selected,
    		items,
    		indicator,
    		color,
    		notSelectedColor,
    		loading,
    		tabButtonClasses,
    		node,
    		indicatorWidth,
    		offset,
    		c,
    		navigation,
    		classes,
    		slots,
    		tabbutton_selected_binding,
    		div_binding,
    		$$scope
    	];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
    			selected: 0,
    			navigation: 11,
    			items: 1,
    			indicator: 2,
    			color: 3,
    			notSelectedColor: 4,
    			loading: 5,
    			tabButtonClasses: 6,
    			classes: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get selected() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navigation() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navigation(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get notSelectedColor() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notSelectedColor(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabButtonClasses() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabButtonClasses(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/smelte/src/components/Switch/Switch.svelte generated by Svelte v3.40.3 */
    const file$j = "node_modules/smelte/src/components/Switch/Switch.svelte";

    // (63:4) <Ripple color={value && !disabled ? color : 'gray'} noHover>
    function create_default_slot$g(ctx) {
    	let div;
    	let div_style_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", /*th*/ ctx[5]);
    			attr_dev(div, "style", div_style_value = /*value*/ ctx[0] ? 'left: 1.25rem' : "");
    			add_location(div, file$j, 63, 6, 1902);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*th*/ 32) {
    				attr_dev(div, "class", /*th*/ ctx[5]);
    			}

    			if (dirty & /*value*/ 1 && div_style_value !== (div_style_value = /*value*/ ctx[0] ? 'left: 1.25rem' : "")) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(63:4) <Ripple color={value && !disabled ? color : 'gray'} noHover>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let div2;
    	let input;
    	let t0;
    	let div1;
    	let div0;
    	let t1;
    	let ripple;
    	let t2;
    	let label_1;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;

    	ripple = new Ripple({
    			props: {
    				color: /*value*/ ctx[0] && !/*disabled*/ ctx[3]
    				? /*color*/ ctx[2]
    				: 'gray',
    				noHover: true,
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			input = element("input");
    			t0 = space();
    			div1 = element("div");
    			div0 = element("div");
    			t1 = space();
    			create_component(ripple.$$.fragment);
    			t2 = space();
    			label_1 = element("label");
    			t3 = text(/*label*/ ctx[1]);
    			attr_dev(input, "class", "hidden");
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$j, 59, 2, 1707);
    			attr_dev(div0, "class", "w-full h-full absolute");
    			add_location(div0, file$j, 61, 4, 1792);
    			attr_dev(div1, "class", /*tr*/ ctx[6]);
    			add_location(div1, file$j, 60, 2, 1771);
    			attr_dev(label_1, "aria-hidden", "true");
    			attr_dev(label_1, "class", /*l*/ ctx[4]);
    			add_location(label_1, file$j, 68, 2, 1999);
    			attr_dev(div2, "class", /*c*/ ctx[7]);
    			add_location(div2, file$j, 58, 0, 1672);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, input);
    			set_input_value(input, /*value*/ ctx[0]);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div1, t1);
    			mount_component(ripple, div1, null);
    			append_dev(div2, t2);
    			append_dev(div2, label_1);
    			append_dev(label_1, t3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_handler*/ ctx[14]),
    					listen_dev(input, "change", /*change_handler*/ ctx[13], false, false, false),
    					listen_dev(div2, "click", /*check*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*value*/ 1) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}

    			const ripple_changes = {};

    			if (dirty & /*value, disabled, color*/ 13) ripple_changes.color = /*value*/ ctx[0] && !/*disabled*/ ctx[3]
    			? /*color*/ ctx[2]
    			: 'gray';

    			if (dirty & /*$$scope, th, value*/ 2097185) {
    				ripple_changes.$$scope = { dirty, ctx };
    			}

    			ripple.$set(ripple_changes);

    			if (!current || dirty & /*tr*/ 64) {
    				attr_dev(div1, "class", /*tr*/ ctx[6]);
    			}

    			if (!current || dirty & /*label*/ 2) set_data_dev(t3, /*label*/ ctx[1]);

    			if (!current || dirty & /*l*/ 16) {
    				attr_dev(label_1, "class", /*l*/ ctx[4]);
    			}

    			if (!current || dirty & /*c*/ 128) {
    				attr_dev(div2, "class", /*c*/ ctx[7]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(ripple);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const trackClassesDefault = "relative w-10 h-auto z-0 rounded-full overflow-visible flex items-center justify-center";
    const thumbClassesDefault = "rounded-full p-2 w-5 h-5 absolute shadow duration-100";
    const labelClassesDefault = "pl-2 cursor-pointer";

    function instance$o($$self, $$props, $$invalidate) {
    	let c;
    	let tr;
    	let th;
    	let l;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Switch', slots, []);
    	const classesDefault = `inline-flex items-center mb-2 cursor-pointer z-10`;
    	let { value = false } = $$props;
    	let { label = "" } = $$props;
    	let { color = "primary" } = $$props;
    	let { disabled = false } = $$props;
    	let { trackClasses = trackClassesDefault } = $$props;
    	let { thumbClasses = thumbClassesDefault } = $$props;
    	let { labelClasses = labelClassesDefault } = $$props;
    	let { classes = classesDefault } = $$props;
    	const cb = new ClassBuilder(classes, classesDefault);
    	const trcb = new ClassBuilder(trackClasses, trackClassesDefault);
    	const thcb = new ClassBuilder(thumbClasses, thumbClassesDefault);
    	const lcb = new ClassBuilder(labelClasses, labelClassesDefault);

    	function check() {
    		if (disabled) return;
    		$$invalidate(0, value = !value);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_change_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('label' in $$new_props) $$invalidate(1, label = $$new_props.label);
    		if ('color' in $$new_props) $$invalidate(2, color = $$new_props.color);
    		if ('disabled' in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ('trackClasses' in $$new_props) $$invalidate(9, trackClasses = $$new_props.trackClasses);
    		if ('thumbClasses' in $$new_props) $$invalidate(10, thumbClasses = $$new_props.thumbClasses);
    		if ('labelClasses' in $$new_props) $$invalidate(11, labelClasses = $$new_props.labelClasses);
    		if ('classes' in $$new_props) $$invalidate(12, classes = $$new_props.classes);
    	};

    	$$self.$capture_state = () => ({
    		Ripple,
    		ClassBuilder,
    		classesDefault,
    		trackClassesDefault,
    		thumbClassesDefault,
    		labelClassesDefault,
    		value,
    		label,
    		color,
    		disabled,
    		trackClasses,
    		thumbClasses,
    		labelClasses,
    		classes,
    		cb,
    		trcb,
    		thcb,
    		lcb,
    		check,
    		l,
    		th,
    		tr,
    		c
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('label' in $$props) $$invalidate(1, label = $$new_props.label);
    		if ('color' in $$props) $$invalidate(2, color = $$new_props.color);
    		if ('disabled' in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ('trackClasses' in $$props) $$invalidate(9, trackClasses = $$new_props.trackClasses);
    		if ('thumbClasses' in $$props) $$invalidate(10, thumbClasses = $$new_props.thumbClasses);
    		if ('labelClasses' in $$props) $$invalidate(11, labelClasses = $$new_props.labelClasses);
    		if ('classes' in $$props) $$invalidate(12, classes = $$new_props.classes);
    		if ('l' in $$props) $$invalidate(4, l = $$new_props.l);
    		if ('th' in $$props) $$invalidate(5, th = $$new_props.th);
    		if ('tr' in $$props) $$invalidate(6, tr = $$new_props.tr);
    		if ('c' in $$props) $$invalidate(7, c = $$new_props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(7, c = cb.flush().add(classes, true, classesDefault).add($$props.class).get());

    		if ($$self.$$.dirty & /*value, color, trackClasses*/ 517) {
    			$$invalidate(6, tr = trcb.flush().add("bg-gray-700", !value).add(`bg-${color}-200`, value).add(trackClasses, true, trackClassesDefault).get());
    		}

    		if ($$self.$$.dirty & /*thumbClasses, value, color*/ 1029) {
    			$$invalidate(5, th = thcb.flush().add(thumbClasses, true, thumbClassesDefault).add("bg-white left-0", !value).add(`bg-${color}-400`, value).get());
    		}

    		if ($$self.$$.dirty & /*labelClasses, disabled*/ 2056) {
    			$$invalidate(4, l = lcb.flush().add(labelClasses, true, labelClassesDefault).add("text-gray-500", disabled).add("text-gray-700", !disabled).get());
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		value,
    		label,
    		color,
    		disabled,
    		l,
    		th,
    		tr,
    		c,
    		check,
    		trackClasses,
    		thumbClasses,
    		labelClasses,
    		classes,
    		change_handler,
    		input_change_handler
    	];
    }

    class Switch extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			value: 0,
    			label: 1,
    			color: 2,
    			disabled: 3,
    			trackClasses: 9,
    			thumbClasses: 10,
    			labelClasses: 11,
    			classes: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Switch",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get value() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trackClasses() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trackClasses(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get thumbClasses() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set thumbClasses(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelClasses() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelClasses(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /**
     * marked - a markdown parser
     * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/markedjs/marked
     */

    var marked = createCommonjsModule(function (module, exports) {
    /**
     * DO NOT EDIT THIS FILE
     * The code in this file is generated from files in ./src/
     */

    (function (global, factory) {
      module.exports = factory() ;
    }(commonjsGlobal, (function () {
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
      }

      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (it) return (it = it.call(o)).next.bind(it);

        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          return function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          };
        }

        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var defaults$5 = {exports: {}};

      function getDefaults$1() {
        return {
          baseUrl: null,
          breaks: false,
          extensions: null,
          gfm: true,
          headerIds: true,
          headerPrefix: '',
          highlight: null,
          langPrefix: 'language-',
          mangle: true,
          pedantic: false,
          renderer: null,
          sanitize: false,
          sanitizer: null,
          silent: false,
          smartLists: false,
          smartypants: false,
          tokenizer: null,
          walkTokens: null,
          xhtml: false
        };
      }

      function changeDefaults$1(newDefaults) {
        defaults$5.exports.defaults = newDefaults;
      }

      defaults$5.exports = {
        defaults: getDefaults$1(),
        getDefaults: getDefaults$1,
        changeDefaults: changeDefaults$1
      };

      /**
       * Helpers
       */
      var escapeTest = /[&<>"']/;
      var escapeReplace = /[&<>"']/g;
      var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
      var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
      var escapeReplacements = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };

      var getEscapeReplacement = function getEscapeReplacement(ch) {
        return escapeReplacements[ch];
      };

      function escape$2(html, encode) {
        if (encode) {
          if (escapeTest.test(html)) {
            return html.replace(escapeReplace, getEscapeReplacement);
          }
        } else {
          if (escapeTestNoEncode.test(html)) {
            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
          }
        }

        return html;
      }

      var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

      function unescape$1(html) {
        // explicitly match decimal, hex, and named HTML entities
        return html.replace(unescapeTest, function (_, n) {
          n = n.toLowerCase();
          if (n === 'colon') return ':';

          if (n.charAt(0) === '#') {
            return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
          }

          return '';
        });
      }

      var caret = /(^|[^\[])\^/g;

      function edit$1(regex, opt) {
        regex = regex.source || regex;
        opt = opt || '';
        var obj = {
          replace: function replace(name, val) {
            val = val.source || val;
            val = val.replace(caret, '$1');
            regex = regex.replace(name, val);
            return obj;
          },
          getRegex: function getRegex() {
            return new RegExp(regex, opt);
          }
        };
        return obj;
      }

      var nonWordAndColonTest = /[^\w:]/g;
      var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

      function cleanUrl$1(sanitize, base, href) {
        if (sanitize) {
          var prot;

          try {
            prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, '').toLowerCase();
          } catch (e) {
            return null;
          }

          if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
            return null;
          }
        }

        if (base && !originIndependentUrl.test(href)) {
          href = resolveUrl(base, href);
        }

        try {
          href = encodeURI(href).replace(/%25/g, '%');
        } catch (e) {
          return null;
        }

        return href;
      }

      var baseUrls = {};
      var justDomain = /^[^:]+:\/*[^/]*$/;
      var protocol = /^([^:]+:)[\s\S]*$/;
      var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

      function resolveUrl(base, href) {
        if (!baseUrls[' ' + base]) {
          // we can ignore everything in base after the last slash of its path component,
          // but we might need to add _that_
          // https://tools.ietf.org/html/rfc3986#section-3
          if (justDomain.test(base)) {
            baseUrls[' ' + base] = base + '/';
          } else {
            baseUrls[' ' + base] = rtrim$1(base, '/', true);
          }
        }

        base = baseUrls[' ' + base];
        var relativeBase = base.indexOf(':') === -1;

        if (href.substring(0, 2) === '//') {
          if (relativeBase) {
            return href;
          }

          return base.replace(protocol, '$1') + href;
        } else if (href.charAt(0) === '/') {
          if (relativeBase) {
            return href;
          }

          return base.replace(domain, '$1') + href;
        } else {
          return base + href;
        }
      }

      var noopTest$1 = {
        exec: function noopTest() {}
      };

      function merge$2(obj) {
        var i = 1,
            target,
            key;

        for (; i < arguments.length; i++) {
          target = arguments[i];

          for (key in target) {
            if (Object.prototype.hasOwnProperty.call(target, key)) {
              obj[key] = target[key];
            }
          }
        }

        return obj;
      }

      function splitCells$1(tableRow, count) {
        // ensure that every cell-delimiting pipe has a space
        // before it to distinguish it from an escaped pipe
        var row = tableRow.replace(/\|/g, function (match, offset, str) {
          var escaped = false,
              curr = offset;

          while (--curr >= 0 && str[curr] === '\\') {
            escaped = !escaped;
          }

          if (escaped) {
            // odd number of slashes means | is escaped
            // so we leave it alone
            return '|';
          } else {
            // add space before unescaped |
            return ' |';
          }
        }),
            cells = row.split(/ \|/);
        var i = 0;

        if (cells.length > count) {
          cells.splice(count);
        } else {
          while (cells.length < count) {
            cells.push('');
          }
        }

        for (; i < cells.length; i++) {
          // leading or trailing whitespace is ignored per the gfm spec
          cells[i] = cells[i].trim().replace(/\\\|/g, '|');
        }

        return cells;
      } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
      // /c*$/ is vulnerable to REDOS.
      // invert: Remove suffix of non-c chars instead. Default falsey.


      function rtrim$1(str, c, invert) {
        var l = str.length;

        if (l === 0) {
          return '';
        } // Length of suffix matching the invert condition.


        var suffLen = 0; // Step left until we fail to match the invert condition.

        while (suffLen < l) {
          var currChar = str.charAt(l - suffLen - 1);

          if (currChar === c && !invert) {
            suffLen++;
          } else if (currChar !== c && invert) {
            suffLen++;
          } else {
            break;
          }
        }

        return str.substr(0, l - suffLen);
      }

      function findClosingBracket$1(str, b) {
        if (str.indexOf(b[1]) === -1) {
          return -1;
        }

        var l = str.length;
        var level = 0,
            i = 0;

        for (; i < l; i++) {
          if (str[i] === '\\') {
            i++;
          } else if (str[i] === b[0]) {
            level++;
          } else if (str[i] === b[1]) {
            level--;

            if (level < 0) {
              return i;
            }
          }
        }

        return -1;
      }

      function checkSanitizeDeprecation$1(opt) {
        if (opt && opt.sanitize && !opt.silent) {
          console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
        }
      } // copied from https://stackoverflow.com/a/5450113/806777


      function repeatString$1(pattern, count) {
        if (count < 1) {
          return '';
        }

        var result = '';

        while (count > 1) {
          if (count & 1) {
            result += pattern;
          }

          count >>= 1;
          pattern += pattern;
        }

        return result + pattern;
      }

      var helpers = {
        escape: escape$2,
        unescape: unescape$1,
        edit: edit$1,
        cleanUrl: cleanUrl$1,
        resolveUrl: resolveUrl,
        noopTest: noopTest$1,
        merge: merge$2,
        splitCells: splitCells$1,
        rtrim: rtrim$1,
        findClosingBracket: findClosingBracket$1,
        checkSanitizeDeprecation: checkSanitizeDeprecation$1,
        repeatString: repeatString$1
      };

      var defaults$4 = defaults$5.exports.defaults;
      var rtrim = helpers.rtrim,
          splitCells = helpers.splitCells,
          _escape = helpers.escape,
          findClosingBracket = helpers.findClosingBracket;

      function outputLink(cap, link, raw) {
        var href = link.href;
        var title = link.title ? _escape(link.title) : null;
        var text = cap[1].replace(/\\([\[\]])/g, '$1');

        if (cap[0].charAt(0) !== '!') {
          return {
            type: 'link',
            raw: raw,
            href: href,
            title: title,
            text: text
          };
        } else {
          return {
            type: 'image',
            raw: raw,
            href: href,
            title: title,
            text: _escape(text)
          };
        }
      }

      function indentCodeCompensation(raw, text) {
        var matchIndentToCode = raw.match(/^(\s+)(?:```)/);

        if (matchIndentToCode === null) {
          return text;
        }

        var indentToCode = matchIndentToCode[1];
        return text.split('\n').map(function (node) {
          var matchIndentInNode = node.match(/^\s+/);

          if (matchIndentInNode === null) {
            return node;
          }

          var indentInNode = matchIndentInNode[0];

          if (indentInNode.length >= indentToCode.length) {
            return node.slice(indentToCode.length);
          }

          return node;
        }).join('\n');
      }
      /**
       * Tokenizer
       */


      var Tokenizer_1 = /*#__PURE__*/function () {
        function Tokenizer(options) {
          this.options = options || defaults$4;
        }

        var _proto = Tokenizer.prototype;

        _proto.space = function space(src) {
          var cap = this.rules.block.newline.exec(src);

          if (cap) {
            if (cap[0].length > 1) {
              return {
                type: 'space',
                raw: cap[0]
              };
            }

            return {
              raw: '\n'
            };
          }
        };

        _proto.code = function code(src) {
          var cap = this.rules.block.code.exec(src);

          if (cap) {
            var text = cap[0].replace(/^ {1,4}/gm, '');
            return {
              type: 'code',
              raw: cap[0],
              codeBlockStyle: 'indented',
              text: !this.options.pedantic ? rtrim(text, '\n') : text
            };
          }
        };

        _proto.fences = function fences(src) {
          var cap = this.rules.block.fences.exec(src);

          if (cap) {
            var raw = cap[0];
            var text = indentCodeCompensation(raw, cap[3] || '');
            return {
              type: 'code',
              raw: raw,
              lang: cap[2] ? cap[2].trim() : cap[2],
              text: text
            };
          }
        };

        _proto.heading = function heading(src) {
          var cap = this.rules.block.heading.exec(src);

          if (cap) {
            var text = cap[2].trim(); // remove trailing #s

            if (/#$/.test(text)) {
              var trimmed = rtrim(text, '#');

              if (this.options.pedantic) {
                text = trimmed.trim();
              } else if (!trimmed || / $/.test(trimmed)) {
                // CommonMark requires space before trailing #s
                text = trimmed.trim();
              }
            }

            return {
              type: 'heading',
              raw: cap[0],
              depth: cap[1].length,
              text: text
            };
          }
        };

        _proto.nptable = function nptable(src) {
          var cap = this.rules.block.nptable.exec(src);

          if (cap) {
            var item = {
              type: 'table',
              header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
              raw: cap[0]
            };

            if (item.header.length === item.align.length) {
              var l = item.align.length;
              var i;

              for (i = 0; i < l; i++) {
                if (/^ *-+: *$/.test(item.align[i])) {
                  item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(item.align[i])) {
                  item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(item.align[i])) {
                  item.align[i] = 'left';
                } else {
                  item.align[i] = null;
                }
              }

              l = item.cells.length;

              for (i = 0; i < l; i++) {
                item.cells[i] = splitCells(item.cells[i], item.header.length);
              }

              return item;
            }
          }
        };

        _proto.hr = function hr(src) {
          var cap = this.rules.block.hr.exec(src);

          if (cap) {
            return {
              type: 'hr',
              raw: cap[0]
            };
          }
        };

        _proto.blockquote = function blockquote(src) {
          var cap = this.rules.block.blockquote.exec(src);

          if (cap) {
            var text = cap[0].replace(/^ *> ?/gm, '');
            return {
              type: 'blockquote',
              raw: cap[0],
              text: text
            };
          }
        };

        _proto.list = function list(src) {
          var cap = this.rules.block.list.exec(src);

          if (cap) {
            var raw = cap[0];
            var bull = cap[2];
            var isordered = bull.length > 1;
            var list = {
              type: 'list',
              raw: raw,
              ordered: isordered,
              start: isordered ? +bull.slice(0, -1) : '',
              loose: false,
              items: []
            }; // Get each top-level item.

            var itemMatch = cap[0].match(this.rules.block.item);
            var next = false,
                item,
                space,
                bcurr,
                bnext,
                addBack,
                loose,
                istask,
                ischecked,
                endMatch;
            var l = itemMatch.length;
            bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);

            for (var i = 0; i < l; i++) {
              item = itemMatch[i];
              raw = item;

              if (!this.options.pedantic) {
                // Determine if current item contains the end of the list
                endMatch = item.match(new RegExp('\\n\\s*\\n {0,' + (bcurr[0].length - 1) + '}\\S'));

                if (endMatch) {
                  addBack = item.length - endMatch.index + itemMatch.slice(i + 1).join('\n').length;
                  list.raw = list.raw.substring(0, list.raw.length - addBack);
                  item = item.substring(0, endMatch.index);
                  raw = item;
                  l = i + 1;
                }
              } // Determine whether the next list item belongs here.
              // Backpedal if it does not belong in this list.


              if (i !== l - 1) {
                bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);

                if (!this.options.pedantic ? bnext[1].length >= bcurr[0].length || bnext[1].length > 3 : bnext[1].length > bcurr[1].length) {
                  // nested list or continuation
                  itemMatch.splice(i, 2, itemMatch[i] + (!this.options.pedantic && bnext[1].length < bcurr[0].length && !itemMatch[i].match(/\n$/) ? '' : '\n') + itemMatch[i + 1]);
                  i--;
                  l--;
                  continue;
                } else if ( // different bullet style
                !this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {
                  addBack = itemMatch.slice(i + 1).join('\n').length;
                  list.raw = list.raw.substring(0, list.raw.length - addBack);
                  i = l - 1;
                }

                bcurr = bnext;
              } // Remove the list item's bullet
              // so it is seen as the next token.


              space = item.length;
              item = item.replace(/^ *([*+-]|\d+[.)]) ?/, ''); // Outdent whatever the
              // list item contains. Hacky.

              if (~item.indexOf('\n ')) {
                space -= item.length;
                item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');
              } // trim item newlines at end


              item = rtrim(item, '\n');

              if (i !== l - 1) {
                raw = raw + '\n';
              } // Determine whether item is loose or not.
              // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
              // for discount behavior.


              loose = next || /\n\n(?!\s*$)/.test(raw);

              if (i !== l - 1) {
                next = raw.slice(-2) === '\n\n';
                if (!loose) loose = next;
              }

              if (loose) {
                list.loose = true;
              } // Check for task list items


              if (this.options.gfm) {
                istask = /^\[[ xX]\] /.test(item);
                ischecked = undefined;

                if (istask) {
                  ischecked = item[1] !== ' ';
                  item = item.replace(/^\[[ xX]\] +/, '');
                }
              }

              list.items.push({
                type: 'list_item',
                raw: raw,
                task: istask,
                checked: ischecked,
                loose: loose,
                text: item
              });
            }

            return list;
          }
        };

        _proto.html = function html(src) {
          var cap = this.rules.block.html.exec(src);

          if (cap) {
            return {
              type: this.options.sanitize ? 'paragraph' : 'html',
              raw: cap[0],
              pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
              text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
            };
          }
        };

        _proto.def = function def(src) {
          var cap = this.rules.block.def.exec(src);

          if (cap) {
            if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
            var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
            return {
              type: 'def',
              tag: tag,
              raw: cap[0],
              href: cap[2],
              title: cap[3]
            };
          }
        };

        _proto.table = function table(src) {
          var cap = this.rules.block.table.exec(src);

          if (cap) {
            var item = {
              type: 'table',
              header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
            };

            if (item.header.length === item.align.length) {
              item.raw = cap[0];
              var l = item.align.length;
              var i;

              for (i = 0; i < l; i++) {
                if (/^ *-+: *$/.test(item.align[i])) {
                  item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(item.align[i])) {
                  item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(item.align[i])) {
                  item.align[i] = 'left';
                } else {
                  item.align[i] = null;
                }
              }

              l = item.cells.length;

              for (i = 0; i < l; i++) {
                item.cells[i] = splitCells(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
              }

              return item;
            }
          }
        };

        _proto.lheading = function lheading(src) {
          var cap = this.rules.block.lheading.exec(src);

          if (cap) {
            return {
              type: 'heading',
              raw: cap[0],
              depth: cap[2].charAt(0) === '=' ? 1 : 2,
              text: cap[1]
            };
          }
        };

        _proto.paragraph = function paragraph(src) {
          var cap = this.rules.block.paragraph.exec(src);

          if (cap) {
            return {
              type: 'paragraph',
              raw: cap[0],
              text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
            };
          }
        };

        _proto.text = function text(src) {
          var cap = this.rules.block.text.exec(src);

          if (cap) {
            return {
              type: 'text',
              raw: cap[0],
              text: cap[0]
            };
          }
        };

        _proto.escape = function escape(src) {
          var cap = this.rules.inline.escape.exec(src);

          if (cap) {
            return {
              type: 'escape',
              raw: cap[0],
              text: _escape(cap[1])
            };
          }
        };

        _proto.tag = function tag(src, inLink, inRawBlock) {
          var cap = this.rules.inline.tag.exec(src);

          if (cap) {
            if (!inLink && /^<a /i.test(cap[0])) {
              inLink = true;
            } else if (inLink && /^<\/a>/i.test(cap[0])) {
              inLink = false;
            }

            if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
              inRawBlock = true;
            } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
              inRawBlock = false;
            }

            return {
              type: this.options.sanitize ? 'text' : 'html',
              raw: cap[0],
              inLink: inLink,
              inRawBlock: inRawBlock,
              text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
            };
          }
        };

        _proto.link = function link(src) {
          var cap = this.rules.inline.link.exec(src);

          if (cap) {
            var trimmedUrl = cap[2].trim();

            if (!this.options.pedantic && /^</.test(trimmedUrl)) {
              // commonmark requires matching angle brackets
              if (!/>$/.test(trimmedUrl)) {
                return;
              } // ending angle bracket cannot be escaped


              var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');

              if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                return;
              }
            } else {
              // find closing parenthesis
              var lastParenIndex = findClosingBracket(cap[2], '()');

              if (lastParenIndex > -1) {
                var start = cap[0].indexOf('!') === 0 ? 5 : 4;
                var linkLen = start + cap[1].length + lastParenIndex;
                cap[2] = cap[2].substring(0, lastParenIndex);
                cap[0] = cap[0].substring(0, linkLen).trim();
                cap[3] = '';
              }
            }

            var href = cap[2];
            var title = '';

            if (this.options.pedantic) {
              // split pedantic href and title
              var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

              if (link) {
                href = link[1];
                title = link[3];
              }
            } else {
              title = cap[3] ? cap[3].slice(1, -1) : '';
            }

            href = href.trim();

            if (/^</.test(href)) {
              if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
                // pedantic allows starting angle bracket without ending angle bracket
                href = href.slice(1);
              } else {
                href = href.slice(1, -1);
              }
            }

            return outputLink(cap, {
              href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
              title: title ? title.replace(this.rules.inline._escapes, '$1') : title
            }, cap[0]);
          }
        };

        _proto.reflink = function reflink(src, links) {
          var cap;

          if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
            var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            link = links[link.toLowerCase()];

            if (!link || !link.href) {
              var text = cap[0].charAt(0);
              return {
                type: 'text',
                raw: text,
                text: text
              };
            }

            return outputLink(cap, link, cap[0]);
          }
        };

        _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
          if (prevChar === void 0) {
            prevChar = '';
          }

          var match = this.rules.inline.emStrong.lDelim.exec(src);
          if (!match) return; // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well

          if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return;
          var nextChar = match[1] || match[2] || '';

          if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {
            var lLength = match[0].length - 1;
            var rDelim,
                rLength,
                delimTotal = lLength,
                midDelimTotal = 0;
            var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
            endReg.lastIndex = 0; // Clip maskedSrc to same section of string as src (move to lexer?)

            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);

            while ((match = endReg.exec(maskedSrc)) != null) {
              rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
              if (!rDelim) continue; // skip single * in __abc*abc__

              rLength = rDelim.length;

              if (match[3] || match[4]) {
                // found another Left Delim
                delimTotal += rLength;
                continue;
              } else if (match[5] || match[6]) {
                // either Left or Right Delim
                if (lLength % 3 && !((lLength + rLength) % 3)) {
                  midDelimTotal += rLength;
                  continue; // CommonMark Emphasis Rules 9-10
                }
              }

              delimTotal -= rLength;
              if (delimTotal > 0) continue; // Haven't found enough closing delimiters
              // Remove extra characters. *a*** -> *a*

              rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal); // Create `em` if smallest delimiter has odd char count. *a***

              if (Math.min(lLength, rLength) % 2) {
                return {
                  type: 'em',
                  raw: src.slice(0, lLength + match.index + rLength + 1),
                  text: src.slice(1, lLength + match.index + rLength)
                };
              } // Create 'strong' if smallest delimiter has even char count. **a***


              return {
                type: 'strong',
                raw: src.slice(0, lLength + match.index + rLength + 1),
                text: src.slice(2, lLength + match.index + rLength - 1)
              };
            }
          }
        };

        _proto.codespan = function codespan(src) {
          var cap = this.rules.inline.code.exec(src);

          if (cap) {
            var text = cap[2].replace(/\n/g, ' ');
            var hasNonSpaceChars = /[^ ]/.test(text);
            var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);

            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
              text = text.substring(1, text.length - 1);
            }

            text = _escape(text, true);
            return {
              type: 'codespan',
              raw: cap[0],
              text: text
            };
          }
        };

        _proto.br = function br(src) {
          var cap = this.rules.inline.br.exec(src);

          if (cap) {
            return {
              type: 'br',
              raw: cap[0]
            };
          }
        };

        _proto.del = function del(src) {
          var cap = this.rules.inline.del.exec(src);

          if (cap) {
            return {
              type: 'del',
              raw: cap[0],
              text: cap[2]
            };
          }
        };

        _proto.autolink = function autolink(src, mangle) {
          var cap = this.rules.inline.autolink.exec(src);

          if (cap) {
            var text, href;

            if (cap[2] === '@') {
              text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
              href = 'mailto:' + text;
            } else {
              text = _escape(cap[1]);
              href = text;
            }

            return {
              type: 'link',
              raw: cap[0],
              text: text,
              href: href,
              tokens: [{
                type: 'text',
                raw: text,
                text: text
              }]
            };
          }
        };

        _proto.url = function url(src, mangle) {
          var cap;

          if (cap = this.rules.inline.url.exec(src)) {
            var text, href;

            if (cap[2] === '@') {
              text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
              href = 'mailto:' + text;
            } else {
              // do extended autolink path validation
              var prevCapZero;

              do {
                prevCapZero = cap[0];
                cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
              } while (prevCapZero !== cap[0]);

              text = _escape(cap[0]);

              if (cap[1] === 'www.') {
                href = 'http://' + text;
              } else {
                href = text;
              }
            }

            return {
              type: 'link',
              raw: cap[0],
              text: text,
              href: href,
              tokens: [{
                type: 'text',
                raw: text,
                text: text
              }]
            };
          }
        };

        _proto.inlineText = function inlineText(src, inRawBlock, smartypants) {
          var cap = this.rules.inline.text.exec(src);

          if (cap) {
            var text;

            if (inRawBlock) {
              text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];
            } else {
              text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
            }

            return {
              type: 'text',
              raw: cap[0],
              text: text
            };
          }
        };

        return Tokenizer;
      }();

      var noopTest = helpers.noopTest,
          edit = helpers.edit,
          merge$1 = helpers.merge;
      /**
       * Block-Level Grammar
       */

      var block$1 = {
        newline: /^(?: *(?:\n|$))+/,
        code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
        fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
        hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
        heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
        blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
        list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
        html: '^ {0,3}(?:' // optional indentation
        + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
        + '|comment[^\\n]*(\\n+|$)' // (2)
        + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
        + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
        + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
        + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
        + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
        + ')',
        def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
        nptable: noopTest,
        table: noopTest,
        lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
        // regex template, placeholders will be replaced according to different paragraph
        // interruption rules of commonmark and the original markdown spec:
        _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
        text: /^[^\n]+/
      };
      block$1._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
      block$1._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
      block$1.def = edit(block$1.def).replace('label', block$1._label).replace('title', block$1._title).getRegex();
      block$1.bullet = /(?:[*+-]|\d{1,9}[.)])/;
      block$1.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
      block$1.item = edit(block$1.item, 'gm').replace(/bull/g, block$1.bullet).getRegex();
      block$1.listItemStart = edit(/^( *)(bull) */).replace('bull', block$1.bullet).getRegex();
      block$1.list = edit(block$1.list).replace(/bull/g, block$1.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block$1.def.source + ')').getRegex();
      block$1._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
      block$1._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
      block$1.html = edit(block$1.html, 'i').replace('comment', block$1._comment).replace('tag', block$1._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
      block$1.paragraph = edit(block$1._paragraph).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
      .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // pars can be interrupted by type (6) html blocks
      .getRegex();
      block$1.blockquote = edit(block$1.blockquote).replace('paragraph', block$1.paragraph).getRegex();
      /**
       * Normal Block Grammar
       */

      block$1.normal = merge$1({}, block$1);
      /**
       * GFM Block Grammar
       */

      block$1.gfm = merge$1({}, block$1.normal, {
        nptable: '^ *([^|\\n ].*\\|.*)\\n' // Header
        + ' {0,3}([-:]+ *\\|[-| :]*)' // Align
        + '(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)',
        // Cells
        table: '^ *\\|(.+)\\n' // Header
        + ' {0,3}\\|?( *[-:]+[-| :]*)' // Align
        + '(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells

      });
      block$1.gfm.nptable = edit(block$1.gfm.nptable).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // tables can be interrupted by type (6) html blocks
      .getRegex();
      block$1.gfm.table = edit(block$1.gfm.table).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // tables can be interrupted by type (6) html blocks
      .getRegex();
      /**
       * Pedantic grammar (original John Gruber's loose markdown specification)
       */

      block$1.pedantic = merge$1({}, block$1.normal, {
        html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block$1._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
        heading: /^(#{1,6})(.*)(?:\n+|$)/,
        fences: noopTest,
        // fences not supported
        paragraph: edit(block$1.normal._paragraph).replace('hr', block$1.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block$1.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
      });
      /**
       * Inline-Level Grammar
       */

      var inline$1 = {
        escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
        autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
        url: noopTest,
        tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
        // CDATA section
        link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
        reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
        nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
        reflinkSearch: 'reflink|nolink(?!\\()',
        emStrong: {
          lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
          //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
          //        () Skip other delimiter (1) #***                   (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
          rDelimAst: /\_\_[^_*]*?\*[^_*]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
          rDelimUnd: /\*\*[^_*]*?\_[^_*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _

        },
        code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
        br: /^( {2,}|\\)\n(?!\s*$)/,
        del: noopTest,
        text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
        punctuation: /^([\spunctuation])/
      }; // list of punctuation marks from CommonMark spec
      // without * and _ to handle the different emphasis markers * and _

      inline$1._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
      inline$1.punctuation = edit(inline$1.punctuation).replace(/punctuation/g, inline$1._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>

      inline$1.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
      inline$1.escapedEmSt = /\\\*|\\_/g;
      inline$1._comment = edit(block$1._comment).replace('(?:-->|$)', '-->').getRegex();
      inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim).replace(/punct/g, inline$1._punctuation).getRegex();
      inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, 'g').replace(/punct/g, inline$1._punctuation).getRegex();
      inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, 'g').replace(/punct/g, inline$1._punctuation).getRegex();
      inline$1._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
      inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
      inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
      inline$1.autolink = edit(inline$1.autolink).replace('scheme', inline$1._scheme).replace('email', inline$1._email).getRegex();
      inline$1._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
      inline$1.tag = edit(inline$1.tag).replace('comment', inline$1._comment).replace('attribute', inline$1._attribute).getRegex();
      inline$1._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
      inline$1._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
      inline$1._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
      inline$1.link = edit(inline$1.link).replace('label', inline$1._label).replace('href', inline$1._href).replace('title', inline$1._title).getRegex();
      inline$1.reflink = edit(inline$1.reflink).replace('label', inline$1._label).getRegex();
      inline$1.reflinkSearch = edit(inline$1.reflinkSearch, 'g').replace('reflink', inline$1.reflink).replace('nolink', inline$1.nolink).getRegex();
      /**
       * Normal Inline Grammar
       */

      inline$1.normal = merge$1({}, inline$1);
      /**
       * Pedantic Inline Grammar
       */

      inline$1.pedantic = merge$1({}, inline$1.normal, {
        strong: {
          start: /^__|\*\*/,
          middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
          endAst: /\*\*(?!\*)/g,
          endUnd: /__(?!_)/g
        },
        em: {
          start: /^_|\*/,
          middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
          endAst: /\*(?!\*)/g,
          endUnd: /_(?!_)/g
        },
        link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', inline$1._label).getRegex(),
        reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline$1._label).getRegex()
      });
      /**
       * GFM Inline Grammar
       */

      inline$1.gfm = merge$1({}, inline$1.normal, {
        escape: edit(inline$1.escape).replace('])', '~|])').getRegex(),
        _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
        url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
        _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
        del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
        text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
      });
      inline$1.gfm.url = edit(inline$1.gfm.url, 'i').replace('email', inline$1.gfm._extended_email).getRegex();
      /**
       * GFM + Line Breaks Inline Grammar
       */

      inline$1.breaks = merge$1({}, inline$1.gfm, {
        br: edit(inline$1.br).replace('{2,}', '*').getRegex(),
        text: edit(inline$1.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
      });
      var rules = {
        block: block$1,
        inline: inline$1
      };

      var Tokenizer$1 = Tokenizer_1;
      var defaults$3 = defaults$5.exports.defaults;
      var block = rules.block,
          inline = rules.inline;
      var repeatString = helpers.repeatString;
      /**
       * smartypants text replacement
       */

      function smartypants(text) {
        return text // em-dashes
        .replace(/---/g, "\u2014") // en-dashes
        .replace(/--/g, "\u2013") // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018") // closing singles & apostrophes
        .replace(/'/g, "\u2019") // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C") // closing doubles
        .replace(/"/g, "\u201D") // ellipses
        .replace(/\.{3}/g, "\u2026");
      }
      /**
       * mangle email addresses
       */


      function mangle(text) {
        var out = '',
            i,
            ch;
        var l = text.length;

        for (i = 0; i < l; i++) {
          ch = text.charCodeAt(i);

          if (Math.random() > 0.5) {
            ch = 'x' + ch.toString(16);
          }

          out += '&#' + ch + ';';
        }

        return out;
      }
      /**
       * Block Lexer
       */


      var Lexer_1 = /*#__PURE__*/function () {
        function Lexer(options) {
          this.tokens = [];
          this.tokens.links = Object.create(null);
          this.options = options || defaults$3;
          this.options.tokenizer = this.options.tokenizer || new Tokenizer$1();
          this.tokenizer = this.options.tokenizer;
          this.tokenizer.options = this.options;
          var rules = {
            block: block.normal,
            inline: inline.normal
          };

          if (this.options.pedantic) {
            rules.block = block.pedantic;
            rules.inline = inline.pedantic;
          } else if (this.options.gfm) {
            rules.block = block.gfm;

            if (this.options.breaks) {
              rules.inline = inline.breaks;
            } else {
              rules.inline = inline.gfm;
            }
          }

          this.tokenizer.rules = rules;
        }
        /**
         * Expose Rules
         */


        /**
         * Static Lex Method
         */
        Lexer.lex = function lex(src, options) {
          var lexer = new Lexer(options);
          return lexer.lex(src);
        }
        /**
         * Static Lex Inline Method
         */
        ;

        Lexer.lexInline = function lexInline(src, options) {
          var lexer = new Lexer(options);
          return lexer.inlineTokens(src);
        }
        /**
         * Preprocessing
         */
        ;

        var _proto = Lexer.prototype;

        _proto.lex = function lex(src) {
          src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ');
          this.blockTokens(src, this.tokens, true);
          this.inline(this.tokens);
          return this.tokens;
        }
        /**
         * Lexing
         */
        ;

        _proto.blockTokens = function blockTokens(src, tokens, top) {
          var _this = this;

          if (tokens === void 0) {
            tokens = [];
          }

          if (top === void 0) {
            top = true;
          }

          if (this.options.pedantic) {
            src = src.replace(/^ +$/gm, '');
          }

          var token, i, l, lastToken, cutSrc, lastParagraphClipped;

          while (src) {
            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {
              if (token = extTokenizer.call(_this, src, tokens)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                return true;
              }

              return false;
            })) {
              continue;
            } // newline


            if (token = this.tokenizer.space(src)) {
              src = src.substring(token.raw.length);

              if (token.type) {
                tokens.push(token);
              }

              continue;
            } // code


            if (token = this.tokenizer.code(src)) {
              src = src.substring(token.raw.length);
              lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.

              if (lastToken && lastToken.type === 'paragraph') {
                lastToken.raw += '\n' + token.raw;
                lastToken.text += '\n' + token.text;
              } else {
                tokens.push(token);
              }

              continue;
            } // fences


            if (token = this.tokenizer.fences(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // heading


            if (token = this.tokenizer.heading(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // table no leading pipe (gfm)


            if (token = this.tokenizer.nptable(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // hr


            if (token = this.tokenizer.hr(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // blockquote


            if (token = this.tokenizer.blockquote(src)) {
              src = src.substring(token.raw.length);
              token.tokens = this.blockTokens(token.text, [], top);
              tokens.push(token);
              continue;
            } // list


            if (token = this.tokenizer.list(src)) {
              src = src.substring(token.raw.length);
              l = token.items.length;

              for (i = 0; i < l; i++) {
                token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
              }

              tokens.push(token);
              continue;
            } // html


            if (token = this.tokenizer.html(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // def


            if (top && (token = this.tokenizer.def(src))) {
              src = src.substring(token.raw.length);

              if (!this.tokens.links[token.tag]) {
                this.tokens.links[token.tag] = {
                  href: token.href,
                  title: token.title
                };
              }

              continue;
            } // table (gfm)


            if (token = this.tokenizer.table(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // lheading


            if (token = this.tokenizer.lheading(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // top-level paragraph
            // prevent paragraph consuming extensions by clipping 'src' to extension start


            cutSrc = src;

            if (this.options.extensions && this.options.extensions.startBlock) {
              (function () {
                var startIndex = Infinity;
                var tempSrc = src.slice(1);
                var tempStart = void 0;

                _this.options.extensions.startBlock.forEach(function (getStartIndex) {
                  tempStart = getStartIndex.call(this, tempSrc);

                  if (typeof tempStart === 'number' && tempStart >= 0) {
                    startIndex = Math.min(startIndex, tempStart);
                  }
                });

                if (startIndex < Infinity && startIndex >= 0) {
                  cutSrc = src.substring(0, startIndex + 1);
                }
              })();
            }

            if (top && (token = this.tokenizer.paragraph(cutSrc))) {
              lastToken = tokens[tokens.length - 1];

              if (lastParagraphClipped && lastToken.type === 'paragraph') {
                lastToken.raw += '\n' + token.raw;
                lastToken.text += '\n' + token.text;
              } else {
                tokens.push(token);
              }

              lastParagraphClipped = cutSrc.length !== src.length;
              src = src.substring(token.raw.length);
              continue;
            } // text


            if (token = this.tokenizer.text(src)) {
              src = src.substring(token.raw.length);
              lastToken = tokens[tokens.length - 1];

              if (lastToken && lastToken.type === 'text') {
                lastToken.raw += '\n' + token.raw;
                lastToken.text += '\n' + token.text;
              } else {
                tokens.push(token);
              }

              continue;
            }

            if (src) {
              var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

              if (this.options.silent) {
                console.error(errMsg);
                break;
              } else {
                throw new Error(errMsg);
              }
            }
          }

          return tokens;
        };

        _proto.inline = function inline(tokens) {
          var i, j, k, l2, row, token;
          var l = tokens.length;

          for (i = 0; i < l; i++) {
            token = tokens[i];

            switch (token.type) {
              case 'paragraph':
              case 'text':
              case 'heading':
                {
                  token.tokens = [];
                  this.inlineTokens(token.text, token.tokens);
                  break;
                }

              case 'table':
                {
                  token.tokens = {
                    header: [],
                    cells: []
                  }; // header

                  l2 = token.header.length;

                  for (j = 0; j < l2; j++) {
                    token.tokens.header[j] = [];
                    this.inlineTokens(token.header[j], token.tokens.header[j]);
                  } // cells


                  l2 = token.cells.length;

                  for (j = 0; j < l2; j++) {
                    row = token.cells[j];
                    token.tokens.cells[j] = [];

                    for (k = 0; k < row.length; k++) {
                      token.tokens.cells[j][k] = [];
                      this.inlineTokens(row[k], token.tokens.cells[j][k]);
                    }
                  }

                  break;
                }

              case 'blockquote':
                {
                  this.inline(token.tokens);
                  break;
                }

              case 'list':
                {
                  l2 = token.items.length;

                  for (j = 0; j < l2; j++) {
                    this.inline(token.items[j].tokens);
                  }

                  break;
                }
            }
          }

          return tokens;
        }
        /**
         * Lexing/Compiling
         */
        ;

        _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock) {
          var _this2 = this;

          if (tokens === void 0) {
            tokens = [];
          }

          if (inLink === void 0) {
            inLink = false;
          }

          if (inRawBlock === void 0) {
            inRawBlock = false;
          }

          var token, lastToken, cutSrc; // String with links masked to avoid interference with em and strong

          var maskedSrc = src;
          var match;
          var keepPrevChar, prevChar; // Mask out reflinks

          if (this.tokens.links) {
            var links = Object.keys(this.tokens.links);

            if (links.length > 0) {
              while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                  maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                }
              }
            }
          } // Mask out other blocks


          while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
          } // Mask out escaped em & strong delimiters


          while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
          }

          while (src) {
            if (!keepPrevChar) {
              prevChar = '';
            }

            keepPrevChar = false; // extensions

            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {
              if (token = extTokenizer.call(_this2, src, tokens)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                return true;
              }

              return false;
            })) {
              continue;
            } // escape


            if (token = this.tokenizer.escape(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // tag


            if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
              src = src.substring(token.raw.length);
              inLink = token.inLink;
              inRawBlock = token.inRawBlock;
              lastToken = tokens[tokens.length - 1];

              if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                lastToken.raw += token.raw;
                lastToken.text += token.text;
              } else {
                tokens.push(token);
              }

              continue;
            } // link


            if (token = this.tokenizer.link(src)) {
              src = src.substring(token.raw.length);

              if (token.type === 'link') {
                token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
              }

              tokens.push(token);
              continue;
            } // reflink, nolink


            if (token = this.tokenizer.reflink(src, this.tokens.links)) {
              src = src.substring(token.raw.length);
              lastToken = tokens[tokens.length - 1];

              if (token.type === 'link') {
                token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
                tokens.push(token);
              } else if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                lastToken.raw += token.raw;
                lastToken.text += token.text;
              } else {
                tokens.push(token);
              }

              continue;
            } // em & strong


            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
              src = src.substring(token.raw.length);
              token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
              tokens.push(token);
              continue;
            } // code


            if (token = this.tokenizer.codespan(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // br


            if (token = this.tokenizer.br(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // del (gfm)


            if (token = this.tokenizer.del(src)) {
              src = src.substring(token.raw.length);
              token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
              tokens.push(token);
              continue;
            } // autolink


            if (token = this.tokenizer.autolink(src, mangle)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // url (gfm)


            if (!inLink && (token = this.tokenizer.url(src, mangle))) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // text
            // prevent inlineText consuming extensions by clipping 'src' to extension start


            cutSrc = src;

            if (this.options.extensions && this.options.extensions.startInline) {
              (function () {
                var startIndex = Infinity;
                var tempSrc = src.slice(1);
                var tempStart = void 0;

                _this2.options.extensions.startInline.forEach(function (getStartIndex) {
                  tempStart = getStartIndex.call(this, tempSrc);

                  if (typeof tempStart === 'number' && tempStart >= 0) {
                    startIndex = Math.min(startIndex, tempStart);
                  }
                });

                if (startIndex < Infinity && startIndex >= 0) {
                  cutSrc = src.substring(0, startIndex + 1);
                }
              })();
            }

            if (token = this.tokenizer.inlineText(cutSrc, inRawBlock, smartypants)) {
              src = src.substring(token.raw.length);

              if (token.raw.slice(-1) !== '_') {
                // Track prevChar before string of ____ started
                prevChar = token.raw.slice(-1);
              }

              keepPrevChar = true;
              lastToken = tokens[tokens.length - 1];

              if (lastToken && lastToken.type === 'text') {
                lastToken.raw += token.raw;
                lastToken.text += token.text;
              } else {
                tokens.push(token);
              }

              continue;
            }

            if (src) {
              var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

              if (this.options.silent) {
                console.error(errMsg);
                break;
              } else {
                throw new Error(errMsg);
              }
            }
          }

          return tokens;
        };

        _createClass(Lexer, null, [{
          key: "rules",
          get: function get() {
            return {
              block: block,
              inline: inline
            };
          }
        }]);

        return Lexer;
      }();

      var defaults$2 = defaults$5.exports.defaults;
      var cleanUrl = helpers.cleanUrl,
          escape$1 = helpers.escape;
      /**
       * Renderer
       */

      var Renderer_1 = /*#__PURE__*/function () {
        function Renderer(options) {
          this.options = options || defaults$2;
        }

        var _proto = Renderer.prototype;

        _proto.code = function code(_code, infostring, escaped) {
          var lang = (infostring || '').match(/\S*/)[0];

          if (this.options.highlight) {
            var out = this.options.highlight(_code, lang);

            if (out != null && out !== _code) {
              escaped = true;
              _code = out;
            }
          }

          _code = _code.replace(/\n$/, '') + '\n';

          if (!lang) {
            return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
          }

          return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
        };

        _proto.blockquote = function blockquote(quote) {
          return '<blockquote>\n' + quote + '</blockquote>\n';
        };

        _proto.html = function html(_html) {
          return _html;
        };

        _proto.heading = function heading(text, level, raw, slugger) {
          if (this.options.headerIds) {
            return '<h' + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + '</h' + level + '>\n';
          } // ignore IDs


          return '<h' + level + '>' + text + '</h' + level + '>\n';
        };

        _proto.hr = function hr() {
          return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
        };

        _proto.list = function list(body, ordered, start) {
          var type = ordered ? 'ol' : 'ul',
              startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
          return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
        };

        _proto.listitem = function listitem(text) {
          return '<li>' + text + '</li>\n';
        };

        _proto.checkbox = function checkbox(checked) {
          return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
        };

        _proto.paragraph = function paragraph(text) {
          return '<p>' + text + '</p>\n';
        };

        _proto.table = function table(header, body) {
          if (body) body = '<tbody>' + body + '</tbody>';
          return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
        };

        _proto.tablerow = function tablerow(content) {
          return '<tr>\n' + content + '</tr>\n';
        };

        _proto.tablecell = function tablecell(content, flags) {
          var type = flags.header ? 'th' : 'td';
          var tag = flags.align ? '<' + type + ' align="' + flags.align + '">' : '<' + type + '>';
          return tag + content + '</' + type + '>\n';
        } // span level renderer
        ;

        _proto.strong = function strong(text) {
          return '<strong>' + text + '</strong>';
        };

        _proto.em = function em(text) {
          return '<em>' + text + '</em>';
        };

        _proto.codespan = function codespan(text) {
          return '<code>' + text + '</code>';
        };

        _proto.br = function br() {
          return this.options.xhtml ? '<br/>' : '<br>';
        };

        _proto.del = function del(text) {
          return '<del>' + text + '</del>';
        };

        _proto.link = function link(href, title, text) {
          href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

          if (href === null) {
            return text;
          }

          var out = '<a href="' + escape$1(href) + '"';

          if (title) {
            out += ' title="' + title + '"';
          }

          out += '>' + text + '</a>';
          return out;
        };

        _proto.image = function image(href, title, text) {
          href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

          if (href === null) {
            return text;
          }

          var out = '<img src="' + href + '" alt="' + text + '"';

          if (title) {
            out += ' title="' + title + '"';
          }

          out += this.options.xhtml ? '/>' : '>';
          return out;
        };

        _proto.text = function text(_text) {
          return _text;
        };

        return Renderer;
      }();

      /**
       * TextRenderer
       * returns only the textual part of the token
       */

      var TextRenderer_1 = /*#__PURE__*/function () {
        function TextRenderer() {}

        var _proto = TextRenderer.prototype;

        // no need for block level renderers
        _proto.strong = function strong(text) {
          return text;
        };

        _proto.em = function em(text) {
          return text;
        };

        _proto.codespan = function codespan(text) {
          return text;
        };

        _proto.del = function del(text) {
          return text;
        };

        _proto.html = function html(text) {
          return text;
        };

        _proto.text = function text(_text) {
          return _text;
        };

        _proto.link = function link(href, title, text) {
          return '' + text;
        };

        _proto.image = function image(href, title, text) {
          return '' + text;
        };

        _proto.br = function br() {
          return '';
        };

        return TextRenderer;
      }();

      /**
       * Slugger generates header id
       */

      var Slugger_1 = /*#__PURE__*/function () {
        function Slugger() {
          this.seen = {};
        }

        var _proto = Slugger.prototype;

        _proto.serialize = function serialize(value) {
          return value.toLowerCase().trim() // remove html tags
          .replace(/<[!\/a-z].*?>/ig, '') // remove unwanted chars
          .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
        }
        /**
         * Finds the next safe (unique) slug to use
         */
        ;

        _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
          var slug = originalSlug;
          var occurenceAccumulator = 0;

          if (this.seen.hasOwnProperty(slug)) {
            occurenceAccumulator = this.seen[originalSlug];

            do {
              occurenceAccumulator++;
              slug = originalSlug + '-' + occurenceAccumulator;
            } while (this.seen.hasOwnProperty(slug));
          }

          if (!isDryRun) {
            this.seen[originalSlug] = occurenceAccumulator;
            this.seen[slug] = 0;
          }

          return slug;
        }
        /**
         * Convert string to unique id
         * @param {object} options
         * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
         */
        ;

        _proto.slug = function slug(value, options) {
          if (options === void 0) {
            options = {};
          }

          var slug = this.serialize(value);
          return this.getNextSafeSlug(slug, options.dryrun);
        };

        return Slugger;
      }();

      var Renderer$1 = Renderer_1;
      var TextRenderer$1 = TextRenderer_1;
      var Slugger$1 = Slugger_1;
      var defaults$1 = defaults$5.exports.defaults;
      var unescape = helpers.unescape;
      /**
       * Parsing & Compiling
       */

      var Parser_1 = /*#__PURE__*/function () {
        function Parser(options) {
          this.options = options || defaults$1;
          this.options.renderer = this.options.renderer || new Renderer$1();
          this.renderer = this.options.renderer;
          this.renderer.options = this.options;
          this.textRenderer = new TextRenderer$1();
          this.slugger = new Slugger$1();
        }
        /**
         * Static Parse Method
         */


        Parser.parse = function parse(tokens, options) {
          var parser = new Parser(options);
          return parser.parse(tokens);
        }
        /**
         * Static Parse Inline Method
         */
        ;

        Parser.parseInline = function parseInline(tokens, options) {
          var parser = new Parser(options);
          return parser.parseInline(tokens);
        }
        /**
         * Parse Loop
         */
        ;

        var _proto = Parser.prototype;

        _proto.parse = function parse(tokens, top) {
          if (top === void 0) {
            top = true;
          }

          var out = '',
              i,
              j,
              k,
              l2,
              l3,
              row,
              cell,
              header,
              body,
              token,
              ordered,
              start,
              loose,
              itemBody,
              item,
              checked,
              task,
              checkbox,
              ret;
          var l = tokens.length;

          for (i = 0; i < l; i++) {
            token = tokens[i]; // Run any renderer extensions

            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
              ret = this.options.extensions.renderers[token.type].call(this, token);

              if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
                out += ret || '';
                continue;
              }
            }

            switch (token.type) {
              case 'space':
                {
                  continue;
                }

              case 'hr':
                {
                  out += this.renderer.hr();
                  continue;
                }

              case 'heading':
                {
                  out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
                  continue;
                }

              case 'code':
                {
                  out += this.renderer.code(token.text, token.lang, token.escaped);
                  continue;
                }

              case 'table':
                {
                  header = ''; // header

                  cell = '';
                  l2 = token.header.length;

                  for (j = 0; j < l2; j++) {
                    cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {
                      header: true,
                      align: token.align[j]
                    });
                  }

                  header += this.renderer.tablerow(cell);
                  body = '';
                  l2 = token.cells.length;

                  for (j = 0; j < l2; j++) {
                    row = token.tokens.cells[j];
                    cell = '';
                    l3 = row.length;

                    for (k = 0; k < l3; k++) {
                      cell += this.renderer.tablecell(this.parseInline(row[k]), {
                        header: false,
                        align: token.align[k]
                      });
                    }

                    body += this.renderer.tablerow(cell);
                  }

                  out += this.renderer.table(header, body);
                  continue;
                }

              case 'blockquote':
                {
                  body = this.parse(token.tokens);
                  out += this.renderer.blockquote(body);
                  continue;
                }

              case 'list':
                {
                  ordered = token.ordered;
                  start = token.start;
                  loose = token.loose;
                  l2 = token.items.length;
                  body = '';

                  for (j = 0; j < l2; j++) {
                    item = token.items[j];
                    checked = item.checked;
                    task = item.task;
                    itemBody = '';

                    if (item.task) {
                      checkbox = this.renderer.checkbox(checked);

                      if (loose) {
                        if (item.tokens.length > 0 && item.tokens[0].type === 'text') {
                          item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;

                          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                            item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                          }
                        } else {
                          item.tokens.unshift({
                            type: 'text',
                            text: checkbox
                          });
                        }
                      } else {
                        itemBody += checkbox;
                      }
                    }

                    itemBody += this.parse(item.tokens, loose);
                    body += this.renderer.listitem(itemBody, task, checked);
                  }

                  out += this.renderer.list(body, ordered, start);
                  continue;
                }

              case 'html':
                {
                  // TODO parse inline content if parameter markdown=1
                  out += this.renderer.html(token.text);
                  continue;
                }

              case 'paragraph':
                {
                  out += this.renderer.paragraph(this.parseInline(token.tokens));
                  continue;
                }

              case 'text':
                {
                  body = token.tokens ? this.parseInline(token.tokens) : token.text;

                  while (i + 1 < l && tokens[i + 1].type === 'text') {
                    token = tokens[++i];
                    body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
                  }

                  out += top ? this.renderer.paragraph(body) : body;
                  continue;
                }

              default:
                {
                  var errMsg = 'Token with "' + token.type + '" type was not found.';

                  if (this.options.silent) {
                    console.error(errMsg);
                    return;
                  } else {
                    throw new Error(errMsg);
                  }
                }
            }
          }

          return out;
        }
        /**
         * Parse Inline Tokens
         */
        ;

        _proto.parseInline = function parseInline(tokens, renderer) {
          renderer = renderer || this.renderer;
          var out = '',
              i,
              token,
              ret;
          var l = tokens.length;

          for (i = 0; i < l; i++) {
            token = tokens[i]; // Run any renderer extensions

            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
              ret = this.options.extensions.renderers[token.type].call(this, token);

              if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
                out += ret || '';
                continue;
              }
            }

            switch (token.type) {
              case 'escape':
                {
                  out += renderer.text(token.text);
                  break;
                }

              case 'html':
                {
                  out += renderer.html(token.text);
                  break;
                }

              case 'link':
                {
                  out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
                  break;
                }

              case 'image':
                {
                  out += renderer.image(token.href, token.title, token.text);
                  break;
                }

              case 'strong':
                {
                  out += renderer.strong(this.parseInline(token.tokens, renderer));
                  break;
                }

              case 'em':
                {
                  out += renderer.em(this.parseInline(token.tokens, renderer));
                  break;
                }

              case 'codespan':
                {
                  out += renderer.codespan(token.text);
                  break;
                }

              case 'br':
                {
                  out += renderer.br();
                  break;
                }

              case 'del':
                {
                  out += renderer.del(this.parseInline(token.tokens, renderer));
                  break;
                }

              case 'text':
                {
                  out += renderer.text(token.text);
                  break;
                }

              default:
                {
                  var errMsg = 'Token with "' + token.type + '" type was not found.';

                  if (this.options.silent) {
                    console.error(errMsg);
                    return;
                  } else {
                    throw new Error(errMsg);
                  }
                }
            }
          }

          return out;
        };

        return Parser;
      }();

      var Lexer = Lexer_1;
      var Parser = Parser_1;
      var Tokenizer = Tokenizer_1;
      var Renderer = Renderer_1;
      var TextRenderer = TextRenderer_1;
      var Slugger = Slugger_1;
      var merge = helpers.merge,
          checkSanitizeDeprecation = helpers.checkSanitizeDeprecation,
          escape = helpers.escape;
      var getDefaults = defaults$5.exports.getDefaults,
          changeDefaults = defaults$5.exports.changeDefaults,
          defaults = defaults$5.exports.defaults;
      /**
       * Marked
       */

      function marked(src, opt, callback) {
        // throw error in case of non string input
        if (typeof src === 'undefined' || src === null) {
          throw new Error('marked(): input parameter is undefined or null');
        }

        if (typeof src !== 'string') {
          throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
        }

        if (typeof opt === 'function') {
          callback = opt;
          opt = null;
        }

        opt = merge({}, marked.defaults, opt || {});
        checkSanitizeDeprecation(opt);

        if (callback) {
          var highlight = opt.highlight;
          var tokens;

          try {
            tokens = Lexer.lex(src, opt);
          } catch (e) {
            return callback(e);
          }

          var done = function done(err) {
            var out;

            if (!err) {
              try {
                if (opt.walkTokens) {
                  marked.walkTokens(tokens, opt.walkTokens);
                }

                out = Parser.parse(tokens, opt);
              } catch (e) {
                err = e;
              }
            }

            opt.highlight = highlight;
            return err ? callback(err) : callback(null, out);
          };

          if (!highlight || highlight.length < 3) {
            return done();
          }

          delete opt.highlight;
          if (!tokens.length) return done();
          var pending = 0;
          marked.walkTokens(tokens, function (token) {
            if (token.type === 'code') {
              pending++;
              setTimeout(function () {
                highlight(token.text, token.lang, function (err, code) {
                  if (err) {
                    return done(err);
                  }

                  if (code != null && code !== token.text) {
                    token.text = code;
                    token.escaped = true;
                  }

                  pending--;

                  if (pending === 0) {
                    done();
                  }
                });
              }, 0);
            }
          });

          if (pending === 0) {
            done();
          }

          return;
        }

        try {
          var _tokens = Lexer.lex(src, opt);

          if (opt.walkTokens) {
            marked.walkTokens(_tokens, opt.walkTokens);
          }

          return Parser.parse(_tokens, opt);
        } catch (e) {
          e.message += '\nPlease report this to https://github.com/markedjs/marked.';

          if (opt.silent) {
            return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
          }

          throw e;
        }
      }
      /**
       * Options
       */


      marked.options = marked.setOptions = function (opt) {
        merge(marked.defaults, opt);
        changeDefaults(marked.defaults);
        return marked;
      };

      marked.getDefaults = getDefaults;
      marked.defaults = defaults;
      /**
       * Use Extension
       */

      marked.use = function () {
        var _this = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var opts = merge.apply(void 0, [{}].concat(args));
        var extensions = marked.defaults.extensions || {
          renderers: {},
          childTokens: {}
        };
        var hasExtensions;
        args.forEach(function (pack) {
          // ==-- Parse "addon" extensions --== //
          if (pack.extensions) {
            hasExtensions = true;
            pack.extensions.forEach(function (ext) {
              if (!ext.name) {
                throw new Error('extension name required');
              }

              if (ext.renderer) {
                // Renderer extensions
                var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;

                if (prevRenderer) {
                  // Replace extension with func to run new extension but fall back if false
                  extensions.renderers[ext.name] = function () {
                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                      args[_key2] = arguments[_key2];
                    }

                    var ret = ext.renderer.apply(this, args);

                    if (ret === false) {
                      ret = prevRenderer.apply(this, args);
                    }

                    return ret;
                  };
                } else {
                  extensions.renderers[ext.name] = ext.renderer;
                }
              }

              if (ext.tokenizer) {
                // Tokenizer Extensions
                if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {
                  throw new Error("extension level must be 'block' or 'inline'");
                }

                if (extensions[ext.level]) {
                  extensions[ext.level].unshift(ext.tokenizer);
                } else {
                  extensions[ext.level] = [ext.tokenizer];
                }

                if (ext.start) {
                  // Function to check for start of token
                  if (ext.level === 'block') {
                    if (extensions.startBlock) {
                      extensions.startBlock.push(ext.start);
                    } else {
                      extensions.startBlock = [ext.start];
                    }
                  } else if (ext.level === 'inline') {
                    if (extensions.startInline) {
                      extensions.startInline.push(ext.start);
                    } else {
                      extensions.startInline = [ext.start];
                    }
                  }
                }
              }

              if (ext.childTokens) {
                // Child tokens to be visited by walkTokens
                extensions.childTokens[ext.name] = ext.childTokens;
              }
            });
          } // ==-- Parse "overwrite" extensions --== //


          if (pack.renderer) {
            (function () {
              var renderer = marked.defaults.renderer || new Renderer();

              var _loop = function _loop(prop) {
                var prevRenderer = renderer[prop]; // Replace renderer with func to run extension, but fall back if false

                renderer[prop] = function () {
                  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                    args[_key3] = arguments[_key3];
                  }

                  var ret = pack.renderer[prop].apply(renderer, args);

                  if (ret === false) {
                    ret = prevRenderer.apply(renderer, args);
                  }

                  return ret;
                };
              };

              for (var prop in pack.renderer) {
                _loop(prop);
              }

              opts.renderer = renderer;
            })();
          }

          if (pack.tokenizer) {
            (function () {
              var tokenizer = marked.defaults.tokenizer || new Tokenizer();

              var _loop2 = function _loop2(prop) {
                var prevTokenizer = tokenizer[prop]; // Replace tokenizer with func to run extension, but fall back if false

                tokenizer[prop] = function () {
                  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                    args[_key4] = arguments[_key4];
                  }

                  var ret = pack.tokenizer[prop].apply(tokenizer, args);

                  if (ret === false) {
                    ret = prevTokenizer.apply(tokenizer, args);
                  }

                  return ret;
                };
              };

              for (var prop in pack.tokenizer) {
                _loop2(prop);
              }

              opts.tokenizer = tokenizer;
            })();
          } // ==-- Parse WalkTokens extensions --== //


          if (pack.walkTokens) {
            var walkTokens = marked.defaults.walkTokens;

            opts.walkTokens = function (token) {
              pack.walkTokens.call(_this, token);

              if (walkTokens) {
                walkTokens(token);
              }
            };
          }

          if (hasExtensions) {
            opts.extensions = extensions;
          }

          marked.setOptions(opts);
        });
      };
      /**
       * Run callback for every token
       */


      marked.walkTokens = function (tokens, callback) {
        var _loop3 = function _loop3() {
          var token = _step.value;
          callback(token);

          switch (token.type) {
            case 'table':
              {
                for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done;) {
                  var cell = _step2.value;
                  marked.walkTokens(cell, callback);
                }

                for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done;) {
                  var row = _step3.value;

                  for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
                    var _cell = _step4.value;
                    marked.walkTokens(_cell, callback);
                  }
                }

                break;
              }

            case 'list':
              {
                marked.walkTokens(token.items, callback);
                break;
              }

            default:
              {
                if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
                  // Walk any extensions
                  marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {
                    marked.walkTokens(token[childTokens], callback);
                  });
                } else if (token.tokens) {
                  marked.walkTokens(token.tokens, callback);
                }
              }
          }
        };

        for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {
          _loop3();
        }
      };
      /**
       * Parse Inline
       */


      marked.parseInline = function (src, opt) {
        // throw error in case of non string input
        if (typeof src === 'undefined' || src === null) {
          throw new Error('marked.parseInline(): input parameter is undefined or null');
        }

        if (typeof src !== 'string') {
          throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
        }

        opt = merge({}, marked.defaults, opt || {});
        checkSanitizeDeprecation(opt);

        try {
          var tokens = Lexer.lexInline(src, opt);

          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }

          return Parser.parseInline(tokens, opt);
        } catch (e) {
          e.message += '\nPlease report this to https://github.com/markedjs/marked.';

          if (opt.silent) {
            return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
          }

          throw e;
        }
      };
      /**
       * Expose
       */


      marked.Parser = Parser;
      marked.parser = Parser.parse;
      marked.Renderer = Renderer;
      marked.TextRenderer = TextRenderer;
      marked.Lexer = Lexer;
      marked.lexer = Lexer.lex;
      marked.Tokenizer = Tokenizer;
      marked.Slugger = Slugger;
      marked.parse = marked;
      var marked_1 = marked;

      return marked_1;

    })));
    });

    /* src/Create/BatchNotes.svelte generated by Svelte v3.40.3 */

    const { console: console_1$4 } = globals;
    const file$i = "src/Create/BatchNotes.svelte";

    // (51:8) {:else}
    function create_else_block$4(ctx) {
    	let h7;
    	let raw_value = marked(/*$batch_notes*/ ctx[1]) + "";

    	const block = {
    		c: function create() {
    			h7 = element("h7");
    			add_location(h7, file$i, 51, 12, 1470);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h7, anchor);
    			h7.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$batch_notes*/ 2 && raw_value !== (raw_value = marked(/*$batch_notes*/ ctx[1]) + "")) h7.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(51:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (48:8) {#if $batch_notes === ""}
    function create_if_block$d(ctx) {
    	let h7;

    	const block = {
    		c: function create() {
    			h7 = element("h7");
    			h7.textContent = "Type batch specific notes here";
    			add_location(h7, file$i, 48, 12, 1394);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h7, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(48:8) {#if $batch_notes === \\\"\\\"}",
    		ctx
    	});

    	return block;
    }

    // (59:4) <Label>
    function create_default_slot_3$6(ctx) {
    	let h3;
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text("Batch Notes (Batch No.");
    			t1 = text(/*$batch_number*/ ctx[2]);
    			t2 = text(")");
    			add_location(h3, file$i, 58, 11, 1599);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			append_dev(h3, t1);
    			append_dev(h3, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$batch_number*/ 4) set_data_dev(t1, /*$batch_number*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(59:4) <Label>",
    		ctx
    	});

    	return block;
    }

    // (58:0) <Dialog  bind:value={showDialog}>
    function create_default_slot_2$d(ctx) {
    	let label;
    	let t;
    	let div;
    	let textarea;
    	let current;
    	let mounted;
    	let dispose;

    	label = new Label$2({
    			props: {
    				$$slots: { default: [create_default_slot_3$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    			t = space();
    			div = element("div");
    			textarea = element("textarea");
    			attr_dev(textarea, "placeholder", "Type batch specific notes here");
    			attr_dev(textarea, "rows", "14");
    			attr_dev(textarea, "cols", "80 ");
    			add_location(textarea, file$i, 59, 31, 1687);
    			attr_dev(div, "class", "text-gray-700");
    			add_location(div, file$i, 59, 4, 1660);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, textarea);
    			set_input_value(textarea, /*$batch_notes*/ ctx[1]);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[8]),
    					listen_dev(textarea, "change", /*add_batch_notes*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty & /*$$scope, $batch_number*/ 4100) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);

    			if (dirty & /*$batch_notes*/ 2) {
    				set_input_value(textarea, /*$batch_notes*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$d.name,
    		type: "slot",
    		source: "(58:0) <Dialog  bind:value={showDialog}>",
    		ctx
    	});

    	return block;
    }

    // (62:8) <Button color="blue" text on:click={() => showDialog = false}>
    function create_default_slot_1$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(62:8) <Button color=\\\"blue\\\" text on:click={() => showDialog = false}>",
    		ctx
    	});

    	return block;
    }

    // (63:8) <Button color="blue" text on:click={() => showDialog = false}>
    function create_default_slot$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(63:8) <Button color=\\\"blue\\\" text on:click={() => showDialog = false}>",
    		ctx
    	});

    	return block;
    }

    // (61:4) 
    function create_actions_slot$4(ctx) {
    	let div;
    	let button0;
    	let t;
    	let button1;
    	let current;

    	button0 = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler_2*/ ctx[6]);

    	button1 = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_3*/ ctx[7]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    			attr_dev(div, "slot", "actions");
    			add_location(div, file$i, 60, 4, 1840);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button0, div, null);
    			append_dev(div, t);
    			mount_component(button1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_actions_slot$4.name,
    		type: "slot",
    		source: "(61:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div2;
    	let div0;
    	let h5;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let dialog;
    	let updating_value;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*$batch_notes*/ ctx[1] === "") return create_if_block$d;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	function dialog_value_binding(value) {
    		/*dialog_value_binding*/ ctx[9](value);
    	}

    	let dialog_props = {
    		$$slots: {
    			actions: [create_actions_slot$4],
    			default: [create_default_slot_2$d]
    		},
    		$$scope: { ctx }
    	};

    	if (/*showDialog*/ ctx[0] !== void 0) {
    		dialog_props.value = /*showDialog*/ ctx[0];
    	}

    	dialog = new Dialog({ props: dialog_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog, 'value', dialog_value_binding));

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			t0 = text("Batch Notes (Batch No.");
    			t1 = text(/*$batch_number*/ ctx[2]);
    			t2 = text(")");
    			t3 = space();
    			div1 = element("div");
    			if_block.c();
    			t4 = space();
    			create_component(dialog.$$.fragment);
    			add_location(h5, file$i, 43, 8, 1219);
    			add_location(div0, file$i, 42, 4, 1168);
    			attr_dev(div1, "class", "text-break");
    			add_location(div1, file$i, 46, 4, 1284);
    			attr_dev(div2, "class", " py-2 text-center");
    			add_location(div2, file$i, 41, 0, 1132);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, h5);
    			append_dev(h5, t0);
    			append_dev(h5, t1);
    			append_dev(h5, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			if_block.m(div1, null);
    			insert_dev(target, t4, anchor);
    			mount_component(dialog, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(div1, "click", /*click_handler_1*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$batch_number*/ 4) set_data_dev(t1, /*$batch_number*/ ctx[2]);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			}

    			const dialog_changes = {};

    			if (dirty & /*$$scope, showDialog, $batch_notes, $batch_number*/ 4103) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*showDialog*/ 1) {
    				updating_value = true;
    				dialog_changes.value = /*showDialog*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			dialog.$set(dialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block.d();
    			if (detaching) detach_dev(t4);
    			destroy_component(dialog, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $batch_notes;
    	let $batch_number;
    	validate_store(batch_notes, 'batch_notes');
    	component_subscribe($$self, batch_notes, $$value => $$invalidate(1, $batch_notes = $$value));
    	validate_store(batch_number, 'batch_number');
    	component_subscribe($$self, batch_number, $$value => $$invalidate(2, $batch_number = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BatchNotes', slots, []);
    	let showDialog = false;
    	let b_notes = "";

    	function add_batch_notes() {
    		if ($batch_notes === "") {
    			fetch("./add_batch_notes/" + "nothing_to_see_here").then(d => d.text());
    		} else {
    			b_notes = $batch_notes.replace(/\n/g, " ");
    			console.log("batch_notes", b_notes);
    			fetch("./add_batch_notes/" + b_notes).then(d => d.text());
    		}
    	}

    	let batch_store = { "batch_notes": "" };

    	onMount(async () => {
    		await fetch("./retrieve_batch_notes").then(d => d.text()).then(d => JSON.parse(d)).then(d => batch_store = d);
    		set_store_value(batch_notes, $batch_notes = batch_store.batch_notes, $batch_notes);
    	}); // console.log($batch_notes);

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<BatchNotes> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, showDialog = true);
    	const click_handler_1 = () => $$invalidate(0, showDialog = true);
    	const click_handler_2 = () => $$invalidate(0, showDialog = false);
    	const click_handler_3 = () => $$invalidate(0, showDialog = false);

    	function textarea_input_handler() {
    		$batch_notes = this.value;
    		batch_notes.set($batch_notes);
    	}

    	function dialog_value_binding(value) {
    		showDialog = value;
    		$$invalidate(0, showDialog);
    	}

    	$$self.$capture_state = () => ({
    		batch_notes,
    		Label: Label$2,
    		Dialog,
    		Button,
    		marked,
    		showDialog,
    		batch_number,
    		onMount,
    		b_notes,
    		add_batch_notes,
    		batch_store,
    		$batch_notes,
    		$batch_number
    	});

    	$$self.$inject_state = $$props => {
    		if ('showDialog' in $$props) $$invalidate(0, showDialog = $$props.showDialog);
    		if ('b_notes' in $$props) b_notes = $$props.b_notes;
    		if ('batch_store' in $$props) batch_store = $$props.batch_store;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showDialog,
    		$batch_notes,
    		$batch_number,
    		add_batch_notes,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		textarea_input_handler,
    		dialog_value_binding
    	];
    }

    class BatchNotes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BatchNotes",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* src/Create/ProductSpecifics.svelte generated by Svelte v3.40.3 */

    const file$h = "src/Create/ProductSpecifics.svelte";

    // (245:0) {#if $contaminant_boolean==="Yes"}
    function create_if_block$c(ctx) {
    	let div1;
    	let div0;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[21](value);
    	}

    	let textfield_props = {
    		placeholder: "Type Contaminant Details",
    		color: "blue",
    		outlined: true,
    		label: "Contaminant Details"
    	};

    	if (/*$contaminant_details*/ ctx[0] !== void 0) {
    		textfield_props.value = /*$contaminant_details*/ ctx[0];
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));
    	textfield.$on("change", /*change_handler_6*/ ctx[22]);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(textfield.$$.fragment);
    			attr_dev(div0, "class", "col-md-10 text-center ");
    			add_location(div0, file$h, 246, 8, 8680);
    			attr_dev(div1, "class", "row align-items-center ");
    			add_location(div1, file$h, 245, 4, 8634);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(textfield, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty & /*$contaminant_details*/ 1) {
    				updating_value = true;
    				textfield_changes.value = /*$contaminant_details*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(textfield);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(245:0) {#if $contaminant_boolean===\\\"Yes\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div2;
    	let div0;
    	let textfield0;
    	let updating_value;
    	let t0;
    	let div1;
    	let textfield1;
    	let updating_value_1;
    	let t1;
    	let div5;
    	let div3;
    	let textfield2;
    	let updating_value_2;
    	let t2;
    	let div4;
    	let textfield3;
    	let updating_value_3;
    	let t3;
    	let div9;
    	let div6;
    	let h7;
    	let t5;
    	let div7;
    	let label0;
    	let input0;
    	let t6;
    	let t7;
    	let div8;
    	let label1;
    	let input1;
    	let t8;
    	let t9;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[8](value);
    	}

    	let textfield0_props = {
    		placeholder: "Type Machine Location",
    		color: "blue",
    		outlined: true,
    		label: "Machine Location (city, country)"
    	};

    	if (/*$machine_location*/ ctx[5] !== void 0) {
    		textfield0_props.value = /*$machine_location*/ ctx[5];
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));
    	textfield0.$on("change", /*change_handler*/ ctx[9]);

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[10](value);
    	}

    	let textfield1_props = {
    		placeholder: "Type Product Type",
    		color: "blue",
    		outlined: true,
    		label: "Product Type"
    	};

    	if (/*$product_type*/ ctx[4] !== void 0) {
    		textfield1_props.value = /*$product_type*/ ctx[4];
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));
    	textfield1.$on("change", /*change_handler_1*/ ctx[11]);

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[12](value);
    	}

    	let textfield2_props = {
    		placeholder: "Type Product Container",
    		color: "blue",
    		outlined: true,
    		label: "Product Container"
    	};

    	if (/*$product_container*/ ctx[3] !== void 0) {
    		textfield2_props.value = /*$product_container*/ ctx[3];
    	}

    	textfield2 = new TextField({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));
    	textfield2.$on("change", /*change_handler_2*/ ctx[13]);

    	function textfield3_value_binding(value) {
    		/*textfield3_value_binding*/ ctx[14](value);
    	}

    	let textfield3_props = {
    		placeholder: "Type Product Weight",
    		color: "blue",
    		outlined: true,
    		label: "Product Weight (kg)"
    	};

    	if (/*$product_weight*/ ctx[2] !== void 0) {
    		textfield3_props.value = /*$product_weight*/ ctx[2];
    	}

    	textfield3 = new TextField({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'value', textfield3_value_binding));
    	textfield3.$on("change", /*change_handler_3*/ ctx[15]);
    	let if_block = /*$contaminant_boolean*/ ctx[1] === "Yes" && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(textfield0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(textfield1.$$.fragment);
    			t1 = space();
    			div5 = element("div");
    			div3 = element("div");
    			create_component(textfield2.$$.fragment);
    			t2 = space();
    			div4 = element("div");
    			create_component(textfield3.$$.fragment);
    			t3 = space();
    			div9 = element("div");
    			div6 = element("div");
    			h7 = element("h7");
    			h7.textContent = "Contains Contaminant?";
    			t5 = space();
    			div7 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t6 = text(" Yes");
    			t7 = space();
    			div8 = element("div");
    			label1 = element("label");
    			input1 = element("input");
    			t8 = text(" No");
    			t9 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(div0, "class", "col-md-6");
    			add_location(div0, file$h, 198, 4, 6526);
    			attr_dev(div1, "class", "col-md-6");
    			add_location(div1, file$h, 201, 4, 6774);
    			attr_dev(div2, "class", "row align-items-center  ");
    			add_location(div2, file$h, 197, 0, 6483);
    			attr_dev(div3, "class", "col-md-6");
    			add_location(div3, file$h, 208, 4, 7047);
    			attr_dev(div4, "class", "col-md-6");
    			add_location(div4, file$h, 211, 4, 7283);
    			attr_dev(div5, "class", "row align-items-center  ");
    			add_location(div5, file$h, 207, 0, 7004);
    			add_location(h7, file$h, 219, 8, 7613);
    			attr_dev(div6, "class", "col-md-5 text-center");
    			add_location(div6, file$h, 218, 4, 7570);
    			attr_dev(input0, "type", "radio");
    			input0.__value = "Yes";
    			input0.value = input0.__value;
    			/*$$binding_groups*/ ctx[17][0].push(input0);
    			add_location(input0, file$h, 234, 8, 8216);
    			add_location(label0, file$h, 233, 4, 8200);
    			attr_dev(div7, "class", "col-md-2 text-center");
    			add_location(div7, file$h, 232, 4, 8161);
    			attr_dev(input1, "type", "radio");
    			input1.__value = "No";
    			input1.value = input1.__value;
    			/*$$binding_groups*/ ctx[17][0].push(input1);
    			add_location(input1, file$h, 239, 8, 8429);
    			add_location(label1, file$h, 238, 4, 8413);
    			attr_dev(div8, "class", "col-md-2 text-center");
    			add_location(div8, file$h, 237, 4, 8374);
    			attr_dev(div9, "class", "row align-items-center  ");
    			add_location(div9, file$h, 217, 0, 7527);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(textfield0, div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			mount_component(textfield1, div1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div3);
    			mount_component(textfield2, div3, null);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			mount_component(textfield3, div4, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div6);
    			append_dev(div6, h7);
    			append_dev(div9, t5);
    			append_dev(div9, div7);
    			append_dev(div7, label0);
    			append_dev(label0, input0);
    			input0.checked = input0.__value === /*$contaminant_boolean*/ ctx[1];
    			append_dev(label0, t6);
    			append_dev(div9, t7);
    			append_dev(div9, div8);
    			append_dev(div8, label1);
    			append_dev(label1, input1);
    			input1.checked = input1.__value === /*$contaminant_boolean*/ ctx[1];
    			append_dev(label1, t8);
    			insert_dev(target, t9, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[16]),
    					listen_dev(input0, "change", /*change_handler_4*/ ctx[18], false, false, false),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[19]),
    					listen_dev(input1, "change", /*change_handler_5*/ ctx[20], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*$machine_location*/ 32) {
    				updating_value = true;
    				textfield0_changes.value = /*$machine_location*/ ctx[5];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*$product_type*/ 16) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*$product_type*/ ctx[4];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty & /*$product_container*/ 8) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*$product_container*/ ctx[3];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_value_3 && dirty & /*$product_weight*/ 4) {
    				updating_value_3 = true;
    				textfield3_changes.value = /*$product_weight*/ ctx[2];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			textfield3.$set(textfield3_changes);

    			if (dirty & /*$contaminant_boolean*/ 2) {
    				input0.checked = input0.__value === /*$contaminant_boolean*/ ctx[1];
    			}

    			if (dirty & /*$contaminant_boolean*/ 2) {
    				input1.checked = input1.__value === /*$contaminant_boolean*/ ctx[1];
    			}

    			if (/*$contaminant_boolean*/ ctx[1] === "Yes") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$contaminant_boolean*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div5);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div9);
    			/*$$binding_groups*/ ctx[17][0].splice(/*$$binding_groups*/ ctx[17][0].indexOf(input0), 1);
    			/*$$binding_groups*/ ctx[17][0].splice(/*$$binding_groups*/ ctx[17][0].indexOf(input1), 1);
    			if (detaching) detach_dev(t9);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $contaminant_details;
    	let $contaminant_boolean;
    	let $product_weight;
    	let $product_container;
    	let $product_type;
    	let $machine_location;
    	validate_store(contaminant_details, 'contaminant_details');
    	component_subscribe($$self, contaminant_details, $$value => $$invalidate(0, $contaminant_details = $$value));
    	validate_store(contaminant_boolean, 'contaminant_boolean');
    	component_subscribe($$self, contaminant_boolean, $$value => $$invalidate(1, $contaminant_boolean = $$value));
    	validate_store(product_weight, 'product_weight');
    	component_subscribe($$self, product_weight, $$value => $$invalidate(2, $product_weight = $$value));
    	validate_store(product_container, 'product_container');
    	component_subscribe($$self, product_container, $$value => $$invalidate(3, $product_container = $$value));
    	validate_store(product_type, 'product_type');
    	component_subscribe($$self, product_type, $$value => $$invalidate(4, $product_type = $$value));
    	validate_store(machine_location, 'machine_location');
    	component_subscribe($$self, machine_location, $$value => $$invalidate(5, $machine_location = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ProductSpecifics', slots, []);
    	let { parameter_value = "" } = $$props;

    	function send_parameters(parameter_name) {
    		// if (contaminant_bool){
    		// $contaminant_boolean = contaminant_bool.currentTarget.value;
    		// console.log("contaminant_bool", contaminant_bool);
    		// console.log("contaminant_bool.currentTarget.value", contaminant_bool.currentTarget.value);
    		// }
    		// console.log("$contaminant_boolean",$contaminant_boolean)
    		// console.log(parameter_name);
    		if (parameter_name === "machine_location") {
    			if ($machine_location != "") {
    				$$invalidate(7, parameter_value = $machine_location);
    			} else {
    				$$invalidate(7, parameter_value = "nothing_to_see_here");
    			}
    		}

    		if (parameter_name === "product_type") {
    			if ($product_type != "") {
    				$$invalidate(7, parameter_value = $product_type);
    			} else {
    				$$invalidate(7, parameter_value = "nothing_to_see_here");
    			}
    		}

    		if (parameter_name === "product_container") {
    			if ($product_container != "") {
    				$$invalidate(7, parameter_value = $product_container);
    			} else {
    				$$invalidate(7, parameter_value = "nothing_to_see_here");
    			}
    		}

    		if (parameter_name === "product_weight") {
    			if ($product_weight != "") {
    				$$invalidate(7, parameter_value = $product_weight);
    			} else {
    				$$invalidate(7, parameter_value = "nothing_to_see_here");
    			}
    		}

    		if (parameter_name === "contaminant_boolean") {
    			// console.log("contaminant_boolean", $contaminant_boolean)
    			if ($contaminant_boolean) {
    				$$invalidate(7, parameter_value = $contaminant_boolean);
    			} else {
    				$$invalidate(7, parameter_value = "nothing_to_see_here");
    			}
    		}

    		if (parameter_name === "contaminant_details") {
    			// console.log("contaminant_details", $contaminant_details)
    			if ($contaminant_details != "") {
    				$$invalidate(7, parameter_value = $contaminant_details);
    			} else {
    				$$invalidate(7, parameter_value = "nothing_to_see_here");
    			}
    		}

    		fetch("./send_parameters/" + parameter_name + "/" + parameter_value).then(d => d.text());
    	} // .then(d => JSON.parse(d))
    	// .then(d => (parameter_values = d));

    	// $parameter1 = parameter_values.parameter1;
    	// $parameter2 = parameter_values.parameter2;
    	// $parameter3 = parameter_values.parameter3;
    	// $parameter4 = parameter_values.parameter4;
    	// $parameter5 = parameter_values.parameter5;
    	// $parameter6 = parameter_values.parameter6;
    	// afterUpdate(async () =>   {
    	//     if ($machine_location === ""){
    	//         not_ready_to_end_batch()
    	// } else if ($product_type === "") {
    	//     not_ready_to_end_batch()
    	// }  else if ($product_container === "") {
    	//     not_ready_to_end_batch()
    	// } else if ($product_weight === "") {
    	//     not_ready_to_end_batch()
    	// }
    	// // else if ($contaminant_boolean === "") {
    	// //         not_ready_to_end_batch()     
    	// //     }
    	// // } else if ($software_type === "") {
    	// //     not_ready_to_end_batch()
    	// // } else if ($software_version === "") {
    	// //     not_ready_to_end_batch()
    	// // }
    	//     else{
    	//         ready_to_end_batch_now()
    	//         $ready_to_end_batch = true
    	//         $button_alert_change = false
    	//     }
    	// } 
    	// );
    	let parameter_values = {
    		"machine_location": "",
    		"product_type": "",
    		"product_container": "",
    		"product_weight": "",
    		"contaminant_boolean": "No",
    		"contaminant_details": ""
    	};

    	onMount(async () => {
    		const response = await fetch("./retrieve_parameters");
    		const parameter_values = await response.json();

    		// characterName = character.name;
    		// .then(d => d.text())
    		// .then(d => JSON.parse(d))
    		// .then(d => (parameter_values = d)
    		// );
    		set_store_value(machine_location, $machine_location = parameter_values.machine_location, $machine_location);

    		set_store_value(product_type, $product_type = parameter_values.product_type, $product_type);
    		set_store_value(product_container, $product_container = parameter_values.product_container, $product_container);
    		set_store_value(product_weight, $product_weight = parameter_values.product_weight, $product_weight);
    		set_store_value(contaminant_boolean, $contaminant_boolean = parameter_values.contaminant_boolean, $contaminant_boolean);
    		set_store_value(contaminant_details, $contaminant_details = parameter_values.contaminant_details, $contaminant_details);
    	}); // console.log($machine_location);
    	// console.log("machine_location");
    	// console.log("$contaminant_boolean",$contaminant_boolean);

    	const writable_props = ['parameter_value'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ProductSpecifics> was created with unknown prop '${key}'`);
    	});

    	const $$binding_groups = [[]];

    	function textfield0_value_binding(value) {
    		$machine_location = value;
    		machine_location.set($machine_location);
    	}

    	const change_handler = () => send_parameters("machine_location");

    	function textfield1_value_binding(value) {
    		$product_type = value;
    		product_type.set($product_type);
    	}

    	const change_handler_1 = () => send_parameters("product_type");

    	function textfield2_value_binding(value) {
    		$product_container = value;
    		product_container.set($product_container);
    	}

    	const change_handler_2 = () => send_parameters("product_container");

    	function textfield3_value_binding(value) {
    		$product_weight = value;
    		product_weight.set($product_weight);
    	}

    	const change_handler_3 = () => send_parameters("product_weight");

    	function input0_change_handler() {
    		$contaminant_boolean = this.__value;
    		contaminant_boolean.set($contaminant_boolean);
    	}

    	const change_handler_4 = () => send_parameters("contaminant_boolean");

    	function input1_change_handler() {
    		$contaminant_boolean = this.__value;
    		contaminant_boolean.set($contaminant_boolean);
    	}

    	const change_handler_5 = () => send_parameters("contaminant_boolean");

    	function textfield_value_binding(value) {
    		$contaminant_details = value;
    		contaminant_details.set($contaminant_details);
    	}

    	const change_handler_6 = () => send_parameters("contaminant_details");

    	$$self.$$set = $$props => {
    		if ('parameter_value' in $$props) $$invalidate(7, parameter_value = $$props.parameter_value);
    	};

    	$$self.$capture_state = () => ({
    		TextField,
    		RadioButtonGroup,
    		onMount,
    		button_alert_change,
    		machine_location,
    		product_type,
    		product_container,
    		product_weight,
    		ready_to_end_batch,
    		contaminant_boolean,
    		contaminant_details,
    		parameter_value,
    		send_parameters,
    		parameter_values,
    		$contaminant_details,
    		$contaminant_boolean,
    		$product_weight,
    		$product_container,
    		$product_type,
    		$machine_location
    	});

    	$$self.$inject_state = $$props => {
    		if ('parameter_value' in $$props) $$invalidate(7, parameter_value = $$props.parameter_value);
    		if ('parameter_values' in $$props) parameter_values = $$props.parameter_values;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		$contaminant_details,
    		$contaminant_boolean,
    		$product_weight,
    		$product_container,
    		$product_type,
    		$machine_location,
    		send_parameters,
    		parameter_value,
    		textfield0_value_binding,
    		change_handler,
    		textfield1_value_binding,
    		change_handler_1,
    		textfield2_value_binding,
    		change_handler_2,
    		textfield3_value_binding,
    		change_handler_3,
    		input0_change_handler,
    		$$binding_groups,
    		change_handler_4,
    		input1_change_handler,
    		change_handler_5,
    		textfield_value_binding,
    		change_handler_6
    	];
    }

    class ProductSpecifics extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { parameter_value: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ProductSpecifics",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get parameter_value() {
    		throw new Error("<ProductSpecifics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set parameter_value(value) {
    		throw new Error("<ProductSpecifics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Create/Batch_Info.svelte generated by Svelte v3.40.3 */
    const file$g = "src/Create/Batch_Info.svelte";

    // (17:8) {#if isOpen }
    function create_if_block_1$9(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "light",
    				$$slots: { default: [create_default_slot_2$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(17:8) {#if isOpen }",
    		ctx
    	});

    	return block;
    }

    // (18:12) <Button  size="lg"  color = "light"   on:click={handleClick} >
    function create_default_slot_2$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Batch Info");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$c.name,
    		type: "slot",
    		source: "(18:12) <Button  size=\\\"lg\\\"  color = \\\"light\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (22:8) {#if !isOpen }
    function create_if_block$b(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "info",
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(22:8) {#if !isOpen }",
    		ctx
    	});

    	return block;
    }

    // (23:12) <Button   size="lg"    color = "info"   on:click={handleClick} >
    function create_default_slot_1$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Batch Info");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(23:12) <Button   size=\\\"lg\\\"    color = \\\"info\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (29:8) <Fade {isOpen} >
    function create_default_slot$e(ctx) {
    	let div3;
    	let div0;
    	let productspecifics;
    	let t0;
    	let div1;
    	let batchnotes;
    	let t1;
    	let div2;
    	let current;
    	productspecifics = new ProductSpecifics({ $$inline: true });
    	batchnotes = new BatchNotes({ $$inline: true });

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			create_component(productspecifics.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(batchnotes.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			attr_dev(div0, "class", "col-md-5 offset-md-1 ");
    			add_location(div0, file$g, 31, 16, 845);
    			attr_dev(div1, "class", "col-md-4 offset-md-1 ");
    			add_location(div1, file$g, 35, 16, 958);
    			add_location(div2, file$g, 38, 12, 1060);
    			attr_dev(div3, "class", "col-md-9  offset-md-2 row align-items-baseline border-bottom pb-4");
    			add_location(div3, file$g, 30, 12, 749);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			mount_component(productspecifics, div0, null);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			mount_component(batchnotes, div1, null);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(productspecifics.$$.fragment, local);
    			transition_in(batchnotes.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(productspecifics.$$.fragment, local);
    			transition_out(batchnotes.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(productspecifics);
    			destroy_component(batchnotes);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(29:8) <Fade {isOpen} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let t0;
    	let t1;
    	let fade;
    	let current;
    	let if_block0 = /*isOpen*/ ctx[0] && create_if_block_1$9(ctx);
    	let if_block1 = !/*isOpen*/ ctx[0] && create_if_block$b(ctx);

    	fade = new Fade({
    			props: {
    				isOpen: /*isOpen*/ ctx[0],
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			create_component(fade.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fade, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$9(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isOpen*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$b(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const fade_changes = {};
    			if (dirty & /*isOpen*/ 1) fade_changes.isOpen = /*isOpen*/ ctx[0];

    			if (dirty & /*$$scope*/ 4) {
    				fade_changes.$$scope = { dirty, ctx };
    			}

    			fade.$set(fade_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(fade.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(fade.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fade, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Batch_Info', slots, []);
    	let isOpen = true;

    	function handleClick() {
    		$$invalidate(0, isOpen = !isOpen);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Batch_Info> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Fade,
    		Button: Button$1,
    		Badge,
    		BatchNotes,
    		ProductSpecifics,
    		ready_to_work,
    		isOpen,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isOpen, handleClick];
    }

    class Batch_Info extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Batch_Info",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src/Settings/Connect.svelte generated by Svelte v3.40.3 */
    const file$f = "src/Settings/Connect.svelte";

    // (86:14) <Button outlined on:click={connectToIP} color="blue">
    function create_default_slot$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Connect");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(86:14) <Button outlined on:click={connectToIP} color=\\\"blue\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div9;
    	let div0;
    	let textfield0;
    	let updating_value;
    	let t0;
    	let div1;
    	let t2;
    	let div2;
    	let textfield1;
    	let updating_value_1;
    	let t3;
    	let div3;
    	let t5;
    	let div4;
    	let textfield2;
    	let updating_value_2;
    	let t6;
    	let div5;
    	let t8;
    	let div6;
    	let textfield3;
    	let updating_value_3;
    	let t9;
    	let div8;
    	let div7;
    	let button;
    	let current;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[11](value);
    	}

    	let textfield0_props = {
    		color: "blue",
    		placeholder: "192",
    		label: "IP Address",
    		outlined: true
    	};

    	if (/*ip_address_one*/ ctx[0] !== void 0) {
    		textfield0_props.value = /*ip_address_one*/ ctx[0];
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[12](value);
    	}

    	let textfield1_props = {
    		color: "blue",
    		placeholder: "168",
    		outlined: true
    	};

    	if (/*ip_address_two*/ ctx[1] !== void 0) {
    		textfield1_props.value = /*ip_address_two*/ ctx[1];
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[13](value);
    	}

    	let textfield2_props = {
    		color: "blue",
    		placeholder: "...",
    		outlined: true
    	};

    	if (/*ip_address_three*/ ctx[2] !== void 0) {
    		textfield2_props.value = /*ip_address_three*/ ctx[2];
    	}

    	textfield2 = new TextField({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));

    	function textfield3_value_binding(value) {
    		/*textfield3_value_binding*/ ctx[14](value);
    	}

    	let textfield3_props = {
    		color: "blue",
    		placeholder: "..",
    		outlined: true
    	};

    	if (/*ip_address_four*/ ctx[3] !== void 0) {
    		textfield3_props.value = /*ip_address_four*/ ctx[3];
    	}

    	textfield3 = new TextField({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'value', textfield3_value_binding));

    	button = new Button({
    			props: {
    				outlined: true,
    				color: "blue",
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*connectToIP*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div0 = element("div");
    			create_component(textfield0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			div1.textContent = ".";
    			t2 = space();
    			div2 = element("div");
    			create_component(textfield1.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			div3.textContent = ".";
    			t5 = space();
    			div4 = element("div");
    			create_component(textfield2.$$.fragment);
    			t6 = space();
    			div5 = element("div");
    			div5.textContent = ".";
    			t8 = space();
    			div6 = element("div");
    			create_component(textfield3.$$.fragment);
    			t9 = space();
    			div8 = element("div");
    			div7 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div0, "class", "offset-md-1 col-md-2 ");
    			add_location(div0, file$f, 62, 4, 1799);
    			add_location(div1, file$f, 65, 4, 1954);
    			attr_dev(div2, "class", "col-md-2 ");
    			add_location(div2, file$f, 68, 4, 1986);
    			add_location(div3, file$f, 71, 4, 2112);
    			attr_dev(div4, "class", "col-md-2 ");
    			add_location(div4, file$f, 74, 4, 2144);
    			add_location(div5, file$f, 77, 4, 2271);
    			attr_dev(div6, "class", "col-md-2 ");
    			add_location(div6, file$f, 80, 4, 2303);
    			add_location(div7, file$f, 85, 8, 2468);
    			attr_dev(div8, "class", " col-md-2  ");
    			add_location(div8, file$f, 83, 4, 2429);
    			attr_dev(div9, "class", "row align-items-center col-md-6 ");
    			add_location(div9, file$f, 60, 1, 1743);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div0);
    			mount_component(textfield0, div0, null);
    			append_dev(div9, t0);
    			append_dev(div9, div1);
    			append_dev(div9, t2);
    			append_dev(div9, div2);
    			mount_component(textfield1, div2, null);
    			append_dev(div9, t3);
    			append_dev(div9, div3);
    			append_dev(div9, t5);
    			append_dev(div9, div4);
    			mount_component(textfield2, div4, null);
    			append_dev(div9, t6);
    			append_dev(div9, div5);
    			append_dev(div9, t8);
    			append_dev(div9, div6);
    			mount_component(textfield3, div6, null);
    			append_dev(div9, t9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			mount_component(button, div7, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*ip_address_one*/ 1) {
    				updating_value = true;
    				textfield0_changes.value = /*ip_address_one*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*ip_address_two*/ 2) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*ip_address_two*/ ctx[1];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty & /*ip_address_three*/ 4) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*ip_address_three*/ ctx[2];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_value_3 && dirty & /*ip_address_four*/ 8) {
    				updating_value_3 = true;
    				textfield3_changes.value = /*ip_address_four*/ ctx[3];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Connect', slots, []);
    	let data = { "status": "test" };
    	let { connection_status = "" } = $$props;
    	let { connection_progress = "" } = $$props;
    	let { connection_progress_float = 67 } = $$props;
    	let connection_data = { "progress": "test2", "status": "test1" };

    	onMount(async () => {
    		await fetch("./connection_stats").then(d => d.text()).then(d => JSON.parse(d)).then(d => $$invalidate(10, connection_data = d));
    	});

    	let { ip_address = "" } = $$props;
    	let { ip_message = "" } = $$props;

    	function connectToIP() {
    		fetch("./connect_to_ip/" + ip_address).then(d => d.text()).then(d => $$invalidate(8, ip_message = d));
    	}

    	let progresstest = 34;
    	let ip_address_one = "";
    	let ip_address_two = "";
    	let ip_address_three = "";
    	let ip_address_four = "";

    	const writable_props = [
    		'connection_status',
    		'connection_progress',
    		'connection_progress_float',
    		'ip_address',
    		'ip_message'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Connect> was created with unknown prop '${key}'`);
    	});

    	function textfield0_value_binding(value) {
    		ip_address_one = value;
    		$$invalidate(0, ip_address_one);
    	}

    	function textfield1_value_binding(value) {
    		ip_address_two = value;
    		$$invalidate(1, ip_address_two);
    	}

    	function textfield2_value_binding(value) {
    		ip_address_three = value;
    		$$invalidate(2, ip_address_three);
    	}

    	function textfield3_value_binding(value) {
    		ip_address_four = value;
    		$$invalidate(3, ip_address_four);
    	}

    	$$self.$$set = $$props => {
    		if ('connection_status' in $$props) $$invalidate(6, connection_status = $$props.connection_status);
    		if ('connection_progress' in $$props) $$invalidate(5, connection_progress = $$props.connection_progress);
    		if ('connection_progress_float' in $$props) $$invalidate(7, connection_progress_float = $$props.connection_progress_float);
    		if ('ip_address' in $$props) $$invalidate(9, ip_address = $$props.ip_address);
    		if ('ip_message' in $$props) $$invalidate(8, ip_message = $$props.ip_message);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		data,
    		connection_status,
    		connection_progress,
    		connection_progress_float,
    		connection_data,
    		TextField,
    		Button,
    		ip_address,
    		ip_message,
    		connectToIP,
    		Progress,
    		progresstest,
    		ip_address_one,
    		ip_address_two,
    		ip_address_three,
    		ip_address_four,
    		Badge
    	});

    	$$self.$inject_state = $$props => {
    		if ('data' in $$props) data = $$props.data;
    		if ('connection_status' in $$props) $$invalidate(6, connection_status = $$props.connection_status);
    		if ('connection_progress' in $$props) $$invalidate(5, connection_progress = $$props.connection_progress);
    		if ('connection_progress_float' in $$props) $$invalidate(7, connection_progress_float = $$props.connection_progress_float);
    		if ('connection_data' in $$props) $$invalidate(10, connection_data = $$props.connection_data);
    		if ('ip_address' in $$props) $$invalidate(9, ip_address = $$props.ip_address);
    		if ('ip_message' in $$props) $$invalidate(8, ip_message = $$props.ip_message);
    		if ('progresstest' in $$props) progresstest = $$props.progresstest;
    		if ('ip_address_one' in $$props) $$invalidate(0, ip_address_one = $$props.ip_address_one);
    		if ('ip_address_two' in $$props) $$invalidate(1, ip_address_two = $$props.ip_address_two);
    		if ('ip_address_three' in $$props) $$invalidate(2, ip_address_three = $$props.ip_address_three);
    		if ('ip_address_four' in $$props) $$invalidate(3, ip_address_four = $$props.ip_address_four);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*connection_data*/ 1024) {
    			$$invalidate(6, connection_status = connection_data.status);
    		}

    		if ($$self.$$.dirty & /*connection_data*/ 1024) {
    			$$invalidate(5, connection_progress = connection_data.progress);
    		}

    		if ($$self.$$.dirty & /*connection_progress*/ 32) {
    			$$invalidate(7, connection_progress_float = +connection_progress);
    		}
    	};

    	return [
    		ip_address_one,
    		ip_address_two,
    		ip_address_three,
    		ip_address_four,
    		connectToIP,
    		connection_progress,
    		connection_status,
    		connection_progress_float,
    		ip_message,
    		ip_address,
    		connection_data,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		textfield2_value_binding,
    		textfield3_value_binding
    	];
    }

    class Connect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			connection_status: 6,
    			connection_progress: 5,
    			connection_progress_float: 7,
    			ip_address: 9,
    			ip_message: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Connect",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get connection_status() {
    		throw new Error("<Connect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set connection_status(value) {
    		throw new Error("<Connect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get connection_progress() {
    		throw new Error("<Connect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set connection_progress(value) {
    		throw new Error("<Connect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get connection_progress_float() {
    		throw new Error("<Connect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set connection_progress_float(value) {
    		throw new Error("<Connect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ip_address() {
    		throw new Error("<Connect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ip_address(value) {
    		throw new Error("<Connect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ip_message() {
    		throw new Error("<Connect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ip_message(value) {
    		throw new Error("<Connect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Create/ConnectToMachine.svelte generated by Svelte v3.40.3 */
    const file$e = "src/Create/ConnectToMachine.svelte";

    // (11:4) {#if isOpen }
    function create_if_block_1$8(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "light",
    				$$slots: { default: [create_default_slot_2$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(11:4) {#if isOpen }",
    		ctx
    	});

    	return block;
    }

    // (13:4) <Button  size="lg"  color = "light"   on:click={handleClick} >
    function create_default_slot_2$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Connect to Machine");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(13:4) <Button  size=\\\"lg\\\"  color = \\\"light\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (17:0) {#if !isOpen }
    function create_if_block$a(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "info",
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(17:0) {#if !isOpen }",
    		ctx
    	});

    	return block;
    }

    // (18:4) <Button   size="lg"    color = "info"   on:click={handleClick} >
    function create_default_slot_1$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Connect to Machine");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(18:4) <Button   size=\\\"lg\\\"    color = \\\"info\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (25:4) <Fade {isOpen} >
    function create_default_slot$c(ctx) {
    	let div;
    	let connect;
    	let current;
    	connect = new Connect({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(connect.$$.fragment);
    			add_location(div, file$e, 26, 8, 682);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(connect, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(connect.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(connect.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(connect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(25:4) <Fade {isOpen} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let fade;
    	let current;
    	let if_block0 = /*isOpen*/ ctx[0] && create_if_block_1$8(ctx);
    	let if_block1 = !/*isOpen*/ ctx[0] && create_if_block$a(ctx);

    	fade = new Fade({
    			props: {
    				isOpen: /*isOpen*/ ctx[0],
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			create_component(fade.$$.fragment);
    			add_location(div0, file$e, 9, 0, 332);
    			attr_dev(div1, "class", "col-md-9  offset-md-2 ");
    			add_location(div1, file$e, 23, 0, 615);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(fade, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$8(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isOpen*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$a(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const fade_changes = {};
    			if (dirty & /*isOpen*/ 1) fade_changes.isOpen = /*isOpen*/ ctx[0];

    			if (dirty & /*$$scope*/ 4) {
    				fade_changes.$$scope = { dirty, ctx };
    			}

    			fade.$set(fade_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(fade.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(fade.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(fade);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ConnectToMachine', slots, []);
    	let isOpen = true;

    	function handleClick() {
    		$$invalidate(0, isOpen = !isOpen);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ConnectToMachine> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Connect,
    		Button: Button$1,
    		Fade,
    		isOpen,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isOpen, handleClick];
    }

    class ConnectToMachine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ConnectToMachine",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src/Create/GeneralNotes.svelte generated by Svelte v3.40.3 */
    const file$d = "src/Create/GeneralNotes.svelte";

    // (11:0) <Dialog  bind:value={showDialog}>
    function create_default_slot_2$a(ctx) {
    	let h3;
    	let t1;
    	let div;
    	let textarea;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "General Notes";
    			t1 = space();
    			div = element("div");
    			textarea = element("textarea");
    			add_location(h3, file$d, 11, 2, 264);
    			attr_dev(textarea, "placeholder", "Type your general product notes here");
    			attr_dev(textarea, "rows", "14");
    			attr_dev(textarea, "cols", "80 ");
    			add_location(textarea, file$d, 12, 29, 317);
    			attr_dev(div, "class", "text-gray-700");
    			add_location(div, file$d, 12, 2, 290);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, textarea);
    			set_input_value(textarea, /*general_notes*/ ctx[0]);

    			if (!mounted) {
    				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*general_notes*/ 1) {
    				set_input_value(textarea, /*general_notes*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(11:0) <Dialog  bind:value={showDialog}>",
    		ctx
    	});

    	return block;
    }

    // (15:6) <Button color="blue" text on:click={() => showDialog = false}>
    function create_default_slot_1$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(15:6) <Button color=\\\"blue\\\" text on:click={() => showDialog = false}>",
    		ctx
    	});

    	return block;
    }

    // (16:6) <Button color="blue" text on:click={() => showDialog = false}>
    function create_default_slot$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(16:6) <Button color=\\\"blue\\\" text on:click={() => showDialog = false}>",
    		ctx
    	});

    	return block;
    }

    // (14:2) 
    function create_actions_slot$3(ctx) {
    	let div;
    	let button0;
    	let t;
    	let button1;
    	let current;

    	button0 = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[2]);

    	button1 = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[3]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    			attr_dev(div, "slot", "actions");
    			add_location(div, file$d, 13, 2, 447);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button0, div, null);
    			append_dev(div, t);
    			mount_component(button1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_actions_slot$3.name,
    		type: "slot",
    		source: "(14:2) ",
    		ctx
    	});

    	return block;
    }

    // (29:6) {:else}
    function create_else_block$3(ctx) {
    	let h7;
    	let raw_value = marked(/*general_notes*/ ctx[0]) + "";

    	const block = {
    		c: function create() {
    			h7 = element("h7");
    			add_location(h7, file$d, 29, 8, 978);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h7, anchor);
    			h7.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*general_notes*/ 1 && raw_value !== (raw_value = marked(/*general_notes*/ ctx[0]) + "")) h7.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(29:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (26:6) {#if general_notes === ""}
    function create_if_block$9(ctx) {
    	let h7;

    	const block = {
    		c: function create() {
    			h7 = element("h7");
    			h7.textContent = "Type your general product notes here";
    			add_location(h7, file$d, 26, 6, 902);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h7, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(26:6) {#if general_notes === \\\"\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let dialog;
    	let updating_value;
    	let t0;
    	let div2;
    	let div0;
    	let h5;
    	let t2;
    	let div1;
    	let current;
    	let mounted;
    	let dispose;

    	function dialog_value_binding(value) {
    		/*dialog_value_binding*/ ctx[5](value);
    	}

    	let dialog_props = {
    		$$slots: {
    			actions: [create_actions_slot$3],
    			default: [create_default_slot_2$a]
    		},
    		$$scope: { ctx }
    	};

    	if (/*showDialog*/ ctx[1] !== void 0) {
    		dialog_props.value = /*showDialog*/ ctx[1];
    	}

    	dialog = new Dialog({ props: dialog_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog, 'value', dialog_value_binding));

    	function select_block_type(ctx, dirty) {
    		if (/*general_notes*/ ctx[0] === "") return create_if_block$9;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			create_component(dialog.$$.fragment);
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "General Notes";
    			t2 = space();
    			div1 = element("div");
    			if_block.c();
    			add_location(h5, file$d, 22, 6, 752);
    			attr_dev(div0, "class", "text-center ");
    			add_location(div0, file$d, 21, 2, 683);
    			attr_dev(div1, "class", "text-center text-break");
    			add_location(div1, file$d, 24, 2, 788);
    			attr_dev(div2, "class", "py-2 ");
    			add_location(div2, file$d, 20, 0, 661);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialog, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, h5);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			if_block.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*click_handler_2*/ ctx[6], false, false, false),
    					listen_dev(div1, "click", /*click_handler_3*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const dialog_changes = {};

    			if (dirty & /*$$scope, showDialog, general_notes*/ 515) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*showDialog*/ 2) {
    				updating_value = true;
    				dialog_changes.value = /*showDialog*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			dialog.$set(dialog_changes);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dialog, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('GeneralNotes', slots, []);
    	let showDialog = false;
    	let showDialog1 = false;
    	let { general_notes = "" } = $$props;
    	const writable_props = ['general_notes'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GeneralNotes> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(1, showDialog = false);
    	const click_handler_1 = () => $$invalidate(1, showDialog = false);

    	function textarea_input_handler() {
    		general_notes = this.value;
    		$$invalidate(0, general_notes);
    	}

    	function dialog_value_binding(value) {
    		showDialog = value;
    		$$invalidate(1, showDialog);
    	}

    	const click_handler_2 = () => $$invalidate(1, showDialog = true);
    	const click_handler_3 = () => $$invalidate(1, showDialog = true);

    	$$self.$$set = $$props => {
    		if ('general_notes' in $$props) $$invalidate(0, general_notes = $$props.general_notes);
    	};

    	$$self.$capture_state = () => ({
    		Dialog,
    		Button,
    		marked,
    		showDialog,
    		showDialog1,
    		general_notes,
    		Badge
    	});

    	$$self.$inject_state = $$props => {
    		if ('showDialog' in $$props) $$invalidate(1, showDialog = $$props.showDialog);
    		if ('showDialog1' in $$props) showDialog1 = $$props.showDialog1;
    		if ('general_notes' in $$props) $$invalidate(0, general_notes = $$props.general_notes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		general_notes,
    		showDialog,
    		click_handler,
    		click_handler_1,
    		textarea_input_handler,
    		dialog_value_binding,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class GeneralNotes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { general_notes: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GeneralNotes",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get general_notes() {
    		throw new Error("<GeneralNotes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set general_notes(value) {
    		throw new Error("<GeneralNotes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Create/OpenGeneralNotes.svelte generated by Svelte v3.40.3 */
    const file$c = "src/Create/OpenGeneralNotes.svelte";

    // (15:4) {#if isOpen }
    function create_if_block_1$7(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "light",
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(15:4) {#if isOpen }",
    		ctx
    	});

    	return block;
    }

    // (16:4) <Button  size="lg"  color = "light"   on:click={handleClick} >
    function create_default_slot_2$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("General Notes");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(16:4) <Button  size=\\\"lg\\\"  color = \\\"light\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (20:4) {#if !isOpen }
    function create_if_block$8(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "info",
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(20:4) {#if !isOpen }",
    		ctx
    	});

    	return block;
    }

    // (21:8) <Button   size="lg"    color = "info"   on:click={handleClick} >
    function create_default_slot_1$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("General Notes");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(21:8) <Button   size=\\\"lg\\\"    color = \\\"info\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (27:4) <Fade {isOpen} >
    function create_default_slot$a(ctx) {
    	let div;
    	let generalnotes;
    	let current;
    	generalnotes = new GeneralNotes({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(generalnotes.$$.fragment);
    			attr_dev(div, "class", "border-bottom pb-4");
    			add_location(div, file$c, 28, 8, 717);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(generalnotes, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(generalnotes.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(generalnotes.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(generalnotes);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(27:4) <Fade {isOpen} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let fade;
    	let current;
    	let if_block0 = /*isOpen*/ ctx[0] && create_if_block_1$7(ctx);
    	let if_block1 = !/*isOpen*/ ctx[0] && create_if_block$8(ctx);

    	fade = new Fade({
    			props: {
    				isOpen: /*isOpen*/ ctx[0],
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			create_component(fade.$$.fragment);
    			add_location(div0, file$c, 13, 0, 361);
    			attr_dev(div1, "class", "col-md-9 offset-md-2 ");
    			add_location(div1, file$c, 25, 0, 651);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(fade, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isOpen*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$8(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const fade_changes = {};
    			if (dirty & /*isOpen*/ 1) fade_changes.isOpen = /*isOpen*/ ctx[0];

    			if (dirty & /*$$scope*/ 4) {
    				fade_changes.$$scope = { dirty, ctx };
    			}

    			fade.$set(fade_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(fade.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(fade.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(fade);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OpenGeneralNotes', slots, []);
    	let isOpen = true;

    	function handleClick() {
    		$$invalidate(0, isOpen = !isOpen);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OpenGeneralNotes> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Fade,
    		Button: Button$1,
    		GeneralNotes,
    		isOpen,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isOpen, handleClick];
    }

    class OpenGeneralNotes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OpenGeneralNotes",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src/Create/BatchRun.svelte generated by Svelte v3.40.3 */

    const { console: console_1$3 } = globals;

    const file$b = "src/Create/BatchRun.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	return child_ctx;
    }

    // (209:0) {#if $ready_to_work}
    function create_if_block_1$6(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block5_anchor;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*$fetching_images*/ ctx[3]) return create_if_block_21$1;
    		if (!/*$fetching_images*/ ctx[3]) return create_if_block_22$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type && current_block_type(ctx);
    	let if_block1 = /*$is_clicked_begin_collection*/ ctx[6] && create_if_block_16$2(ctx);
    	let if_block2 = !/*$is_clicked_begin_collection*/ ctx[6] && create_if_block_13$2(ctx);
    	let if_block3 = /*$is_Clicked_end*/ ctx[4] && create_if_block_8$2(ctx);
    	let if_block4 = !/*$is_Clicked_end*/ ctx[4] && create_if_block_5$2(ctx);
    	let if_block5 = /*$button_alert_change*/ ctx[1] && create_if_block_2$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			if_block5_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, if_block5_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if (if_block0) if_block0.d(1);
    				if_block0 = current_block_type && current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			}

    			if (/*$is_clicked_begin_collection*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*$is_clicked_begin_collection*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_16$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!/*$is_clicked_begin_collection*/ ctx[6]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*$is_clicked_begin_collection*/ 64) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_13$2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(t2.parentNode, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$is_Clicked_end*/ ctx[4]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*$is_Clicked_end*/ 16) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_8$2(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t3.parentNode, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!/*$is_Clicked_end*/ ctx[4]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*$is_Clicked_end*/ 16) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_5$2(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t4.parentNode, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*$button_alert_change*/ ctx[1]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*$button_alert_change*/ 2) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_2$3(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) {
    				if_block0.d(detaching);
    			}

    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(if_block5_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(209:0) {#if $ready_to_work}",
    		ctx
    	});

    	return block;
    }

    // (219:37) 
    function create_if_block_22$1(ctx) {
    	let t;
    	let if_block1_anchor;
    	let if_block0 = /*$is_Clicked_start*/ ctx[5] && create_if_block_24(ctx);
    	let if_block1 = !/*$is_Clicked_start*/ ctx[5] && create_if_block_23(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$is_Clicked_start*/ ctx[5]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_24(ctx);
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*$is_Clicked_start*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_23(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22$1.name,
    		type: "if",
    		source: "(219:37) ",
    		ctx
    	});

    	return block;
    }

    // (210:8) {#if $fetching_images}
    function create_if_block_21$1(ctx) {
    	let div;
    	let select1;
    	let select0;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*$batch_collection*/ ctx[8];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			select0 = element("select");
    			add_location(select0, file$b, 216, 20, 7754);
    			select1.disabled = true;
    			if (/*$batch_number*/ ctx[2] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[15].call(select1));
    			add_location(select1, file$b, 212, 20, 7448);
    			attr_dev(div, "class", "col-md-2");
    			add_location(div, file$b, 210, 16, 7345);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			append_dev(select1, select0);
    			select_option(select1, /*$batch_number*/ ctx[2]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[15]),
    					listen_dev(select1, "change", /*send_batch_number*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_collection*/ 256) {
    				each_value_1 = /*$batch_collection*/ ctx[8];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, select0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty[0] & /*$batch_number, $batch_collection*/ 260) {
    				select_option(select1, /*$batch_number*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21$1.name,
    		type: "if",
    		source: "(210:8) {#if $fetching_images}",
    		ctx
    	});

    	return block;
    }

    // (220:16) {#if $is_Clicked_start }
    function create_if_block_24(ctx) {
    	let div;
    	let select1;
    	let select0;
    	let mounted;
    	let dispose;
    	let each_value_3 = /*$batch_collection*/ ctx[8];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			select0 = element("select");
    			add_location(select0, file$b, 227, 20, 8292);
    			select1.disabled = true;
    			if (/*$batch_number*/ ctx[2] === void 0) add_render_callback(() => /*select1_change_handler_1*/ ctx[16].call(select1));
    			add_location(select1, file$b, 223, 20, 7986);
    			attr_dev(div, "class", "col-md-2");
    			add_location(div, file$b, 221, 16, 7883);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			append_dev(select1, select0);
    			select_option(select1, /*$batch_number*/ ctx[2]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select1, "change", /*select1_change_handler_1*/ ctx[16]),
    					listen_dev(select1, "change", /*send_batch_number*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_collection*/ 256) {
    				each_value_3 = /*$batch_collection*/ ctx[8];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_3$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, select0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_3.length;
    			}

    			if (dirty[0] & /*$batch_number, $batch_collection*/ 260) {
    				select_option(select1, /*$batch_number*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_24.name,
    		type: "if",
    		source: "(220:16) {#if $is_Clicked_start }",
    		ctx
    	});

    	return block;
    }

    // (225:24) {#each $batch_collection as batch_collection_number}
    function create_each_block_3$1(ctx) {
    	let option;
    	let t_value = /*batch_collection_number*/ ctx[35] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*batch_collection_number*/ ctx[35];
    			option.value = option.__value;
    			add_location(option, file$b, 225, 24, 8163);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_collection*/ 256 && t_value !== (t_value = /*batch_collection_number*/ ctx[35] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$batch_collection*/ 256 && option_value_value !== (option_value_value = /*batch_collection_number*/ ctx[35])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(225:24) {#each $batch_collection as batch_collection_number}",
    		ctx
    	});

    	return block;
    }

    // (231:16) {#if !$is_Clicked_start}
    function create_if_block_23(ctx) {
    	let div;
    	let select1;
    	let select0;
    	let mounted;
    	let dispose;
    	let each_value_2 = /*$batch_collection*/ ctx[8];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			select0 = element("select");
    			add_location(select0, file$b, 237, 20, 8804);
    			if (/*$batch_number*/ ctx[2] === void 0) add_render_callback(() => /*select1_change_handler_2*/ ctx[17].call(select1));
    			add_location(select1, file$b, 233, 20, 8507);
    			attr_dev(div, "class", "col-md-2");
    			add_location(div, file$b, 231, 16, 8404);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			append_dev(select1, select0);
    			select_option(select1, /*$batch_number*/ ctx[2]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select1, "change", /*select1_change_handler_2*/ ctx[17]),
    					listen_dev(select1, "change", /*send_batch_number*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_collection*/ 256) {
    				each_value_2 = /*$batch_collection*/ ctx[8];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, select0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}

    			if (dirty[0] & /*$batch_number, $batch_collection*/ 260) {
    				select_option(select1, /*$batch_number*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_23.name,
    		type: "if",
    		source: "(231:16) {#if !$is_Clicked_start}",
    		ctx
    	});

    	return block;
    }

    // (235:24) {#each $batch_collection as batch_collection_number}
    function create_each_block_2$2(ctx) {
    	let option;
    	let t_value = /*batch_collection_number*/ ctx[35] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*batch_collection_number*/ ctx[35];
    			option.value = option.__value;
    			add_location(option, file$b, 235, 24, 8675);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_collection*/ 256 && t_value !== (t_value = /*batch_collection_number*/ ctx[35] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$batch_collection*/ 256 && option_value_value !== (option_value_value = /*batch_collection_number*/ ctx[35])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(235:24) {#each $batch_collection as batch_collection_number}",
    		ctx
    	});

    	return block;
    }

    // (214:24) {#each $batch_collection as batch_collection_number}
    function create_each_block_1$2(ctx) {
    	let option;
    	let t_value = /*batch_collection_number*/ ctx[35] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*batch_collection_number*/ ctx[35];
    			option.value = option.__value;
    			add_location(option, file$b, 214, 24, 7625);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_collection*/ 256 && t_value !== (t_value = /*batch_collection_number*/ ctx[35] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$batch_collection*/ 256 && option_value_value !== (option_value_value = /*batch_collection_number*/ ctx[35])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(214:24) {#each $batch_collection as batch_collection_number}",
    		ctx
    	});

    	return block;
    }

    // (244:8) {#if $is_clicked_begin_collection }
    function create_if_block_16$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_17$1, create_if_block_18$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$fetching_images*/ ctx[3]) return 0;
    		if (!/*$fetching_images*/ ctx[3]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16$2.name,
    		type: "if",
    		source: "(244:8) {#if $is_clicked_begin_collection }",
    		ctx
    	});

    	return block;
    }

    // (250:41) 
    function create_if_block_18$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_19$1, create_if_block_20$1];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (!/*$is_Clicked_start*/ ctx[5]) return 0;
    		if (/*$is_Clicked_start*/ ctx[5]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_2(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18$1.name,
    		type: "if",
    		source: "(250:41) ",
    		ctx
    	});

    	return block;
    }

    // (245:12) {#if $fetching_images}
    function create_if_block_17$1(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				disabled: true,
    				$$slots: { default: [create_default_slot_14$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-3");
    			add_location(div, file$b, 245, 12, 8966);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17$1.name,
    		type: "if",
    		source: "(245:12) {#if $fetching_images}",
    		ctx
    	});

    	return block;
    }

    // (256:46) 
    function create_if_block_20$1(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				disabled: true,
    				$$slots: { default: [create_default_slot_16$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-3");
    			add_location(div, file$b, 256, 20, 9435);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[0] & /*$batch_number*/ 4 | dirty[1] & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20$1.name,
    		type: "if",
    		source: "(256:46) ",
    		ctx
    	});

    	return block;
    }

    // (251:16) {#if !$is_Clicked_start}
    function create_if_block_19$1(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				$$slots: { default: [create_default_slot_15$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*send_start_batch*/ ctx[10]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-3");
    			add_location(div, file$b, 251, 20, 9187);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[0] & /*$batch_number*/ 4 | dirty[1] & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19$1.name,
    		type: "if",
    		source: "(251:16) {#if !$is_Clicked_start}",
    		ctx
    	});

    	return block;
    }

    // (258:24) <Button disabled   >
    function create_default_slot_16$2(ctx) {
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Start Batch ");
    			t1 = text(/*$batch_number*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_number*/ 4) set_data_dev(t1, /*$batch_number*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$2.name,
    		type: "slot",
    		source: "(258:24) <Button disabled   >",
    		ctx
    	});

    	return block;
    }

    // (253:24) <Button  color = "blue" on:click={send_start_batch} >
    function create_default_slot_15$2(ctx) {
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Start Batch ");
    			t1 = text(/*$batch_number*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_number*/ 4) set_data_dev(t1, /*$batch_number*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$2.name,
    		type: "slot",
    		source: "(253:24) <Button  color = \\\"blue\\\" on:click={send_start_batch} >",
    		ctx
    	});

    	return block;
    }

    // (247:16) <Button  disabled  >
    function create_default_slot_14$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Fetching Images From Machine");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$2.name,
    		type: "slot",
    		source: "(247:16) <Button  disabled  >",
    		ctx
    	});

    	return block;
    }

    // (264:8) {#if !$is_clicked_begin_collection }
    function create_if_block_13$2(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = !/*$is_Clicked_start*/ ctx[5] && create_if_block_15$2(ctx);
    	let if_block1 = /*$is_Clicked_start*/ ctx[5] && create_if_block_14$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*$is_Clicked_start*/ ctx[5]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*$is_Clicked_start*/ 32) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_15$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$is_Clicked_start*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*$is_Clicked_start*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_14$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13$2.name,
    		type: "if",
    		source: "(264:8) {#if !$is_clicked_begin_collection }",
    		ctx
    	});

    	return block;
    }

    // (265:12) {#if !$is_Clicked_start}
    function create_if_block_15$2(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				$$slots: { default: [create_default_slot_13$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*send_start_batch*/ ctx[10]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-3");
    			add_location(div, file$b, 265, 16, 9731);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[0] & /*$batch_number*/ 4 | dirty[1] & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15$2.name,
    		type: "if",
    		source: "(265:12) {#if !$is_Clicked_start}",
    		ctx
    	});

    	return block;
    }

    // (267:20) <Button  color = "blue" on:click={send_start_batch} >
    function create_default_slot_13$3(ctx) {
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Start Batch ");
    			t1 = text(/*$batch_number*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_number*/ 4) set_data_dev(t1, /*$batch_number*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$3.name,
    		type: "slot",
    		source: "(267:20) <Button  color = \\\"blue\\\" on:click={send_start_batch} >",
    		ctx
    	});

    	return block;
    }

    // (270:12) {#if $is_Clicked_start }
    function create_if_block_14$2(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "alert",
    				$$slots: { default: [create_default_slot_12$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-3");
    			add_location(div, file$b, 270, 16, 9958);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[0] & /*$batch_number*/ 4 | dirty[1] & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14$2.name,
    		type: "if",
    		source: "(270:12) {#if $is_Clicked_start }",
    		ctx
    	});

    	return block;
    }

    // (272:20) <Button color = "alert"  >
    function create_default_slot_12$3(ctx) {
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Start Batch ");
    			t1 = text(/*$batch_number*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_number*/ 4) set_data_dev(t1, /*$batch_number*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$3.name,
    		type: "slot",
    		source: "(272:20) <Button color = \\\"alert\\\"  >",
    		ctx
    	});

    	return block;
    }

    // (280:8) {#if $is_Clicked_end }
    function create_if_block_8$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_9$2, create_if_block_10$2];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$fetching_images*/ ctx[3]) return 0;
    		if (!/*$fetching_images*/ ctx[3]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_3(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$2.name,
    		type: "if",
    		source: "(280:8) {#if $is_Clicked_end }",
    		ctx
    	});

    	return block;
    }

    // (285:41) 
    function create_if_block_10$2(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$button_alert_change*/ ctx[1] && create_if_block_12$2(ctx);
    	let if_block1 = !/*$button_alert_change*/ ctx[1] && create_if_block_11$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$button_alert_change*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*$button_alert_change*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_12$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*$button_alert_change*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*$button_alert_change*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_11$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$2.name,
    		type: "if",
    		source: "(285:41) ",
    		ctx
    	});

    	return block;
    }

    // (281:12) {#if $fetching_images}
    function create_if_block_9$2(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				disabled: true,
    				$$slots: { default: [create_default_slot_9$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-3");
    			add_location(div, file$b, 281, 16, 10229);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$2.name,
    		type: "if",
    		source: "(281:12) {#if $fetching_images}",
    		ctx
    	});

    	return block;
    }

    // (286:16) {#if $button_alert_change }
    function create_if_block_12$2(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "alert",
    				$$slots: { default: [create_default_slot_11$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*send_end_batch*/ ctx[12]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-3");
    			add_location(div, file$b, 286, 16, 10456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$2.name,
    		type: "if",
    		source: "(286:16) {#if $button_alert_change }",
    		ctx
    	});

    	return block;
    }

    // (288:20) <Button  color = "alert" on:click={send_end_batch} >
    function create_default_slot_11$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("End Batch");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$3.name,
    		type: "slot",
    		source: "(288:20) <Button  color = \\\"alert\\\" on:click={send_end_batch} >",
    		ctx
    	});

    	return block;
    }

    // (291:16) {#if !$button_alert_change }
    function create_if_block_11$2(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				$$slots: { default: [create_default_slot_10$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*send_end_batch*/ ctx[12]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-3");
    			add_location(div, file$b, 291, 16, 10677);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$2.name,
    		type: "if",
    		source: "(291:16) {#if !$button_alert_change }",
    		ctx
    	});

    	return block;
    }

    // (293:20) <Button  color = "blue" on:click={send_end_batch} >
    function create_default_slot_10$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("End Batch");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$3.name,
    		type: "slot",
    		source: "(293:20) <Button  color = \\\"blue\\\" on:click={send_end_batch} >",
    		ctx
    	});

    	return block;
    }

    // (283:20) <Button  disabled  >
    function create_default_slot_9$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Fetching Images From Machine");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$3.name,
    		type: "slot",
    		source: "(283:20) <Button  disabled  >",
    		ctx
    	});

    	return block;
    }

    // (300:8) {#if !$is_Clicked_end}
    function create_if_block_5$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_6$2, create_if_block_7$2];
    	const if_blocks = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*$fetching_images*/ ctx[3]) return 0;
    		if (!/*$fetching_images*/ ctx[3]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_4(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_4(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(300:8) {#if !$is_Clicked_end}",
    		ctx
    	});

    	return block;
    }

    // (305:41) 
    function create_if_block_7$2(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				disabled: true,
    				color: "blue",
    				$$slots: { default: [create_default_slot_8$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-3");
    			add_location(div, file$b, 305, 16, 11135);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(305:41) ",
    		ctx
    	});

    	return block;
    }

    // (301:12) {#if $fetching_images}
    function create_if_block_6$2(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				disabled: true,
    				$$slots: { default: [create_default_slot_7$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-3");
    			add_location(div, file$b, 301, 16, 10952);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(301:12) {#if $fetching_images}",
    		ctx
    	});

    	return block;
    }

    // (307:20) <Button disabled color = "blue"  >
    function create_default_slot_8$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("End Batch");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$3.name,
    		type: "slot",
    		source: "(307:20) <Button disabled color = \\\"blue\\\"  >",
    		ctx
    	});

    	return block;
    }

    // (303:20) <Button  disabled  >
    function create_default_slot_7$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Fetching Images From Machine");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$3.name,
    		type: "slot",
    		source: "(303:20) <Button  disabled  >",
    		ctx
    	});

    	return block;
    }

    // (314:8) {#if $button_alert_change }
    function create_if_block_2$3(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = !/*$is_Clicked_cancel*/ ctx[9] && create_if_block_4$3(ctx);
    	let if_block1 = /*$is_Clicked_cancel*/ ctx[9] && create_if_block_3$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*$is_Clicked_cancel*/ ctx[9]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*$is_Clicked_cancel*/ 512) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$is_Clicked_cancel*/ ctx[9]) {
    				if (if_block1) {
    					if (dirty[0] & /*$is_Clicked_cancel*/ 512) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(314:8) {#if $button_alert_change }",
    		ctx
    	});

    	return block;
    }

    // (315:12) {#if !$is_Clicked_cancel }
    function create_if_block_4$3(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "error",
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*cancel_batch*/ ctx[13]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-2");
    			add_location(div, file$b, 315, 16, 11389);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(315:12) {#if !$is_Clicked_cancel }",
    		ctx
    	});

    	return block;
    }

    // (317:20) <Button  color = "error" on:click={cancel_batch} >
    function create_default_slot_6$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel Batch");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(317:20) <Button  color = \\\"error\\\" on:click={cancel_batch} >",
    		ctx
    	});

    	return block;
    }

    // (323:12) {#if $is_Clicked_cancel}
    function create_if_block_3$3(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				disabled: true,
    				color: "error",
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-2");
    			add_location(div, file$b, 323, 16, 11610);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(323:12) {#if $is_Clicked_cancel}",
    		ctx
    	});

    	return block;
    }

    // (325:20) <Button disabled color = "error"  >
    function create_default_slot_5$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel Batch");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(325:20) <Button disabled color = \\\"error\\\"  >",
    		ctx
    	});

    	return block;
    }

    // (334:0) {#if !$ready_to_work}
    function create_if_block$7(ctx) {
    	let div0;
    	let select1;
    	let select0;
    	let t0;
    	let div1;
    	let button0;
    	let t1;
    	let div2;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*$batch_collection*/ ctx[8];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	button0 = new Button({
    			props: {
    				disabled: true,
    				color: "blue",
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				disabled: true,
    				color: "blue",
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			select0 = element("select");
    			t0 = space();
    			div1 = element("div");
    			create_component(button0.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(button1.$$.fragment);
    			add_location(select0, file$b, 341, 4, 12152);
    			select1.disabled = true;
    			if (/*$batch_number*/ ctx[2] === void 0) add_render_callback(() => /*select1_change_handler_3*/ ctx[18].call(select1));
    			add_location(select1, file$b, 337, 4, 11910);
    			attr_dev(div0, "class", "col-md-2");
    			add_location(div0, file$b, 335, 0, 11839);
    			attr_dev(div1, "class", "col-md-3");
    			add_location(div1, file$b, 344, 8, 12178);
    			attr_dev(div2, "class", "col-md-3");
    			add_location(div2, file$b, 351, 8, 12308);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			append_dev(select1, select0);
    			select_option(select1, /*$batch_number*/ ctx[2]);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(button0, div1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(button1, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select1, "change", /*select1_change_handler_3*/ ctx[18]),
    					listen_dev(select1, "change", /*send_batch_number*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_collection*/ 256) {
    				each_value = /*$batch_collection*/ ctx[8];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, select0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*$batch_number, $batch_collection*/ 260) {
    				select_option(select1, /*$batch_number*/ ctx[2]);
    			}

    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 8192) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 8192) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			destroy_component(button1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(334:0) {#if !$ready_to_work}",
    		ctx
    	});

    	return block;
    }

    // (339:8) {#each $batch_collection as batch_collection_number}
    function create_each_block$2(ctx) {
    	let option;
    	let t_value = /*batch_collection_number*/ ctx[35] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*batch_collection_number*/ ctx[35];
    			option.value = option.__value;
    			add_location(option, file$b, 339, 8, 12055);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$batch_collection*/ 256 && t_value !== (t_value = /*batch_collection_number*/ ctx[35] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$batch_collection*/ 256 && option_value_value !== (option_value_value = /*batch_collection_number*/ ctx[35])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(339:8) {#each $batch_collection as batch_collection_number}",
    		ctx
    	});

    	return block;
    }

    // (346:12) <Button disabled  color = "blue" >
    function create_default_slot_4$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Busy Processing Images");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(346:12) <Button disabled  color = \\\"blue\\\" >",
    		ctx
    	});

    	return block;
    }

    // (353:12) <Button disabled color = "blue" >
    function create_default_slot_3$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Busy Processing Images");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(353:12) <Button disabled color = \\\"blue\\\" >",
    		ctx
    	});

    	return block;
    }

    // (363:0) <Dialog  bind:value={showDialog_Cancel_Batch}>
    function create_default_slot_2$8(ctx) {
    	let h4;
    	let t1;
    	let div;
    	let h7;
    	let t2;
    	let u;
    	let t4;

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Are you sure?";
    			t1 = space();
    			div = element("div");
    			h7 = element("h7");
    			t2 = text("Doing so will result in the ");
    			u = element("u");
    			u.textContent = "loss";
    			t4 = text(" of any images in the current batch");
    			add_location(h4, file$b, 364, 8, 12554);
    			add_location(u, file$b, 366, 46, 12641);
    			add_location(h7, file$b, 366, 12, 12607);
    			add_location(div, file$b, 365, 8, 12586);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, h7);
    			append_dev(h7, t2);
    			append_dev(h7, u);
    			append_dev(h7, t4);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(363:0) <Dialog  bind:value={showDialog_Cancel_Batch}>",
    		ctx
    	});

    	return block;
    }

    // (372:8) <Button color="blue" text on:click={() => dialog_cancel_batch("Yes")}>
    function create_default_slot_1$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Yes");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(372:8) <Button color=\\\"blue\\\" text on:click={() => dialog_cancel_batch(\\\"Yes\\\")}>",
    		ctx
    	});

    	return block;
    }

    // (373:8) <Button color="blue" text on:click={() => dialog_cancel_batch("No")}>
    function create_default_slot$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(373:8) <Button color=\\\"blue\\\" text on:click={() => dialog_cancel_batch(\\\"No\\\")}>",
    		ctx
    	});

    	return block;
    }

    // (371:4) 
    function create_actions_slot$2(ctx) {
    	let div;
    	let button0;
    	let t;
    	let button1;
    	let current;

    	button0 = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[19]);

    	button1 = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[20]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    			attr_dev(div, "slot", "actions");
    			add_location(div, file$b, 370, 4, 12727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button0, div, null);
    			append_dev(div, t);
    			mount_component(button1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 8192) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 8192) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_actions_slot$2.name,
    		type: "slot",
    		source: "(371:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let dialog;
    	let updating_value;
    	let current;
    	let if_block0 = /*$ready_to_work*/ ctx[7] && create_if_block_1$6(ctx);
    	let if_block1 = !/*$ready_to_work*/ ctx[7] && create_if_block$7(ctx);

    	function dialog_value_binding(value) {
    		/*dialog_value_binding*/ ctx[21](value);
    	}

    	let dialog_props = {
    		$$slots: {
    			actions: [create_actions_slot$2],
    			default: [create_default_slot_2$8]
    		},
    		$$scope: { ctx }
    	};

    	if (/*showDialog_Cancel_Batch*/ ctx[0] !== void 0) {
    		dialog_props.value = /*showDialog_Cancel_Batch*/ ctx[0];
    	}

    	dialog = new Dialog({ props: dialog_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog, 'value', dialog_value_binding));

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			create_component(dialog.$$.fragment);
    			attr_dev(div0, "class", "row align-items-baseline border-bottom pb-4");
    			add_location(div0, file$b, 204, 0, 7134);
    			attr_dev(div1, "class", "col-md-3 offset-md-6 ");
    			attr_dev(div1, "rows", "4");
    			attr_dev(div1, "cols", "4 ");
    			add_location(div1, file$b, 361, 0, 12443);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(dialog, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$ready_to_work*/ ctx[7]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*$ready_to_work*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*$ready_to_work*/ ctx[7]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*$ready_to_work*/ 128) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$7(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const dialog_changes = {};

    			if (dirty[1] & /*$$scope*/ 8192) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty[0] & /*showDialog_Cancel_Batch*/ 1) {
    				updating_value = true;
    				dialog_changes.value = /*showDialog_Cancel_Batch*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			dialog.$set(dialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(dialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(dialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(dialog);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $button_alert_change;
    	let $ready_to_start_new_batch;
    	let $batch_notes;
    	let $completed_batches;
    	let $batch_number;
    	let $fetching_images;
    	let $ready_to_end_batch;
    	let $product_weight;
    	let $product_container;
    	let $product_type;
    	let $machine_location;
    	let $is_Clicked_end;
    	let $is_Clicked_start;
    	let $is_clicked_begin_collection;
    	let $ready_to_work;
    	let $batch_collection;
    	let $is_Clicked_cancel;
    	validate_store(button_alert_change, 'button_alert_change');
    	component_subscribe($$self, button_alert_change, $$value => $$invalidate(1, $button_alert_change = $$value));
    	validate_store(ready_to_start_new_batch, 'ready_to_start_new_batch');
    	component_subscribe($$self, ready_to_start_new_batch, $$value => $$invalidate(22, $ready_to_start_new_batch = $$value));
    	validate_store(batch_notes, 'batch_notes');
    	component_subscribe($$self, batch_notes, $$value => $$invalidate(23, $batch_notes = $$value));
    	validate_store(completed_batches, 'completed_batches');
    	component_subscribe($$self, completed_batches, $$value => $$invalidate(24, $completed_batches = $$value));
    	validate_store(batch_number, 'batch_number');
    	component_subscribe($$self, batch_number, $$value => $$invalidate(2, $batch_number = $$value));
    	validate_store(fetching_images, 'fetching_images');
    	component_subscribe($$self, fetching_images, $$value => $$invalidate(3, $fetching_images = $$value));
    	validate_store(ready_to_end_batch, 'ready_to_end_batch');
    	component_subscribe($$self, ready_to_end_batch, $$value => $$invalidate(25, $ready_to_end_batch = $$value));
    	validate_store(product_weight, 'product_weight');
    	component_subscribe($$self, product_weight, $$value => $$invalidate(26, $product_weight = $$value));
    	validate_store(product_container, 'product_container');
    	component_subscribe($$self, product_container, $$value => $$invalidate(27, $product_container = $$value));
    	validate_store(product_type, 'product_type');
    	component_subscribe($$self, product_type, $$value => $$invalidate(28, $product_type = $$value));
    	validate_store(machine_location, 'machine_location');
    	component_subscribe($$self, machine_location, $$value => $$invalidate(29, $machine_location = $$value));
    	validate_store(is_Clicked_end, 'is_Clicked_end');
    	component_subscribe($$self, is_Clicked_end, $$value => $$invalidate(4, $is_Clicked_end = $$value));
    	validate_store(is_Clicked_start, 'is_Clicked_start');
    	component_subscribe($$self, is_Clicked_start, $$value => $$invalidate(5, $is_Clicked_start = $$value));
    	validate_store(is_clicked_begin_collection, 'is_clicked_begin_collection');
    	component_subscribe($$self, is_clicked_begin_collection, $$value => $$invalidate(6, $is_clicked_begin_collection = $$value));
    	validate_store(ready_to_work, 'ready_to_work');
    	component_subscribe($$self, ready_to_work, $$value => $$invalidate(7, $ready_to_work = $$value));
    	validate_store(batch_collection, 'batch_collection');
    	component_subscribe($$self, batch_collection, $$value => $$invalidate(8, $batch_collection = $$value));
    	validate_store(is_Clicked_cancel, 'is_Clicked_cancel');
    	component_subscribe($$self, is_Clicked_cancel, $$value => $$invalidate(9, $is_Clicked_cancel = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BatchRun', slots, []);
    	let c_status = "";

    	// console.log($is_Clicked_start);
    	function send_start_batch() {
    		if ($is_clicked_begin_collection) {
    			fetch("./send_start_batch").then(d => d.text());
    			send_change_colour();

    			// c_status = "Batch Running"
    			// send_create_status(c_status)
    			fetch("./send_next_step/" + "Fill out New Batch Info").then(d => d.text());
    		} else {
    			collected_not_began_alert();
    		}
    	}

    	function collected_not_began_alert() {
    		set_store_value(is_Clicked_start, $is_Clicked_start = true, $is_Clicked_start);
    		fetch("./send_next_step/" + "Begin Collection before starting a batch").then(d => d.text());
    	} // console.log($next_step)

    	// function send_create_status(c_status) {
    	//     fetch("./send_create_status/" + c_status)
    	//     .then(d => d.text());
    	// }
    	function send_change_colour() {
    		fetch("./is_Clicked_start/" + true).then(d => d.text());
    		fetch("./is_Clicked_end/" + true).then(d => d.text());
    		set_store_value(is_Clicked_start, $is_Clicked_start = true, $is_Clicked_start);
    		set_store_value(is_Clicked_end, $is_Clicked_end = true, $is_Clicked_end);
    	}

    	function end_change_colour() {
    		// console.log($next_step)
    		if ($ready_to_end_batch === true) {
    			// $next_step = "Fill in all Batch Info before ending batch"
    			initialise_new_batch();
    		}
    	}

    	function initialise_new_batch() {
    		fetch("./is_Clicked_start/" + false).then(d => d.text());
    		fetch("./is_Clicked_end/" + false).then(d => d.text());
    		set_store_value(is_Clicked_start, $is_Clicked_start = false, $is_Clicked_start);
    		set_store_value(is_Clicked_end, $is_Clicked_end = false, $is_Clicked_end);
    		set_store_value(button_alert_change, $button_alert_change = false, $button_alert_change);
    		fetch("./ready_to_end_collection/" + true).then(d => d.text());
    	}

    	// let fact_loc = "test";
    	// let testt = "test1";
    	// let ps_parameter_values = {"machine_location":"","product_type":"","product_container":"","product_weight":"","batch_number":$batch_number};
    	async function send_batch_number() {
    		// fetch("./send_batch_number/"+$batch_number).then(de => de.text())
    		// .then(de => JSON.parse(de))
    		// .then(de => (ps_parameter_values = de)
    		// );
    		const response = await fetch("./send_batch_number/" + $batch_number);

    		const ps_parameter_values = await response.json();

    		// console.log(ps_parameter_values)
    		set_store_value(machine_location, $machine_location = ps_parameter_values.machine_location, $machine_location);

    		// fact_loc = ps_parameter_values.machine_location;
    		set_store_value(product_type, $product_type = ps_parameter_values.product_type, $product_type);

    		set_store_value(product_container, $product_container = ps_parameter_values.product_container, $product_container);
    		set_store_value(product_weight, $product_weight = ps_parameter_values.product_weight, $product_weight);
    		set_store_value(batch_number, $batch_number = ps_parameter_values.batch_number, $batch_number);
    	} // $software_type = parameter_values.software_type;
    	// $software_version = parameter_values.software_version;

    	// console.log(fact_loc);
    	// console.log("machine_location");
    	// console.log($machine_location);
    	// console.log($batch_number);
    	// console.log("fact_loc" );
    	// console.log(fact_loc);
    	// console.log(testt)
    	// console.log("finished send batch number");
    	async function send_end_batch() {
    		// check_parameters()
    		// console.log($batch_number)
    		// console.log("ready_to_end_batch", $ready_to_end_batch)
    		if ($ready_to_end_batch === true) {
    			// console.log("should I be here?")
    			set_store_value(button_alert_change, $button_alert_change = false, $button_alert_change);

    			// console.log("$batch_number", $batch_number)
    			set_store_value(ready_to_start_new_batch, $ready_to_start_new_batch = false, $ready_to_start_new_batch);

    			set_store_value(fetching_images, $fetching_images = true, $fetching_images);
    			const response = await fetch("./send_end_batch/" + $batch_number);
    			const send_end_batch_outcome = await response.json();

    			// fetch("./send_end_batch/"+ $batch_number )
    			// .then(d => d.text());
    			const response_retrieve_completed_batches = await fetch("./retrieve_completed_batches");

    			const completed_batches_response = await response_retrieve_completed_batches.json();
    			set_store_value(completed_batches, $completed_batches = completed_batches_response.completed_batches, $completed_batches);
    			console.log("$completed_batches1", $completed_batches);
    			end_change_colour();

    			// c_status = "Batch Finished";
    			// send_create_status(c_status)
    			// fetch("./send_next_step/"+ "Ready to Start a New Batch")
    			// .then(d => d.text());
    			set_store_value(batch_notes, $batch_notes = "", $batch_notes);

    			// console.log("send_end_batch_outcome","ready_to_start_new_batch", send_end_batch_outcome, $ready_to_start_new_batch)
    			if (send_end_batch_outcome === "received_send_end_batch") {
    				set_store_value(ready_to_start_new_batch, $ready_to_start_new_batch = true, $ready_to_start_new_batch);
    			}
    		} else {
    			set_store_value(button_alert_change, $button_alert_change = true, $button_alert_change);
    		}
    	}

    	// function check_parameters(){
    	// if ($machine_location === ""){
    	//     not_ready_to_end_batch()
    	// } else if ($product_type === "") {
    	//     not_ready_to_end_batch()
    	// }  else if ($product_container === "") {
    	//     not_ready_to_end_batch()
    	// } else if ($product_weight === "") {
    	//     not_ready_to_end_batch()
    	// }
    	// else if ($contaminant_boolean === "") {
    	//     not_ready_to_end_batch()
    	// }
    	// else if ($contaminant_details === "") {
    	//     console.log($contaminant_details)
    	//     not_ready_to_end_batch()
    	// }
    	// else {
    	//             // console.log("ready_to_end_batch_now")
    	//         ready_to_end_batch_now()
    	//         $ready_to_end_batch = true
    	//         $button_alert_change = false
    	//         }
    	//         if (!$machine_location === "" && !$product_type === "" 
    	//         && !$product_container === "" && !$product_weight === ""){
    	//             $ready_to_end_batch_boolean = true;
    	//         }
    	// } 
    	function cancel_batch() {
    		$$invalidate(0, showDialog_Cancel_Batch = true);
    	}

    	function dialog_cancel_batch(answer) {
    		// console.log(answer)
    		$$invalidate(0, showDialog_Cancel_Batch = false);

    		if (answer === "Yes") {
    			initialise_new_batch();
    		}
    	}

    	let showDialog_Cancel_Batch = false;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<BatchRun> was created with unknown prop '${key}'`);
    	});

    	function select1_change_handler() {
    		$batch_number = select_value(this);
    		batch_number.set($batch_number);
    	}

    	function select1_change_handler_1() {
    		$batch_number = select_value(this);
    		batch_number.set($batch_number);
    	}

    	function select1_change_handler_2() {
    		$batch_number = select_value(this);
    		batch_number.set($batch_number);
    	}

    	function select1_change_handler_3() {
    		$batch_number = select_value(this);
    		batch_number.set($batch_number);
    	}

    	const click_handler = () => dialog_cancel_batch("Yes");
    	const click_handler_1 = () => dialog_cancel_batch("No");

    	function dialog_value_binding(value) {
    		showDialog_Cancel_Batch = value;
    		$$invalidate(0, showDialog_Cancel_Batch);
    	}

    	$$self.$capture_state = () => ({
    		batch_number,
    		batch_collection,
    		is_Clicked_end,
    		is_Clicked_start,
    		next_step,
    		ready_to_end_batch,
    		machine_location,
    		product_type,
    		product_container,
    		product_weight,
    		button_alert_change,
    		batch_notes,
    		is_clicked_begin_collection,
    		is_clicked_end_collection,
    		ready_to_start_new_batch,
    		contaminant_details,
    		contaminant_boolean,
    		is_Clicked_cancel,
    		ready_to_end_collection,
    		ready_to_work,
    		fetching_images,
    		completed_batches,
    		onMount,
    		Button,
    		Dialog,
    		tick,
    		c_status,
    		send_start_batch,
    		collected_not_began_alert,
    		send_change_colour,
    		end_change_colour,
    		initialise_new_batch,
    		send_batch_number,
    		send_end_batch,
    		cancel_batch,
    		dialog_cancel_batch,
    		showDialog_Cancel_Batch,
    		$button_alert_change,
    		$ready_to_start_new_batch,
    		$batch_notes,
    		$completed_batches,
    		$batch_number,
    		$fetching_images,
    		$ready_to_end_batch,
    		$product_weight,
    		$product_container,
    		$product_type,
    		$machine_location,
    		$is_Clicked_end,
    		$is_Clicked_start,
    		$is_clicked_begin_collection,
    		$ready_to_work,
    		$batch_collection,
    		$is_Clicked_cancel
    	});

    	$$self.$inject_state = $$props => {
    		if ('c_status' in $$props) c_status = $$props.c_status;
    		if ('showDialog_Cancel_Batch' in $$props) $$invalidate(0, showDialog_Cancel_Batch = $$props.showDialog_Cancel_Batch);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showDialog_Cancel_Batch,
    		$button_alert_change,
    		$batch_number,
    		$fetching_images,
    		$is_Clicked_end,
    		$is_Clicked_start,
    		$is_clicked_begin_collection,
    		$ready_to_work,
    		$batch_collection,
    		$is_Clicked_cancel,
    		send_start_batch,
    		send_batch_number,
    		send_end_batch,
    		cancel_batch,
    		dialog_cancel_batch,
    		select1_change_handler,
    		select1_change_handler_1,
    		select1_change_handler_2,
    		select1_change_handler_3,
    		click_handler,
    		click_handler_1,
    		dialog_value_binding
    	];
    }

    class BatchRun extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BatchRun",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* src/Create/OpenBatchRun.svelte generated by Svelte v3.40.3 */
    const file$a = "src/Create/OpenBatchRun.svelte";

    // (15:4) {#if isOpen }
    function create_if_block_1$5(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "light",
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(15:4) {#if isOpen }",
    		ctx
    	});

    	return block;
    }

    // (16:4) <Button  size="lg"  color = "light"   on:click={handleClick} >
    function create_default_slot_2$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Batch Run");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(16:4) <Button  size=\\\"lg\\\"  color = \\\"light\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (20:0) {#if !isOpen }
    function create_if_block$6(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "info",
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(20:0) {#if !isOpen }",
    		ctx
    	});

    	return block;
    }

    // (21:4) <Button   size="lg"    color = "info"   on:click={handleClick} >
    function create_default_slot_1$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Batch Run");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(21:4) <Button   size=\\\"lg\\\"    color = \\\"info\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (28:4) <Fade {isOpen} >
    function create_default_slot$8(ctx) {
    	let div;
    	let batchrun;
    	let current;
    	batchrun = new BatchRun({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(batchrun.$$.fragment);
    			add_location(div, file$a, 29, 8, 678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(batchrun, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(batchrun.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(batchrun.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(batchrun);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(28:4) <Fade {isOpen} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let fade;
    	let current;
    	let if_block0 = /*isOpen*/ ctx[0] && create_if_block_1$5(ctx);
    	let if_block1 = !/*isOpen*/ ctx[0] && create_if_block$6(ctx);

    	fade = new Fade({
    			props: {
    				isOpen: /*isOpen*/ ctx[0],
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			create_component(fade.$$.fragment);
    			add_location(div0, file$a, 13, 0, 353);
    			attr_dev(div1, "class", "col-md-9  offset-md-2");
    			add_location(div1, file$a, 26, 0, 612);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(fade, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isOpen*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const fade_changes = {};
    			if (dirty & /*isOpen*/ 1) fade_changes.isOpen = /*isOpen*/ ctx[0];

    			if (dirty & /*$$scope*/ 4) {
    				fade_changes.$$scope = { dirty, ctx };
    			}

    			fade.$set(fade_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(fade.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(fade.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(fade);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OpenBatchRun', slots, []);
    	let isOpen = true;

    	function handleClick() {
    		$$invalidate(0, isOpen = !isOpen);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OpenBatchRun> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Fade,
    		Button: Button$1,
    		BatchRun,
    		isOpen,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isOpen, handleClick];
    }

    class OpenBatchRun extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OpenBatchRun",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    function zoom(node, scale = 1.5) {
    	node.style.transition = '1s';

    	function zoomIn(e) {
    		// node.style.transform = `scale(${scale})`
            node.style.transform = `rotate(90deg) scale(${scale})`;
            e.stopImmediatePropagation();
            this.removeEventListener("click", zoomIn);
            node.onclick = zoomOut;
    	}
    	function zoomOut(e) {
    		node.style.transform = 'scale(1)';
            e.stopImmediatePropagation();
            this.removeEventListener("click", zoomOut);
            node.onclick = zoomIn;
    	}
    	// node.addEventListener('mouseenter', zoomIn)
    	// node.addEventListener('mouseleave', zoomOut)
        node.addEventListener('click', zoomIn);
    	node.addEventListener('click', zoomOut);

    	return {
    		destroy() {
    			// node.removeEventListener('mouseenter', zoomIn)
    			// node.removeEventListener('mouseleave', zoomOut)
                node.addEventListener('click', zoomIn);
    	        node.addEventListener('click', zoomOut);
    		}
    	}
    }

    /* src/Create/UploadedSoFar.svelte generated by Svelte v3.40.3 */

    const { Object: Object_1, console: console_1$2 } = globals;
    const file$9 = "src/Create/UploadedSoFar.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[121] = list[i][0];
    	child_ctx[122] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[125] = list[i].batch_number;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[125] = list[i].batch_number;
    	return child_ctx;
    }

    function get_each_context_8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[125] = list[i].batch_number;
    	child_ctx[130] = list[i].machine_location;
    	child_ctx[131] = list[i].product_type;
    	child_ctx[132] = list[i].product_container;
    	child_ctx[133] = list[i].product_weight;
    	child_ctx[134] = list[i].contaminant_boolean;
    	child_ctx[135] = list[i].contaminant_details;
    	child_ctx[136] = list[i].voltage_kv;
    	child_ctx[137] = list[i].current_ma;
    	child_ctx[138] = list[i].build_date;
    	child_ctx[139] = list[i].soft_version;
    	child_ctx[140] = list[i].batch_notes;
    	child_ctx[141] = list[i].individual_images;
    	child_ctx[143] = list[i].first_image_dir;
    	child_ctx[158] = list[i].images_processed;
    	child_ctx[145] = i;
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[125] = list[i].batch_number;
    	child_ctx[130] = list[i].machine_location;
    	child_ctx[131] = list[i].product_type;
    	child_ctx[132] = list[i].product_container;
    	child_ctx[133] = list[i].product_weight;
    	child_ctx[134] = list[i].contaminant_boolean;
    	child_ctx[135] = list[i].contaminant_details;
    	child_ctx[136] = list[i].voltage_kv;
    	child_ctx[137] = list[i].current_ma;
    	child_ctx[138] = list[i].build_date;
    	child_ctx[139] = list[i].soft_version;
    	child_ctx[140] = list[i].batch_notes;
    	child_ctx[141] = list[i].individual_images;
    	child_ctx[142] = list[i].number_of_jobs_left;
    	child_ctx[143] = list[i].first_image_dir;
    	child_ctx[145] = i;
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[146] = list[i];
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[149] = list[i];
    	return child_ctx;
    }

    function get_each_context_6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[152] = list[i];
    	return child_ctx;
    }

    function get_each_context_7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[155] = list[i];
    	return child_ctx;
    }

    // (672:48) 
    function create_if_block_13$1(ctx) {
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let if_block1_anchor;
    	let current;
    	const if_block_creators = [create_if_block_20, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$batches_left_to_process*/ ctx[41]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*$completed_batches*/ ctx[5].length && create_if_block_14$1(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(t.parentNode, t);
    			}

    			if (/*$completed_batches*/ ctx[5].length) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*$completed_batches*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_14$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13$1.name,
    		type: "if",
    		source: "(672:48) ",
    		ctx
    	});

    	return block;
    }

    // (561:0) {#if !$collection_running && $ready_to_work }
    function create_if_block_8$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$collection_ids*/ ctx[35].length && create_if_block_9$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$collection_ids*/ ctx[35].length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[1] & /*$collection_ids*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_9$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(561:0) {#if !$collection_running && $ready_to_work }",
    		ctx
    	});

    	return block;
    }

    // (706:8) {:else}
    function create_else_block_2$1(ctx) {
    	let div1;
    	let div0;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				disabled: true,
    				$$slots: { default: [create_default_slot_17$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div0, "class", "col-md-2");
    			add_location(div0, file$9, 707, 10, 30773);
    			attr_dev(div1, "class", "row align-items-center ");
    			add_location(div1, file$9, 706, 8, 30725);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(button, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(706:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (673:8) {#if $batches_left_to_process}
    function create_if_block_20(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_21, create_if_block_22];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$fetching_images*/ ctx[42]) return 0;
    		if (!/*$fetching_images*/ ctx[42]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_3(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20.name,
    		type: "if",
    		source: "(673:8) {#if $batches_left_to_process}",
    		ctx
    	});

    	return block;
    }

    // (709:14) <Button  color = "blue"  disabled >
    function create_default_slot_17$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Process");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$1.name,
    		type: "slot",
    		source: "(709:14) <Button  color = \\\"blue\\\"  disabled >",
    		ctx
    	});

    	return block;
    }

    // (690:43) 
    function create_if_block_22(ctx) {
    	let div1;
    	let div0;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				$$slots: { default: [create_default_slot_16$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", process_batch_images);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div0, "class", "col-md-2");
    			add_location(div0, file$9, 691, 20, 29996);
    			attr_dev(div1, "class", "row align-items-center ");
    			add_location(div1, file$9, 690, 18, 29938);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(button, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22.name,
    		type: "if",
    		source: "(690:43) ",
    		ctx
    	});

    	return block;
    }

    // (674:14) {#if $fetching_images}
    function create_if_block_21(ctx) {
    	let div1;
    	let div0;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				disabled: true,
    				$$slots: { default: [create_default_slot_15$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div0, "class", "col-md-2");
    			add_location(div0, file$9, 675, 18, 29199);
    			attr_dev(div1, "class", "row align-items-center ");
    			add_location(div1, file$9, 674, 16, 29143);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(button, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21.name,
    		type: "if",
    		source: "(674:14) {#if $fetching_images}",
    		ctx
    	});

    	return block;
    }

    // (693:24) <Button  color = "blue" on:click={process_batch_images} >
    function create_default_slot_16$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Process");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$1.name,
    		type: "slot",
    		source: "(693:24) <Button  color = \\\"blue\\\" on:click={process_batch_images} >",
    		ctx
    	});

    	return block;
    }

    // (677:22) <Button  color = "blue" disabled >
    function create_default_slot_15$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Process");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$1.name,
    		type: "slot",
    		source: "(677:22) <Button  color = \\\"blue\\\" disabled >",
    		ctx
    	});

    	return block;
    }

    // (728:0) {#if $completed_batches.length }
    function create_if_block_14$1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_8 = /*$completed_batches*/ ctx[5];
    	validate_each_argument(each_value_8);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_8.length; i += 1) {
    		each_blocks[i] = create_each_block_8(get_each_context_8(ctx, each_value_8, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*get_all_images, $completed_batches*/ 33 | dirty[1] & /*open_batch_notes_modal, openDetailsModal, openImageModal, $create_mode_dir*/ 57472) {
    				each_value_8 = /*$completed_batches*/ ctx[5];
    				validate_each_argument(each_value_8);
    				let i;

    				for (i = 0; i < each_value_8.length; i += 1) {
    					const child_ctx = get_each_context_8(ctx, each_value_8, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_8.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_8.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14$1.name,
    		type: "if",
    		source: "(728:0) {#if $completed_batches.length }",
    		ctx
    	});

    	return block;
    }

    // (736:16) 
    function create_title_slot_1(ctx) {
    	let div;
    	let card_title;
    	let t;
    	let current;

    	card_title = new Card.Title({
    			props: {
    				title: "Batch No. " + /*batch_number*/ ctx[125],
    				classes: "text-center"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(card_title.$$.fragment);
    			t = space();
    			attr_dev(div, "slot", "title");
    			add_location(div, file$9, 735, 16, 31929);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(card_title, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_title_changes = {};
    			if (dirty[0] & /*$completed_batches*/ 32) card_title_changes.title = "Batch No. " + /*batch_number*/ ctx[125];
    			card_title.$set(card_title_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card_title.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card_title.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(card_title);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_1.name,
    		type: "slot",
    		source: "(736:16) ",
    		ctx
    	});

    	return block;
    }

    // (753:46) 
    function create_if_block_19(ctx) {
    	let div;
    	let h7;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h7 = element("h7");
    			h7.textContent = "Images ready to be processed";
    			add_location(h7, file$9, 753, 62, 32714);
    			attr_dev(div, "class", "w-auto h-64 text-center pt-24 ");
    			add_location(div, file$9, 753, 18, 32670);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h7);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(753:46) ",
    		ctx
    	});

    	return block;
    }

    // (746:18) {#if images_processed}
    function create_if_block_18(ctx) {
    	let image;
    	let current;

    	image = new Image_1({
    			props: {
    				class: "w-auto h-64",
    				src: /*$create_mode_dir*/ ctx[38].substring(15) + "/batch_" + /*batch_number*/ ctx[125] + "/All_Images/plain_jpgs/" + /*first_image_dir*/ ctx[143] + ".jpg"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(image.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(image, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const image_changes = {};
    			if (dirty[0] & /*$completed_batches*/ 32 | dirty[1] & /*$create_mode_dir*/ 128) image_changes.src = /*$create_mode_dir*/ ctx[38].substring(15) + "/batch_" + /*batch_number*/ ctx[125] + "/All_Images/plain_jpgs/" + /*first_image_dir*/ ctx[143] + ".jpg";
    			image.$set(image_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(image.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(image.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(image, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(746:18) {#if images_processed}",
    		ctx
    	});

    	return block;
    }

    // (744:16) 
    function create_media_slot_1(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_18, create_if_block_19];
    	const if_blocks = [];

    	function select_block_type_5(ctx, dirty) {
    		if (/*images_processed*/ ctx[158]) return 0;
    		if (!/*images_processed*/ ctx[158]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_5(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			attr_dev(div, "slot", "media");
    			add_location(div, file$9, 743, 16, 32168);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div, null);
    			}

    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*openImageModal*/ ctx[46](/*batch_number*/ ctx[125]))) /*openImageModal*/ ctx[46](/*batch_number*/ ctx[125]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_5(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(div, t);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot_1.name,
    		type: "slot",
    		source: "(744:16) ",
    		ctx
    	});

    	return block;
    }

    // (766:18) {#if contaminant_boolean==="Yes"}
    function create_if_block_17(ctx) {
    	let div;
    	let span0;
    	let span1;
    	let t1_value = /*contaminant_details*/ ctx[135] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Contaminant Details ";
    			span1 = element("span");
    			t1 = text(t1_value);
    			attr_dev(span0, "class", "subtitle-1");
    			add_location(span0, file$9, 766, 51, 33981);
    			attr_dev(span1, "class", "text-black dark:text-gray-100");
    			add_location(span1, file$9, 766, 103, 34033);
    			attr_dev(div, "class", "pb-1 line-clamp-1");
    			add_location(div, file$9, 766, 18, 33948);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, span1);
    			append_dev(span1, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$completed_batches*/ 32 && t1_value !== (t1_value = /*contaminant_details*/ ctx[135] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(766:18) {#if contaminant_boolean===\\\"Yes\\\"}",
    		ctx
    	});

    	return block;
    }

    // (769:18) {#if contaminant_boolean==="No"}
    function create_if_block_16$1(ctx) {
    	let div;
    	let br;

    	const block = {
    		c: function create() {
    			div = element("div");
    			br = element("br");
    			add_location(br, file$9, 770, 20, 34271);
    			attr_dev(div, "class", "pb-1 line-clamp-1 subtitle-1");
    			add_location(div, file$9, 769, 18, 34207);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, br);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16$1.name,
    		type: "if",
    		source: "(769:18) {#if contaminant_boolean===\\\"No\\\"}",
    		ctx
    	});

    	return block;
    }

    // (783:20) {:else}
    function create_else_block_1$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No Notes Yet";
    			attr_dev(div, "class", "text-gray-700 body-2 line-clamp-3");
    			add_location(div, file$9, 783, 20, 35406);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(783:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (781:20) {#if batch_notes}
    function create_if_block_15$1(ctx) {
    	let div;
    	let t_value = /*batch_notes*/ ctx[140] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "text-black dark:text-gray-100 line-clamp-3");
    			add_location(div, file$9, 781, 20, 35279);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$completed_batches*/ 32 && t_value !== (t_value = /*batch_notes*/ ctx[140] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15$1.name,
    		type: "if",
    		source: "(781:20) {#if batch_notes}",
    		ctx
    	});

    	return block;
    }

    // (759:16) 
    function create_text_slot_1(ctx) {
    	let div11;
    	let div9;
    	let div0;
    	let span0;
    	let span1;
    	let t1_value = /*machine_location*/ ctx[130] + "";
    	let t1;
    	let t2;
    	let div1;
    	let span2;
    	let span3;
    	let t4_value = /*product_type*/ ctx[131] + "";
    	let t4;
    	let t5;
    	let div2;
    	let span4;
    	let span5;
    	let t7_value = /*product_container*/ ctx[132] + "";
    	let t7;
    	let t8;
    	let div3;
    	let span6;
    	let span7;
    	let t10_value = /*product_weight*/ ctx[133] + "";
    	let t10;
    	let t11;
    	let div4;
    	let span8;
    	let span9;
    	let t13_value = /*contaminant_boolean*/ ctx[134] + "";
    	let t13;
    	let t14;
    	let t15;
    	let t16;
    	let div5;
    	let span10;
    	let span11;
    	let t18_value = /*build_date*/ ctx[138] + "";
    	let t18;
    	let t19;
    	let div6;
    	let span12;
    	let span13;
    	let t21_value = /*soft_version*/ ctx[139] + "";
    	let t21;
    	let t22;
    	let div7;
    	let span14;
    	let span15;
    	let t24_value = /*voltage_kv*/ ctx[136] + "";
    	let t24;
    	let t25;
    	let div8;
    	let span16;
    	let span17;
    	let t27_value = /*current_ma*/ ctx[137] + "";
    	let t27;
    	let t28;
    	let div10;
    	let h6;
    	let t30;
    	let t31;
    	let mounted;
    	let dispose;
    	let if_block0 = /*contaminant_boolean*/ ctx[134] === "Yes" && create_if_block_17(ctx);
    	let if_block1 = /*contaminant_boolean*/ ctx[134] === "No" && create_if_block_16$1(ctx);

    	function select_block_type_4(ctx, dirty) {
    		if (/*batch_notes*/ ctx[140]) return create_if_block_15$1;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type_4(ctx);
    	let if_block2 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div11 = element("div");
    			div9 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "Machine Location: ";
    			span1 = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			span2 = element("span");
    			span2.textContent = "Product Type: ";
    			span3 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			div2 = element("div");
    			span4 = element("span");
    			span4.textContent = "Product Container: ";
    			span5 = element("span");
    			t7 = text(t7_value);
    			t8 = space();
    			div3 = element("div");
    			span6 = element("span");
    			span6.textContent = "Product Weight (kg): ";
    			span7 = element("span");
    			t10 = text(t10_value);
    			t11 = space();
    			div4 = element("div");
    			span8 = element("span");
    			span8.textContent = "Contains Contaminants? ";
    			span9 = element("span");
    			t13 = text(t13_value);
    			t14 = space();
    			if (if_block0) if_block0.c();
    			t15 = space();
    			if (if_block1) if_block1.c();
    			t16 = space();
    			div5 = element("div");
    			span10 = element("span");
    			span10.textContent = "Build Date: ";
    			span11 = element("span");
    			t18 = text(t18_value);
    			t19 = space();
    			div6 = element("div");
    			span12 = element("span");
    			span12.textContent = "Software Version: ";
    			span13 = element("span");
    			t21 = text(t21_value);
    			t22 = space();
    			div7 = element("div");
    			span14 = element("span");
    			span14.textContent = "Voltage (kV): ";
    			span15 = element("span");
    			t24 = text(t24_value);
    			t25 = space();
    			div8 = element("div");
    			span16 = element("span");
    			span16.textContent = "Current (mA): ";
    			span17 = element("span");
    			t27 = text(t27_value);
    			t28 = space();
    			div10 = element("div");
    			h6 = element("h6");
    			h6.textContent = "Batch Notes:";
    			t30 = space();
    			if_block2.c();
    			t31 = space();
    			attr_dev(span0, "class", "subtitle-1");
    			add_location(span0, file$9, 760, 51, 33030);
    			attr_dev(span1, "class", "text-black dark:text-gray-100");
    			add_location(span1, file$9, 760, 101, 33080);
    			attr_dev(div0, "class", "pb-1 line-clamp-1");
    			add_location(div0, file$9, 760, 18, 32997);
    			attr_dev(span2, "class", "subtitle-1");
    			add_location(span2, file$9, 761, 51, 33210);
    			attr_dev(span3, "class", "text-black dark:text-gray-100");
    			add_location(span3, file$9, 761, 97, 33256);
    			attr_dev(div1, "class", "pb-1 line-clamp-1");
    			add_location(div1, file$9, 761, 18, 33177);
    			attr_dev(span4, "class", "subtitle-1");
    			add_location(span4, file$9, 762, 51, 33381);
    			attr_dev(span5, "class", "text-black dark:text-gray-100");
    			add_location(span5, file$9, 762, 102, 33432);
    			attr_dev(div2, "class", "pb-1 line-clamp-1");
    			add_location(div2, file$9, 762, 18, 33348);
    			attr_dev(span6, "class", "subtitle-1");
    			add_location(span6, file$9, 763, 51, 33562);
    			attr_dev(span7, "class", "text-black dark:text-gray-100");
    			add_location(span7, file$9, 763, 104, 33615);
    			attr_dev(div3, "class", "pb-1 line-clamp-1");
    			add_location(div3, file$9, 763, 18, 33529);
    			attr_dev(span8, "class", "subtitle-1");
    			add_location(span8, file$9, 764, 51, 33742);
    			attr_dev(span9, "class", "text-black dark:text-gray-100");
    			add_location(span9, file$9, 764, 106, 33797);
    			attr_dev(div4, "class", "pb-1 line-clamp-1");
    			add_location(div4, file$9, 764, 18, 33709);
    			attr_dev(span10, "class", "subtitle-1");
    			add_location(span10, file$9, 773, 51, 34377);
    			attr_dev(span11, "class", "text-black dark:text-gray-100");
    			add_location(span11, file$9, 773, 95, 34421);
    			attr_dev(div5, "class", "pb-1 line-clamp-1");
    			add_location(div5, file$9, 773, 18, 34344);
    			attr_dev(span12, "class", "subtitle-1");
    			add_location(span12, file$9, 774, 51, 34544);
    			attr_dev(span13, "class", "text-black dark:text-gray-100");
    			add_location(span13, file$9, 774, 101, 34594);
    			attr_dev(div6, "class", "pb-1 line-clamp-1");
    			add_location(div6, file$9, 774, 18, 34511);
    			attr_dev(span14, "class", "subtitle-1");
    			add_location(span14, file$9, 775, 51, 34719);
    			attr_dev(span15, "class", "text-black dark:text-gray-100");
    			add_location(span15, file$9, 775, 97, 34765);
    			attr_dev(div7, "class", "pb-1 line-clamp-1");
    			add_location(div7, file$9, 775, 18, 34686);
    			attr_dev(span16, "class", "subtitle-1");
    			add_location(span16, file$9, 776, 51, 34888);
    			attr_dev(span17, "class", "text-black dark:text-gray-100");
    			add_location(span17, file$9, 776, 97, 34934);
    			attr_dev(div8, "class", "pb-1 line-clamp-1");
    			add_location(div8, file$9, 776, 18, 34855);
    			add_location(div9, file$9, 759, 18, 32931);
    			attr_dev(h6, "class", "text-black dark:text-gray-100 svelte-133jb13");
    			add_location(h6, file$9, 779, 20, 35158);
    			attr_dev(div10, "class", " text-center p-2 pb-0 pt-3");
    			add_location(div10, file$9, 778, 18, 35048);
    			attr_dev(div11, "slot", "text");
    			attr_dev(div11, "class", "text-left  p-1 pb-0 pt-3 text-gray-700 body-2");
    			add_location(div11, file$9, 758, 16, 32840);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div9);
    			append_dev(div9, div0);
    			append_dev(div0, span0);
    			append_dev(div0, span1);
    			append_dev(span1, t1);
    			append_dev(div9, t2);
    			append_dev(div9, div1);
    			append_dev(div1, span2);
    			append_dev(div1, span3);
    			append_dev(span3, t4);
    			append_dev(div9, t5);
    			append_dev(div9, div2);
    			append_dev(div2, span4);
    			append_dev(div2, span5);
    			append_dev(span5, t7);
    			append_dev(div9, t8);
    			append_dev(div9, div3);
    			append_dev(div3, span6);
    			append_dev(div3, span7);
    			append_dev(span7, t10);
    			append_dev(div9, t11);
    			append_dev(div9, div4);
    			append_dev(div4, span8);
    			append_dev(div4, span9);
    			append_dev(span9, t13);
    			append_dev(div9, t14);
    			if (if_block0) if_block0.m(div9, null);
    			append_dev(div9, t15);
    			if (if_block1) if_block1.m(div9, null);
    			append_dev(div9, t16);
    			append_dev(div9, div5);
    			append_dev(div5, span10);
    			append_dev(div5, span11);
    			append_dev(span11, t18);
    			append_dev(div9, t19);
    			append_dev(div9, div6);
    			append_dev(div6, span12);
    			append_dev(div6, span13);
    			append_dev(span13, t21);
    			append_dev(div9, t22);
    			append_dev(div9, div7);
    			append_dev(div7, span14);
    			append_dev(div7, span15);
    			append_dev(span15, t24);
    			append_dev(div9, t25);
    			append_dev(div9, div8);
    			append_dev(div8, span16);
    			append_dev(div8, span17);
    			append_dev(span17, t27);
    			append_dev(div11, t28);
    			append_dev(div11, div10);
    			append_dev(div10, h6);
    			append_dev(div10, t30);
    			if_block2.m(div10, null);
    			append_dev(div11, t31);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						div9,
    						"click",
    						function () {
    							if (is_function(/*openDetailsModal*/ ctx[44](/*batch_number*/ ctx[125]))) /*openDetailsModal*/ ctx[44](/*batch_number*/ ctx[125]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div10,
    						"click",
    						function () {
    							if (is_function(/*open_batch_notes_modal*/ ctx[45](/*batch_number*/ ctx[125]))) /*open_batch_notes_modal*/ ctx[45](/*batch_number*/ ctx[125]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*$completed_batches*/ 32 && t1_value !== (t1_value = /*machine_location*/ ctx[130] + "")) set_data_dev(t1, t1_value);
    			if (dirty[0] & /*$completed_batches*/ 32 && t4_value !== (t4_value = /*product_type*/ ctx[131] + "")) set_data_dev(t4, t4_value);
    			if (dirty[0] & /*$completed_batches*/ 32 && t7_value !== (t7_value = /*product_container*/ ctx[132] + "")) set_data_dev(t7, t7_value);
    			if (dirty[0] & /*$completed_batches*/ 32 && t10_value !== (t10_value = /*product_weight*/ ctx[133] + "")) set_data_dev(t10, t10_value);
    			if (dirty[0] & /*$completed_batches*/ 32 && t13_value !== (t13_value = /*contaminant_boolean*/ ctx[134] + "")) set_data_dev(t13, t13_value);

    			if (/*contaminant_boolean*/ ctx[134] === "Yes") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_17(ctx);
    					if_block0.c();
    					if_block0.m(div9, t15);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*contaminant_boolean*/ ctx[134] === "No") {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_16$1(ctx);
    					if_block1.c();
    					if_block1.m(div9, t16);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*$completed_batches*/ 32 && t18_value !== (t18_value = /*build_date*/ ctx[138] + "")) set_data_dev(t18, t18_value);
    			if (dirty[0] & /*$completed_batches*/ 32 && t21_value !== (t21_value = /*soft_version*/ ctx[139] + "")) set_data_dev(t21, t21_value);
    			if (dirty[0] & /*$completed_batches*/ 32 && t24_value !== (t24_value = /*voltage_kv*/ ctx[136] + "")) set_data_dev(t24, t24_value);
    			if (dirty[0] & /*$completed_batches*/ 32 && t27_value !== (t27_value = /*current_ma*/ ctx[137] + "")) set_data_dev(t27, t27_value);

    			if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div10, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div11);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_text_slot_1.name,
    		type: "slot",
    		source: "(759:16) ",
    		ctx
    	});

    	return block;
    }

    // (729:4) {#each $completed_batches as { batch_number, machine_location, product_type,       product_container, product_weight,contaminant_boolean, contaminant_details,       voltage_kv, current_ma, build_date, soft_version, batch_notes, individual_images,        first_image_dir, images_processed}
    function create_each_block_8(ctx) {
    	let card_card;
    	let current;

    	function change_handler_5() {
    		return /*change_handler_5*/ ctx[78](/*batch_number*/ ctx[125]);
    	}

    	card_card = new Card.Card({
    			props: {
    				class: "h-auto w-1/4 m-4 p-2",
    				$$slots: {
    					text: [create_text_slot_1],
    					media: [create_media_slot_1],
    					title: [create_title_slot_1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card_card.$on("change", change_handler_5);

    	const block = {
    		c: function create() {
    			create_component(card_card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card_card, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const card_card_changes = {};

    			if (dirty[0] & /*$completed_batches*/ 32 | dirty[1] & /*$create_mode_dir*/ 128 | dirty[5] & /*$$scope*/ 32) {
    				card_card_changes.$$scope = { dirty, ctx };
    			}

    			card_card.$set(card_card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card_card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card_card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card_card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_8.name,
    		type: "each",
    		source: "(729:4) {#each $completed_batches as { batch_number, machine_location, product_type,       product_container, product_weight,contaminant_boolean, contaminant_details,       voltage_kv, current_ma, build_date, soft_version, batch_notes, individual_images,        first_image_dir, images_processed}",
    		ctx
    	});

    	return block;
    }

    // (563:8) {#if $collection_ids.length }
    function create_if_block_9$1(ctx) {
    	let div4;
    	let div0;
    	let textfield0;
    	let updating_value;
    	let t0;
    	let select1;
    	let select0;
    	let t1;
    	let div1;
    	let textfield1;
    	let updating_value_1;
    	let t2;
    	let select3;
    	let select2;
    	let t3;
    	let div2;
    	let textfield2;
    	let updating_value_2;
    	let t4;
    	let select5;
    	let select4;
    	let t5;
    	let div3;
    	let select7;
    	let select6;
    	let t6;
    	let each4_anchor;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[63](value);
    	}

    	let textfield0_props = {
    		label: "Search Company",
    		color: "blue",
    		outlined: true
    	};

    	if (/*$local_company_search_term*/ ctx[31] !== void 0) {
    		textfield0_props.value = /*$local_company_search_term*/ ctx[31];
    	}

    	textfield0 = new TextField({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));
    	textfield0.$on("input", /*input_handler*/ ctx[64]);
    	let each_value_7 = /*$matching_local_company_names*/ ctx[30];
    	validate_each_argument(each_value_7);
    	let each_blocks_4 = [];

    	for (let i = 0; i < each_value_7.length; i += 1) {
    		each_blocks_4[i] = create_each_block_7(get_each_context_7(ctx, each_value_7, i));
    	}

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[67](value);
    	}

    	let textfield1_props = {
    		label: "Search Product",
    		color: "blue",
    		outlined: true
    	};

    	if (/*$local_product_search_term*/ ctx[28] !== void 0) {
    		textfield1_props.value = /*$local_product_search_term*/ ctx[28];
    	}

    	textfield1 = new TextField({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));
    	textfield1.$on("input", /*input_handler_1*/ ctx[68]);
    	let each_value_6 = /*$matching_local_product_names*/ ctx[27];
    	validate_each_argument(each_value_6);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_6.length; i += 1) {
    		each_blocks_3[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
    	}

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[71](value);
    	}

    	let textfield2_props = {
    		label: "Search User",
    		color: "blue",
    		outlined: true
    	};

    	if (/*$local_user_search_term*/ ctx[25] !== void 0) {
    		textfield2_props.value = /*$local_user_search_term*/ ctx[25];
    	}

    	textfield2 = new TextField({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));
    	textfield2.$on("input", /*input_handler_2*/ ctx[72]);
    	let each_value_5 = /*$matching_local_user_names*/ ctx[24];
    	validate_each_argument(each_value_5);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks_2[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	let each_value_4 = /*$matching_local_collection_ids*/ ctx[34];
    	validate_each_argument(each_value_4);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks_1[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	let each_value_3 = /*$completed_collection*/ ctx[36];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			create_component(textfield0.$$.fragment);
    			t0 = space();
    			select1 = element("select");

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].c();
    			}

    			select0 = element("select");
    			t1 = space();
    			div1 = element("div");
    			create_component(textfield1.$$.fragment);
    			t2 = space();
    			select3 = element("select");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			select2 = element("select");
    			t3 = space();
    			div2 = element("div");
    			create_component(textfield2.$$.fragment);
    			t4 = space();
    			select5 = element("select");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			select4 = element("select");
    			t5 = space();
    			div3 = element("div");
    			select7 = element("select");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			select6 = element("select");
    			t6 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each4_anchor = empty();
    			add_location(select0, file$9, 574, 18, 22507);
    			if (/*$local_company_selection*/ ctx[29] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[65].call(select1));
    			add_location(select1, file$9, 570, 18, 22174);
    			attr_dev(div0, "class", "col-md-2");
    			add_location(div0, file$9, 566, 14, 21892);
    			add_location(select2, file$9, 589, 16, 23464);
    			if (/*$local_product_selection*/ ctx[26] === void 0) add_render_callback(() => /*select3_change_handler*/ ctx[69].call(select3));
    			add_location(select3, file$9, 585, 16, 23139);
    			attr_dev(div1, "class", "col-md-2");
    			add_location(div1, file$9, 581, 14, 22863);
    			add_location(select4, file$9, 600, 18, 24096);
    			if (/*$local_user_selection*/ ctx[23] === void 0) add_render_callback(() => /*select5_change_handler*/ ctx[73].call(select5));
    			add_location(select5, file$9, 596, 18, 23781);
    			attr_dev(div2, "class", "col-md-2");
    			add_location(div2, file$9, 592, 14, 23510);
    			add_location(select6, file$9, 610, 16, 24558);
    			if (/*$local_collection_id*/ ctx[33] === void 0) add_render_callback(() => /*select7_change_handler*/ ctx[75].call(select7));
    			add_location(select7, file$9, 606, 16, 24250);
    			attr_dev(div3, "class", "col-md-2 offset-md-1");
    			add_location(div3, file$9, 603, 14, 24141);
    			attr_dev(div4, "class", "row align-items-center ");
    			add_location(div4, file$9, 564, 8, 21838);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			mount_component(textfield0, div0, null);
    			append_dev(div0, t0);
    			append_dev(div0, select1);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].m(select1, null);
    			}

    			append_dev(select1, select0);
    			select_option(select1, /*$local_company_selection*/ ctx[29]);
    			append_dev(div4, t1);
    			append_dev(div4, div1);
    			mount_component(textfield1, div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, select3);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(select3, null);
    			}

    			append_dev(select3, select2);
    			select_option(select3, /*$local_product_selection*/ ctx[26]);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			mount_component(textfield2, div2, null);
    			append_dev(div2, t4);
    			append_dev(div2, select5);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(select5, null);
    			}

    			append_dev(select5, select4);
    			select_option(select5, /*$local_user_selection*/ ctx[23]);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			append_dev(div3, select7);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select7, null);
    			}

    			append_dev(select7, select6);
    			select_option(select7, /*$local_collection_id*/ ctx[33]);
    			insert_dev(target, t6, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each4_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[65]),
    					listen_dev(select1, "change", /*change_handler*/ ctx[66], false, false, false),
    					listen_dev(select3, "change", /*select3_change_handler*/ ctx[69]),
    					listen_dev(select3, "change", /*change_handler_1*/ ctx[70], false, false, false),
    					listen_dev(select5, "change", /*select5_change_handler*/ ctx[73]),
    					listen_dev(select5, "change", /*change_handler_2*/ ctx[74], false, false, false),
    					listen_dev(select7, "change", /*select7_change_handler*/ ctx[75]),
    					listen_dev(select7, "change", /*change_handler_3*/ ctx[76], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty[1] & /*$local_company_search_term*/ 1) {
    				updating_value = true;
    				textfield0_changes.value = /*$local_company_search_term*/ ctx[31];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);

    			if (dirty[0] & /*$matching_local_company_names*/ 1073741824) {
    				each_value_7 = /*$matching_local_company_names*/ ctx[30];
    				validate_each_argument(each_value_7);
    				let i;

    				for (i = 0; i < each_value_7.length; i += 1) {
    					const child_ctx = get_each_context_7(ctx, each_value_7, i);

    					if (each_blocks_4[i]) {
    						each_blocks_4[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_4[i] = create_each_block_7(child_ctx);
    						each_blocks_4[i].c();
    						each_blocks_4[i].m(select1, select0);
    					}
    				}

    				for (; i < each_blocks_4.length; i += 1) {
    					each_blocks_4[i].d(1);
    				}

    				each_blocks_4.length = each_value_7.length;
    			}

    			if (dirty[0] & /*$local_company_selection, $matching_local_company_names*/ 1610612736) {
    				select_option(select1, /*$local_company_selection*/ ctx[29]);
    			}

    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty[0] & /*$local_product_search_term*/ 268435456) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*$local_product_search_term*/ ctx[28];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);

    			if (dirty[0] & /*$matching_local_product_names*/ 134217728) {
    				each_value_6 = /*$matching_local_product_names*/ ctx[27];
    				validate_each_argument(each_value_6);
    				let i;

    				for (i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6(ctx, each_value_6, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_6(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(select3, select2);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_6.length;
    			}

    			if (dirty[0] & /*$local_product_selection, $matching_local_product_names*/ 201326592) {
    				select_option(select3, /*$local_product_selection*/ ctx[26]);
    			}

    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty[0] & /*$local_user_search_term*/ 33554432) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*$local_user_search_term*/ ctx[25];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);

    			if (dirty[0] & /*$matching_local_user_names*/ 16777216) {
    				each_value_5 = /*$matching_local_user_names*/ ctx[24];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_5(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(select5, select4);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_5.length;
    			}

    			if (dirty[0] & /*$local_user_selection, $matching_local_user_names*/ 25165824) {
    				select_option(select5, /*$local_user_selection*/ ctx[23]);
    			}

    			if (dirty[1] & /*$matching_local_collection_ids*/ 8) {
    				each_value_4 = /*$matching_local_collection_ids*/ ctx[34];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_4(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select7, select6);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_4.length;
    			}

    			if (dirty[1] & /*$local_collection_id, $matching_local_collection_ids*/ 12) {
    				select_option(select7, /*$local_collection_id*/ ctx[33]);
    			}

    			if (dirty[0] & /*get_all_images*/ 1 | dirty[1] & /*$completed_collection, open_batch_notes_modal, openImageModal, $create_mode_dir, $local_collection_id*/ 49316) {
    				each_value_3 = /*$completed_collection*/ ctx[36];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each4_anchor.parentNode, each4_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(textfield0);
    			destroy_each(each_blocks_4, detaching);
    			destroy_component(textfield1);
    			destroy_each(each_blocks_3, detaching);
    			destroy_component(textfield2);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each4_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(563:8) {#if $collection_ids.length }",
    		ctx
    	});

    	return block;
    }

    // (572:22) {#each $matching_local_company_names as local_company_selection}
    function create_each_block_7(ctx) {
    	let option;
    	let t_value = /*local_company_selection*/ ctx[155] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*local_company_selection*/ ctx[155];
    			option.value = option.__value;
    			add_location(option, file$9, 572, 24, 22382);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$matching_local_company_names*/ 1073741824 && t_value !== (t_value = /*local_company_selection*/ ctx[155] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$matching_local_company_names*/ 1073741824 && option_value_value !== (option_value_value = /*local_company_selection*/ ctx[155])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_7.name,
    		type: "each",
    		source: "(572:22) {#each $matching_local_company_names as local_company_selection}",
    		ctx
    	});

    	return block;
    }

    // (587:20) {#each $matching_local_product_names as local_product_selection}
    function create_each_block_6(ctx) {
    	let option;
    	let t_value = /*local_product_selection*/ ctx[152] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*local_product_selection*/ ctx[152];
    			option.value = option.__value;
    			add_location(option, file$9, 587, 22, 23343);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$matching_local_product_names*/ 134217728 && t_value !== (t_value = /*local_product_selection*/ ctx[152] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$matching_local_product_names*/ 134217728 && option_value_value !== (option_value_value = /*local_product_selection*/ ctx[152])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_6.name,
    		type: "each",
    		source: "(587:20) {#each $matching_local_product_names as local_product_selection}",
    		ctx
    	});

    	return block;
    }

    // (598:22) {#each $matching_local_user_names as local_user_selection}
    function create_each_block_5(ctx) {
    	let option;
    	let t_value = /*local_user_selection*/ ctx[149] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*local_user_selection*/ ctx[149];
    			option.value = option.__value;
    			add_location(option, file$9, 598, 24, 23977);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$matching_local_user_names*/ 16777216 && t_value !== (t_value = /*local_user_selection*/ ctx[149] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$matching_local_user_names*/ 16777216 && option_value_value !== (option_value_value = /*local_user_selection*/ ctx[149])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(598:22) {#each $matching_local_user_names as local_user_selection}",
    		ctx
    	});

    	return block;
    }

    // (608:20) {#each $matching_local_collection_ids as collection_id}
    function create_each_block_4(ctx) {
    	let option;
    	let t_value = /*collection_id*/ ctx[146] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*collection_id*/ ctx[146];
    			option.value = option.__value;
    			add_location(option, file$9, 608, 22, 24457);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*$matching_local_collection_ids*/ 8 && t_value !== (t_value = /*collection_id*/ ctx[146] + "")) set_data_dev(t, t_value);

    			if (dirty[1] & /*$matching_local_collection_ids*/ 8 && option_value_value !== (option_value_value = /*collection_id*/ ctx[146])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(608:20) {#each $matching_local_collection_ids as collection_id}",
    		ctx
    	});

    	return block;
    }

    // (620:24) 
    function create_title_slot(ctx) {
    	let div;
    	let card_title;
    	let t;
    	let current;

    	card_title = new Card.Title({
    			props: {
    				title: "Batch No. " + /*batch_number*/ ctx[125],
    				classes: "text-center"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(card_title.$$.fragment);
    			t = space();
    			attr_dev(div, "slot", "title");
    			add_location(div, file$9, 619, 24, 25105);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(card_title, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_title_changes = {};
    			if (dirty[1] & /*$completed_collection*/ 32) card_title_changes.title = "Batch No. " + /*batch_number*/ ctx[125];
    			card_title.$set(card_title_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card_title.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card_title.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(card_title);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot.name,
    		type: "slot",
    		source: "(620:24) ",
    		ctx
    	});

    	return block;
    }

    // (628:24) 
    function create_media_slot(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t = space();
    			attr_dev(img, "class", "w-auto h-64");
    			attr_dev(img, "alt", "Something went wrong...");
    			if (!src_url_equal(img.src, img_src_value = /*$create_mode_dir*/ ctx[38].substring(15, 26) + "temp_collections/" + /*$local_collection_id*/ ctx[33] + "/batch_" + /*batch_number*/ ctx[125] + "/All_Images/plain_jpgs/" + /*first_image_dir*/ ctx[143] + ".jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "loading", "eager");
    			add_location(img, file$9, 629, 26, 25563);
    			attr_dev(div, "slot", "media");
    			add_location(div, file$9, 627, 24, 25404);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*openImageModal*/ ctx[46](/*batch_number*/ ctx[125]))) /*openImageModal*/ ctx[46](/*batch_number*/ ctx[125]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[1] & /*$create_mode_dir, $local_collection_id, $completed_collection, $matching_local_collection_ids*/ 172 && !src_url_equal(img.src, img_src_value = /*$create_mode_dir*/ ctx[38].substring(15, 26) + "temp_collections/" + /*$local_collection_id*/ ctx[33] + "/batch_" + /*batch_number*/ ctx[125] + "/All_Images/plain_jpgs/" + /*first_image_dir*/ ctx[143] + ".jpg")) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot.name,
    		type: "slot",
    		source: "(628:24) ",
    		ctx
    	});

    	return block;
    }

    // (644:26) {#if contaminant_boolean==="Yes"}
    function create_if_block_12$1(ctx) {
    	let div;
    	let span0;
    	let span1;
    	let t1_value = /*contaminant_details*/ ctx[135] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Contaminant Details ";
    			span1 = element("span");
    			t1 = text(t1_value);
    			attr_dev(span0, "class", "subtitle-1");
    			add_location(span0, file$9, 644, 59, 27144);
    			attr_dev(span1, "class", "text-black dark:text-gray-100");
    			add_location(span1, file$9, 644, 111, 27196);
    			attr_dev(div, "class", "pb-1 line-clamp-1");
    			add_location(div, file$9, 644, 26, 27111);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, span1);
    			append_dev(span1, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*$completed_collection*/ 32 && t1_value !== (t1_value = /*contaminant_details*/ ctx[135] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$1.name,
    		type: "if",
    		source: "(644:26) {#if contaminant_boolean===\\\"Yes\\\"}",
    		ctx
    	});

    	return block;
    }

    // (647:26) {#if contaminant_boolean==="No"}
    function create_if_block_11$1(ctx) {
    	let div;
    	let br;

    	const block = {
    		c: function create() {
    			div = element("div");
    			br = element("br");
    			add_location(br, file$9, 648, 28, 27466);
    			attr_dev(div, "class", "pb-1 line-clamp-1 subtitle-1");
    			add_location(div, file$9, 647, 26, 27394);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, br);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$1.name,
    		type: "if",
    		source: "(647:26) {#if contaminant_boolean===\\\"No\\\"}",
    		ctx
    	});

    	return block;
    }

    // (661:28) {:else}
    function create_else_block$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No Notes Yet";
    			attr_dev(div, "class", "text-gray-700 body-2 line-clamp-3");
    			add_location(div, file$9, 661, 28, 28682);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(661:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (659:28) {#if batch_notes}
    function create_if_block_10$1(ctx) {
    	let div;
    	let t_value = /*batch_notes*/ ctx[140] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "text-black dark:text-gray-100 line-clamp-3");
    			add_location(div, file$9, 659, 28, 28539);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*$completed_collection*/ 32 && t_value !== (t_value = /*batch_notes*/ ctx[140] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(659:28) {#if batch_notes}",
    		ctx
    	});

    	return block;
    }

    // (638:24) 
    function create_text_slot(ctx) {
    	let div10;
    	let div0;
    	let span0;
    	let span1;
    	let t1_value = /*machine_location*/ ctx[130] + "";
    	let t1;
    	let t2;
    	let div1;
    	let span2;
    	let span3;
    	let t4_value = /*product_type*/ ctx[131] + "";
    	let t4;
    	let t5;
    	let div2;
    	let span4;
    	let span5;
    	let t7_value = /*product_container*/ ctx[132] + "";
    	let t7;
    	let t8;
    	let div3;
    	let span6;
    	let span7;
    	let t10_value = /*product_weight*/ ctx[133] + "";
    	let t10;
    	let t11;
    	let div4;
    	let span8;
    	let span9;
    	let t13_value = /*contaminant_boolean*/ ctx[134] + "";
    	let t13;
    	let t14;
    	let t15;
    	let t16;
    	let div5;
    	let span10;
    	let span11;
    	let t18_value = /*build_date*/ ctx[138] + "";
    	let t18;
    	let t19;
    	let div6;
    	let span12;
    	let span13;
    	let t21_value = /*soft_version*/ ctx[139] + "";
    	let t21;
    	let t22;
    	let div7;
    	let span14;
    	let span15;
    	let t24_value = /*voltage_kv*/ ctx[136] + "";
    	let t24;
    	let t25;
    	let div8;
    	let span16;
    	let span17;
    	let t27_value = /*current_ma*/ ctx[137] + "";
    	let t27;
    	let t28;
    	let div9;
    	let h6;
    	let t30;
    	let t31;
    	let mounted;
    	let dispose;
    	let if_block0 = /*contaminant_boolean*/ ctx[134] === "Yes" && create_if_block_12$1(ctx);
    	let if_block1 = /*contaminant_boolean*/ ctx[134] === "No" && create_if_block_11$1(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*batch_notes*/ ctx[140]) return create_if_block_10$1;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block2 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "Machine Location: ";
    			span1 = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			span2 = element("span");
    			span2.textContent = "Product Type: ";
    			span3 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			div2 = element("div");
    			span4 = element("span");
    			span4.textContent = "Product Container: ";
    			span5 = element("span");
    			t7 = text(t7_value);
    			t8 = space();
    			div3 = element("div");
    			span6 = element("span");
    			span6.textContent = "Product Weight (kg): ";
    			span7 = element("span");
    			t10 = text(t10_value);
    			t11 = space();
    			div4 = element("div");
    			span8 = element("span");
    			span8.textContent = "Contains Contaminants? ";
    			span9 = element("span");
    			t13 = text(t13_value);
    			t14 = space();
    			if (if_block0) if_block0.c();
    			t15 = space();
    			if (if_block1) if_block1.c();
    			t16 = space();
    			div5 = element("div");
    			span10 = element("span");
    			span10.textContent = "Build Date: ";
    			span11 = element("span");
    			t18 = text(t18_value);
    			t19 = space();
    			div6 = element("div");
    			span12 = element("span");
    			span12.textContent = "Software Version: ";
    			span13 = element("span");
    			t21 = text(t21_value);
    			t22 = space();
    			div7 = element("div");
    			span14 = element("span");
    			span14.textContent = "Voltage (kV): ";
    			span15 = element("span");
    			t24 = text(t24_value);
    			t25 = space();
    			div8 = element("div");
    			span16 = element("span");
    			span16.textContent = "Current (mA): ";
    			span17 = element("span");
    			t27 = text(t27_value);
    			t28 = space();
    			div9 = element("div");
    			h6 = element("h6");
    			h6.textContent = "Batch Notes:";
    			t30 = space();
    			if_block2.c();
    			t31 = space();
    			attr_dev(span0, "class", "subtitle-1");
    			add_location(span0, file$9, 638, 59, 26145);
    			attr_dev(span1, "class", "text-black dark:text-gray-100");
    			add_location(span1, file$9, 638, 109, 26195);
    			attr_dev(div0, "class", "pb-1 line-clamp-1");
    			add_location(div0, file$9, 638, 26, 26112);
    			attr_dev(span2, "class", "subtitle-1");
    			add_location(span2, file$9, 639, 59, 26333);
    			attr_dev(span3, "class", "text-black dark:text-gray-100");
    			add_location(span3, file$9, 639, 105, 26379);
    			attr_dev(div1, "class", "pb-1 line-clamp-1");
    			add_location(div1, file$9, 639, 26, 26300);
    			attr_dev(span4, "class", "subtitle-1");
    			add_location(span4, file$9, 640, 59, 26512);
    			attr_dev(span5, "class", "text-black dark:text-gray-100");
    			add_location(span5, file$9, 640, 110, 26563);
    			attr_dev(div2, "class", "pb-1 line-clamp-1");
    			add_location(div2, file$9, 640, 26, 26479);
    			attr_dev(span6, "class", "subtitle-1");
    			add_location(span6, file$9, 641, 59, 26701);
    			attr_dev(span7, "class", "text-black dark:text-gray-100");
    			add_location(span7, file$9, 641, 112, 26754);
    			attr_dev(div3, "class", "pb-1 line-clamp-1");
    			add_location(div3, file$9, 641, 26, 26668);
    			attr_dev(span8, "class", "subtitle-1");
    			add_location(span8, file$9, 642, 59, 26889);
    			attr_dev(span9, "class", "text-black dark:text-gray-100");
    			add_location(span9, file$9, 642, 114, 26944);
    			attr_dev(div4, "class", "pb-1 line-clamp-1");
    			add_location(div4, file$9, 642, 26, 26856);
    			attr_dev(span10, "class", "subtitle-1");
    			add_location(span10, file$9, 651, 59, 27596);
    			attr_dev(span11, "class", "text-black dark:text-gray-100");
    			add_location(span11, file$9, 651, 103, 27640);
    			attr_dev(div5, "class", "pb-1 line-clamp-1");
    			add_location(div5, file$9, 651, 26, 27563);
    			attr_dev(span12, "class", "subtitle-1");
    			add_location(span12, file$9, 652, 59, 27771);
    			attr_dev(span13, "class", "text-black dark:text-gray-100");
    			add_location(span13, file$9, 652, 109, 27821);
    			attr_dev(div6, "class", "pb-1 line-clamp-1");
    			add_location(div6, file$9, 652, 26, 27738);
    			attr_dev(span14, "class", "subtitle-1");
    			add_location(span14, file$9, 653, 59, 27954);
    			attr_dev(span15, "class", "text-black dark:text-gray-100");
    			add_location(span15, file$9, 653, 105, 28000);
    			attr_dev(div7, "class", "pb-1 line-clamp-1");
    			add_location(div7, file$9, 653, 26, 27921);
    			attr_dev(span16, "class", "subtitle-1");
    			add_location(span16, file$9, 654, 59, 28131);
    			attr_dev(span17, "class", "text-black dark:text-gray-100");
    			add_location(span17, file$9, 654, 105, 28177);
    			attr_dev(div8, "class", "pb-1 line-clamp-1");
    			add_location(div8, file$9, 654, 26, 28098);
    			attr_dev(h6, "class", "text-black dark:text-gray-100 svelte-133jb13");
    			add_location(h6, file$9, 657, 28, 28402);
    			attr_dev(div9, "class", " text-center p-2 pb-0 pt-3");
    			add_location(div9, file$9, 656, 26, 28284);
    			attr_dev(div10, "slot", "text");
    			attr_dev(div10, "class", "text-left  p-1 pb-0 pt-3 text-gray-700 body-2");
    			add_location(div10, file$9, 637, 24, 26013);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div0);
    			append_dev(div0, span0);
    			append_dev(div0, span1);
    			append_dev(span1, t1);
    			append_dev(div10, t2);
    			append_dev(div10, div1);
    			append_dev(div1, span2);
    			append_dev(div1, span3);
    			append_dev(span3, t4);
    			append_dev(div10, t5);
    			append_dev(div10, div2);
    			append_dev(div2, span4);
    			append_dev(div2, span5);
    			append_dev(span5, t7);
    			append_dev(div10, t8);
    			append_dev(div10, div3);
    			append_dev(div3, span6);
    			append_dev(div3, span7);
    			append_dev(span7, t10);
    			append_dev(div10, t11);
    			append_dev(div10, div4);
    			append_dev(div4, span8);
    			append_dev(div4, span9);
    			append_dev(span9, t13);
    			append_dev(div10, t14);
    			if (if_block0) if_block0.m(div10, null);
    			append_dev(div10, t15);
    			if (if_block1) if_block1.m(div10, null);
    			append_dev(div10, t16);
    			append_dev(div10, div5);
    			append_dev(div5, span10);
    			append_dev(div5, span11);
    			append_dev(span11, t18);
    			append_dev(div10, t19);
    			append_dev(div10, div6);
    			append_dev(div6, span12);
    			append_dev(div6, span13);
    			append_dev(span13, t21);
    			append_dev(div10, t22);
    			append_dev(div10, div7);
    			append_dev(div7, span14);
    			append_dev(div7, span15);
    			append_dev(span15, t24);
    			append_dev(div10, t25);
    			append_dev(div10, div8);
    			append_dev(div8, span16);
    			append_dev(div8, span17);
    			append_dev(span17, t27);
    			append_dev(div10, t28);
    			append_dev(div10, div9);
    			append_dev(div9, h6);
    			append_dev(div9, t30);
    			if_block2.m(div9, null);
    			append_dev(div10, t31);

    			if (!mounted) {
    				dispose = listen_dev(
    					div9,
    					"click",
    					function () {
    						if (is_function(/*open_batch_notes_modal*/ ctx[45](/*batch_number*/ ctx[125]))) /*open_batch_notes_modal*/ ctx[45](/*batch_number*/ ctx[125]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[1] & /*$completed_collection*/ 32 && t1_value !== (t1_value = /*machine_location*/ ctx[130] + "")) set_data_dev(t1, t1_value);
    			if (dirty[1] & /*$completed_collection*/ 32 && t4_value !== (t4_value = /*product_type*/ ctx[131] + "")) set_data_dev(t4, t4_value);
    			if (dirty[1] & /*$completed_collection*/ 32 && t7_value !== (t7_value = /*product_container*/ ctx[132] + "")) set_data_dev(t7, t7_value);
    			if (dirty[1] & /*$completed_collection*/ 32 && t10_value !== (t10_value = /*product_weight*/ ctx[133] + "")) set_data_dev(t10, t10_value);
    			if (dirty[1] & /*$completed_collection*/ 32 && t13_value !== (t13_value = /*contaminant_boolean*/ ctx[134] + "")) set_data_dev(t13, t13_value);

    			if (/*contaminant_boolean*/ ctx[134] === "Yes") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_12$1(ctx);
    					if_block0.c();
    					if_block0.m(div10, t15);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*contaminant_boolean*/ ctx[134] === "No") {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_11$1(ctx);
    					if_block1.c();
    					if_block1.m(div10, t16);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[1] & /*$completed_collection*/ 32 && t18_value !== (t18_value = /*build_date*/ ctx[138] + "")) set_data_dev(t18, t18_value);
    			if (dirty[1] & /*$completed_collection*/ 32 && t21_value !== (t21_value = /*soft_version*/ ctx[139] + "")) set_data_dev(t21, t21_value);
    			if (dirty[1] & /*$completed_collection*/ 32 && t24_value !== (t24_value = /*voltage_kv*/ ctx[136] + "")) set_data_dev(t24, t24_value);
    			if (dirty[1] & /*$completed_collection*/ 32 && t27_value !== (t27_value = /*current_ma*/ ctx[137] + "")) set_data_dev(t27, t27_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div9, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_block2.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_text_slot.name,
    		type: "slot",
    		source: "(638:24) ",
    		ctx
    	});

    	return block;
    }

    // (615:16) {#each $completed_collection as { batch_number, machine_location, product_type,                   product_container, product_weight,contaminant_boolean, contaminant_details,                   voltage_kv, current_ma, build_date, soft_version, batch_notes,individual_images,                   number_of_jobs_left, first_image_dir}
    function create_each_block_3(ctx) {
    	let card_card;
    	let current;

    	function change_handler_4() {
    		return /*change_handler_4*/ ctx[77](/*batch_number*/ ctx[125]);
    	}

    	card_card = new Card.Card({
    			props: {
    				class: "h-auto w-1/4 m-4 p-2",
    				$$slots: {
    					text: [create_text_slot],
    					media: [create_media_slot],
    					title: [create_title_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card_card.$on("change", change_handler_4);

    	const block = {
    		c: function create() {
    			create_component(card_card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card_card, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const card_card_changes = {};

    			if (dirty[1] & /*$completed_collection, $create_mode_dir, $local_collection_id*/ 164 | dirty[5] & /*$$scope*/ 32) {
    				card_card_changes.$$scope = { dirty, ctx };
    			}

    			card_card.$set(card_card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card_card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card_card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card_card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(615:16) {#each $completed_collection as { batch_number, machine_location, product_type,                   product_container, product_weight,contaminant_boolean, contaminant_details,                   voltage_kv, current_ma, build_date, soft_version, batch_notes,individual_images,                   number_of_jobs_left, first_image_dir}",
    		ctx
    	});

    	return block;
    }

    // (802:36) <Badge class= "align-top" color = "info">
    function create_default_slot_14$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*$number_of_jobs_left*/ ctx[32]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*$number_of_jobs_left*/ 2) set_data_dev(t, /*$number_of_jobs_left*/ ctx[32]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$1.name,
    		type: "slot",
    		source: "(802:36) <Badge class= \\\"align-top\\\" color = \\\"info\\\">",
    		ctx
    	});

    	return block;
    }

    // (799:6) <Dialog class="h-5/6 w-5/6 " bind:value={$showProcessDialog} persistent>
    function create_default_slot_13$2(ctx) {
    	let div2;
    	let div0;
    	let h20;
    	let t1;
    	let div1;
    	let h21;
    	let badge;
    	let current;

    	badge = new Badge({
    			props: {
    				class: "align-top",
    				color: "info",
    				$$slots: { default: [create_default_slot_14$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Processing Jobs Left:";
    			t1 = space();
    			div1 = element("div");
    			h21 = element("h2");
    			create_component(badge.$$.fragment);
    			add_location(h20, file$9, 800, 42, 35877);
    			attr_dev(div0, "class", "col-md-6 offset-md-1");
    			add_location(div0, file$9, 800, 8, 35843);
    			add_location(h21, file$9, 801, 31, 35945);
    			attr_dev(div1, "class", "col-md-2 ");
    			add_location(div1, file$9, 801, 8, 35922);
    			attr_dev(div2, "class", "row align-items-center text-center p-72");
    			add_location(div2, file$9, 799, 8, 35781);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, h20);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, h21);
    			mount_component(badge, h21, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_changes = {};

    			if (dirty[1] & /*$number_of_jobs_left*/ 2 | dirty[5] & /*$$scope*/ 32) {
    				badge_changes.$$scope = { dirty, ctx };
    			}

    			badge.$set(badge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(badge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$2.name,
    		type: "slot",
    		source: "(799:6) <Dialog class=\\\"h-5/6 w-5/6 \\\" bind:value={$showProcessDialog} persistent>",
    		ctx
    	});

    	return block;
    }

    // (825:18) {#if isEnabled}
    function create_if_block_7$1(ctx) {
    	let div;
    	let img0;
    	let img0_src_value;
    	let t;
    	let img1;
    	let img1_src_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img0 = element("img");
    			t = space();
    			img1 = element("img");
    			attr_dev(img0, "alt", "Loading....");
    			attr_dev(img0, "loading", "eager");
    			set_style(img0, "max-height", "700px");
    			if (!src_url_equal(img0.src, img0_src_value = /*plain_image_path*/ ctx[1])) attr_dev(img0, "src", img0_src_value);
    			add_location(img0, file$9, 828, 20, 36862);
    			attr_dev(img1, "alt", "Loading....");
    			attr_dev(img1, "loading", "eager");
    			set_style(img1, "max-height", "700px");
    			if (!src_url_equal(img1.src, img1_src_value = /*sobel_image_path*/ ctx[2])) attr_dev(img1, "src", img1_src_value);
    			add_location(img1, file$9, 837, 20, 37280);
    			attr_dev(div, "class", "grid grid-rows-1 grid-flow-col gap-x-36 z-50");
    			add_location(div, file$9, 825, 18, 36585);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img0);
    			append_dev(div, t);
    			append_dev(div, img1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*plain_image_path*/ 2 && !src_url_equal(img0.src, img0_src_value = /*plain_image_path*/ ctx[1])) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (dirty[0] & /*sobel_image_path*/ 4 && !src_url_equal(img1.src, img1_src_value = /*sobel_image_path*/ ctx[2])) {
    				attr_dev(img1, "src", img1_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(825:18) {#if isEnabled}",
    		ctx
    	});

    	return block;
    }

    // (843:18) {#if !isEnabled}
    function create_if_block_6$1(ctx) {
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "z-50");
    			set_style(img, "display", "block");
    			set_style(img, "margin-left", "400px");
    			set_style(img, "margin-right", "250px");
    			set_style(img, "max-width", "100%");
    			set_style(img, "max-height", "700px");
    			set_style(img, "object-fit", "contain");
    			set_style(img, "position", "absolute");
    			set_style(img, "transform", "rotate(90deg) scale(1.2)");
    			if (!src_url_equal(img.src, img_src_value = /*plain_image_path*/ ctx[1])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$9, 845, 20, 37568);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = action_destroyer(zoom.call(null, img, 2));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*plain_image_path*/ 2 && !src_url_equal(img.src, img_src_value = /*plain_image_path*/ ctx[1])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(843:18) {#if !isEnabled}",
    		ctx
    	});

    	return block;
    }

    // (891:44) 
    function create_if_block_5$1(ctx) {
    	let div1;
    	let div0;
    	let t1;
    	let select1;
    	let select0;
    	let mounted;
    	let dispose;
    	let each_value_2 = /*$completed_collection*/ ctx[36];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Batch no:";
    			t1 = space();
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			select0 = element("select");
    			attr_dev(div0, "class", "p-1");
    			add_location(div0, file$9, 894, 20, 39785);
    			add_location(select0, file$9, 903, 18, 40231);
    			if (/*batch_no*/ ctx[6] === void 0) add_render_callback(() => /*select1_change_handler_2*/ ctx[82].call(select1));
    			add_location(select1, file$9, 899, 20, 39963);
    			attr_dev(div1, "class", "row align-items-center ");
    			add_location(div1, file$9, 891, 12, 39693);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t1);
    			append_dev(div1, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			append_dev(select1, select0);
    			select_option(select1, /*batch_no*/ ctx[6]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select1, "change", /*select1_change_handler_2*/ ctx[82]),
    					listen_dev(
    						select1,
    						"change",
    						function () {
    							if (is_function(/*get_all_images*/ ctx[0](/*batch_no*/ ctx[6]))) /*get_all_images*/ ctx[0](/*batch_no*/ ctx[6]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[1] & /*$completed_collection*/ 32) {
    				each_value_2 = /*$completed_collection*/ ctx[36];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, select0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}

    			if (dirty[0] & /*batch_no*/ 64 | dirty[1] & /*$completed_collection*/ 32) {
    				select_option(select1, /*batch_no*/ ctx[6]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(891:44) ",
    		ctx
    	});

    	return block;
    }

    // (874:14) {#if $collection_running  }
    function create_if_block_4$2(ctx) {
    	let div1;
    	let div0;
    	let t1;
    	let select1;
    	let select0;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*$completed_batches*/ ctx[5];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Batch no:";
    			t1 = space();
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			select0 = element("select");
    			attr_dev(div0, "class", "p-1");
    			add_location(div0, file$9, 877, 28, 39056);
    			add_location(select0, file$9, 886, 26, 39571);
    			if (/*batch_no*/ ctx[6] === void 0) add_render_callback(() => /*select1_change_handler_1*/ ctx[81].call(select1));
    			add_location(select1, file$9, 882, 28, 39274);
    			attr_dev(div1, "class", "row align-items-center ");
    			add_location(div1, file$9, 874, 18, 38962);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t1);
    			append_dev(div1, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			append_dev(select1, select0);
    			select_option(select1, /*batch_no*/ ctx[6]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select1, "change", /*select1_change_handler_1*/ ctx[81]),
    					listen_dev(
    						select1,
    						"change",
    						function () {
    							if (is_function(/*get_all_images*/ ctx[0](/*batch_no*/ ctx[6]))) /*get_all_images*/ ctx[0](/*batch_no*/ ctx[6]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*$completed_batches*/ 32) {
    				each_value_1 = /*$completed_batches*/ ctx[5];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, select0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty[0] & /*batch_no*/ 64 | dirty[1] & /*$completed_collection*/ 32) {
    				select_option(select1, /*batch_no*/ ctx[6]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(874:14) {#if $collection_running  }",
    		ctx
    	});

    	return block;
    }

    // (901:22) {#each $completed_collection as  {batch_number}}
    function create_each_block_2$1(ctx) {
    	let option;
    	let t_value = /*batch_number*/ ctx[125] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*batch_number*/ ctx[125];
    			option.value = option.__value;
    			add_location(option, file$9, 901, 24, 40127);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*$completed_collection*/ 32 && t_value !== (t_value = /*batch_number*/ ctx[125] + "")) set_data_dev(t, t_value);

    			if (dirty[1] & /*$completed_collection*/ 32 && option_value_value !== (option_value_value = /*batch_number*/ ctx[125])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(901:22) {#each $completed_collection as  {batch_number}}",
    		ctx
    	});

    	return block;
    }

    // (884:30) {#each $completed_batches as  {batch_number}}
    function create_each_block_1$1(ctx) {
    	let option;
    	let t_value = /*batch_number*/ ctx[125] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*batch_number*/ ctx[125];
    			option.value = option.__value;
    			add_location(option, file$9, 884, 32, 39451);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$completed_batches*/ 32 && t_value !== (t_value = /*batch_number*/ ctx[125] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$completed_batches*/ 32 && option_value_value !== (option_value_value = /*batch_number*/ ctx[125])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(884:30) {#each $completed_batches as  {batch_number}}",
    		ctx
    	});

    	return block;
    }

    // (920:14) <Button color="blue" icon="view_list" on:click={viewVariables} >
    function create_default_slot_12$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Variables");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$2.name,
    		type: "slot",
    		source: "(920:14) <Button color=\\\"blue\\\" icon=\\\"view_list\\\" on:click={viewVariables} >",
    		ctx
    	});

    	return block;
    }

    // (929:14) <Button color="blue" text on:click={() => showDeleteImageModal = true}>
    function create_default_slot_11$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Delete Image");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$2.name,
    		type: "slot",
    		source: "(929:14) <Button color=\\\"blue\\\" text on:click={() => showDeleteImageModal = true}>",
    		ctx
    	});

    	return block;
    }

    // (932:14) <Button color="blue" text on:click={() => showImageModal = false}>
    function create_default_slot_10$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Close");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$2.name,
    		type: "slot",
    		source: "(932:14) <Button color=\\\"blue\\\" text on:click={() => showImageModal = false}>",
    		ctx
    	});

    	return block;
    }

    // (817:2) <Dialog class="h-screen w-5/6" bind:value={showImageModal} >
    function create_default_slot_9$2(ctx) {
    	let div11;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let small0;
    	let t2;
    	let t3;
    	let t4;
    	let small1;
    	let t5;
    	let t6;
    	let t7;
    	let slider;
    	let updating_value;
    	let t8;
    	let div10;
    	let div9;
    	let div2;
    	let t9;
    	let div3;
    	let button0;
    	let t10;
    	let div4;
    	let button1;
    	let t11;
    	let div5;
    	let button2;
    	let t12;
    	let div6;
    	let h5;
    	let t14;
    	let switch_1;
    	let updating_value_1;
    	let t15;
    	let div7;
    	let button3;
    	let t16;
    	let div8;
    	let button4;
    	let current;
    	let if_block0 = /*isEnabled*/ ctx[13] && create_if_block_7$1(ctx);
    	let if_block1 = !/*isEnabled*/ ctx[13] && create_if_block_6$1(ctx);

    	function slider_value_binding(value) {
    		/*slider_value_binding*/ ctx[80](value);
    	}

    	let slider_props = {
    		min: "1",
    		max: /*$plain_pngs_paths*/ ctx[39].length,
    		disabled: /*disabled*/ ctx[52],
    		color: "blue"
    	};

    	if (/*slider_value*/ ctx[12] !== void 0) {
    		slider_props.value = /*slider_value*/ ctx[12];
    	}

    	slider = new Slider({ props: slider_props, $$inline: true });
    	binding_callbacks.push(() => bind(slider, 'value', slider_value_binding));

    	slider.$on("change", function () {
    		if (is_function(/*reRenderImages*/ ctx[55](/*batch_no*/ ctx[6], /*slider_value*/ ctx[12]))) /*reRenderImages*/ ctx[55](/*batch_no*/ ctx[6], /*slider_value*/ ctx[12]).apply(this, arguments);
    	});

    	function select_block_type_6(ctx, dirty) {
    		if (/*$collection_running*/ ctx[37]) return create_if_block_4$2;
    		if (!/*$collection_running*/ ctx[37]) return create_if_block_5$1;
    	}

    	let current_block_type = select_block_type_6(ctx);
    	let if_block2 = current_block_type && current_block_type(ctx);

    	button0 = new Button({
    			props: { color: "blue", icon: "arrow_back" },
    			$$inline: true
    		});

    	button0.$on("click", /*arrowBack*/ ctx[54]);

    	button1 = new Button({
    			props: { color: "blue", icon: "arrow_forward" },
    			$$inline: true
    		});

    	button1.$on("click", /*arrowForward*/ ctx[53]);

    	button2 = new Button({
    			props: {
    				color: "blue",
    				icon: "view_list",
    				$$slots: { default: [create_default_slot_12$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2.$on("click", /*viewVariables*/ ctx[59]);

    	function switch_1_value_binding(value) {
    		/*switch_1_value_binding*/ ctx[83](value);
    	}

    	let switch_1_props = { label: "Enabled", color: "blue" };

    	if (/*isEnabled*/ ctx[13] !== void 0) {
    		switch_1_props.value = /*isEnabled*/ ctx[13];
    	}

    	switch_1 = new Switch({ props: switch_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(switch_1, 'value', switch_1_value_binding));
    	switch_1.$on("click", /*sobel_change*/ ctx[56]);

    	button3 = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_11$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button3.$on("click", /*click_handler*/ ctx[84]);

    	button4 = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_10$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button4.$on("click", /*click_handler_1*/ ctx[85]);

    	const block = {
    		c: function create() {
    			div11 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			small0 = element("small");
    			t2 = text("Image Number: ");
    			t3 = text(/*slider_value*/ ctx[12]);
    			t4 = space();
    			small1 = element("small");
    			t5 = text("Time Stamp: ");
    			t6 = text(/*current_time_stamp*/ ctx[3]);
    			t7 = space();
    			create_component(slider.$$.fragment);
    			t8 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div2 = element("div");
    			if (if_block2) if_block2.c();
    			t9 = space();
    			div3 = element("div");
    			create_component(button0.$$.fragment);
    			t10 = space();
    			div4 = element("div");
    			create_component(button1.$$.fragment);
    			t11 = space();
    			div5 = element("div");
    			create_component(button2.$$.fragment);
    			t12 = space();
    			div6 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Sobel On/Off";
    			t14 = space();
    			create_component(switch_1.$$.fragment);
    			t15 = space();
    			div7 = element("div");
    			create_component(button3.$$.fragment);
    			t16 = space();
    			div8 = element("div");
    			create_component(button4.$$.fragment);
    			set_style(div0, "min-height", "720px");
    			add_location(div0, file$9, 821, 6, 36461);
    			add_location(small0, file$9, 863, 12, 38463);
    			add_location(small1, file$9, 864, 12, 38519);
    			attr_dev(div1, "class", "h-2/12 ");
    			add_location(div1, file$9, 860, 10, 38283);
    			attr_dev(div2, "class", "col-md-1 ");
    			add_location(div2, file$9, 872, 12, 38878);
    			attr_dev(div3, "class", "offset-md-2 col-md-1 ");
    			add_location(div3, file$9, 910, 12, 40332);
    			attr_dev(div4, "class", "col-md-1");
    			add_location(div4, file$9, 914, 12, 40477);
    			attr_dev(div5, "class", "col-md-1");
    			add_location(div5, file$9, 918, 12, 40615);
    			attr_dev(h5, "class", "pb-8 pt-10");
    			attr_dev(h5, "id", "switches");
    			add_location(h5, file$9, 923, 14, 40817);
    			attr_dev(div6, "class", "col-md-3  text-center");
    			add_location(div6, file$9, 922, 12, 40767);
    			attr_dev(div7, "class", "col-md-1 ");
    			add_location(div7, file$9, 927, 12, 41005);
    			attr_dev(div8, "class", "col-md-1 ");
    			add_location(div8, file$9, 930, 12, 41167);
    			attr_dev(div9, "class", "row align-items-center ");
    			add_location(div9, file$9, 871, 10, 38828);
    			attr_dev(div10, "class", "h-2/9 ");
    			add_location(div10, file$9, 870, 8, 38796);
    			attr_dev(div11, "class", "h-screen w-full");
    			add_location(div11, file$9, 820, 4, 36424);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div11, t1);
    			append_dev(div11, div1);
    			append_dev(div1, small0);
    			append_dev(small0, t2);
    			append_dev(small0, t3);
    			append_dev(div1, t4);
    			append_dev(div1, small1);
    			append_dev(small1, t5);
    			append_dev(small1, t6);
    			append_dev(div1, t7);
    			mount_component(slider, div1, null);
    			append_dev(div11, t8);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div2);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div9, t9);
    			append_dev(div9, div3);
    			mount_component(button0, div3, null);
    			append_dev(div9, t10);
    			append_dev(div9, div4);
    			mount_component(button1, div4, null);
    			append_dev(div9, t11);
    			append_dev(div9, div5);
    			mount_component(button2, div5, null);
    			append_dev(div9, t12);
    			append_dev(div9, div6);
    			append_dev(div6, h5);
    			append_dev(div6, t14);
    			mount_component(switch_1, div6, null);
    			append_dev(div9, t15);
    			append_dev(div9, div7);
    			mount_component(button3, div7, null);
    			append_dev(div9, t16);
    			append_dev(div9, div8);
    			mount_component(button4, div8, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*isEnabled*/ ctx[13]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_7$1(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*isEnabled*/ ctx[13]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_6$1(ctx);
    					if_block1.c();
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty[0] & /*slider_value*/ 4096) set_data_dev(t3, /*slider_value*/ ctx[12]);
    			if (!current || dirty[0] & /*current_time_stamp*/ 8) set_data_dev(t6, /*current_time_stamp*/ ctx[3]);
    			const slider_changes = {};
    			if (dirty[1] & /*$plain_pngs_paths*/ 256) slider_changes.max = /*$plain_pngs_paths*/ ctx[39].length;

    			if (!updating_value && dirty[0] & /*slider_value*/ 4096) {
    				updating_value = true;
    				slider_changes.value = /*slider_value*/ ctx[12];
    				add_flush_callback(() => updating_value = false);
    			}

    			slider.$set(slider_changes);

    			if (current_block_type === (current_block_type = select_block_type_6(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if (if_block2) if_block2.d(1);
    				if_block2 = current_block_type && current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div2, null);
    				}
    			}

    			const button2_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    			const switch_1_changes = {};

    			if (!updating_value_1 && dirty[0] & /*isEnabled*/ 8192) {
    				updating_value_1 = true;
    				switch_1_changes.value = /*isEnabled*/ ctx[13];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			switch_1.$set(switch_1_changes);
    			const button3_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button3_changes.$$scope = { dirty, ctx };
    			}

    			button3.$set(button3_changes);
    			const button4_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button4_changes.$$scope = { dirty, ctx };
    			}

    			button4.$set(button4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slider.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			transition_in(switch_1.$$.fragment, local);
    			transition_in(button3.$$.fragment, local);
    			transition_in(button4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slider.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			transition_out(switch_1.$$.fragment, local);
    			transition_out(button3.$$.fragment, local);
    			transition_out(button4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div11);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(slider);

    			if (if_block2) {
    				if_block2.d();
    			}

    			destroy_component(button0);
    			destroy_component(button1);
    			destroy_component(button2);
    			destroy_component(switch_1);
    			destroy_component(button3);
    			destroy_component(button4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$2.name,
    		type: "slot",
    		source: "(817:2) <Dialog class=\\\"h-screen w-5/6\\\" bind:value={showImageModal} >",
    		ctx
    	});

    	return block;
    }

    // (956:8) <Button color="blue" text on:click={() => showdetailsModal = false}>
    function create_default_slot_8$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Close");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$2.name,
    		type: "slot",
    		source: "(956:8) <Button color=\\\"blue\\\" text on:click={() => showdetailsModal = false}>",
    		ctx
    	});

    	return block;
    }

    // (944:2) <Dialog  bind:value={showdetailsModal} on:change={get_all_completed_batches(batch_no)}>
    function create_default_slot_7$2(ctx) {
    	let div1;
    	let div0;
    	let span1;
    	let span0;
    	let input0;
    	let t1;
    	let span3;
    	let span2;
    	let input1;
    	let t3;
    	let span5;
    	let span4;
    	let input2;
    	let t5;
    	let span7;
    	let span6;
    	let input3;
    	let t7;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	button = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_8$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_2*/ ctx[95]);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span1 = element("span");
    			span0 = element("span");
    			span0.textContent = "Machine Location: ";
    			input0 = element("input");
    			t1 = space();
    			span3 = element("span");
    			span2 = element("span");
    			span2.textContent = "Product Type: ";
    			input1 = element("input");
    			t3 = space();
    			span5 = element("span");
    			span4 = element("span");
    			span4.textContent = "Product Container: ";
    			input2 = element("input");
    			t5 = space();
    			span7 = element("span");
    			span6 = element("span");
    			span6.textContent = "Product Weight (kg): ";
    			input3 = element("input");
    			t7 = space();
    			create_component(button.$$.fragment);
    			attr_dev(span0, "class", "subtitle-1");
    			add_location(span0, file$9, 949, 50, 41627);
    			attr_dev(input0, "class", "text-black dark:text-gray-100");
    			add_location(input0, file$9, 949, 100, 41677);
    			attr_dev(span1, "class", "pb-1 line-clamp-1");
    			add_location(span1, file$9, 949, 16, 41593);
    			attr_dev(span2, "class", "subtitle-1");
    			add_location(span2, file$9, 950, 50, 41890);
    			attr_dev(input1, "class", "text-black dark:text-gray-100");
    			add_location(input1, file$9, 950, 96, 41936);
    			attr_dev(span3, "class", "pb-1 line-clamp-1");
    			add_location(span3, file$9, 950, 16, 41856);
    			attr_dev(span4, "class", "subtitle-1");
    			add_location(span4, file$9, 951, 50, 42136);
    			attr_dev(input2, "class", "text-black dark:text-gray-100");
    			add_location(input2, file$9, 951, 101, 42187);
    			attr_dev(span5, "class", "pb-1 line-clamp-1");
    			add_location(span5, file$9, 951, 16, 42102);
    			attr_dev(span6, "class", "subtitle-1");
    			add_location(span6, file$9, 952, 50, 42402);
    			attr_dev(input3, "class", "text-black dark:text-gray-100");
    			add_location(input3, file$9, 952, 103, 42455);
    			attr_dev(span7, "class", "pb-1 line-clamp-1");
    			add_location(span7, file$9, 952, 16, 42368);
    			attr_dev(div0, "class", "text-left  p-1 pb-0 pt-3 text-gray-700 body-2");
    			add_location(div0, file$9, 946, 6, 41502);
    			add_location(div1, file$9, 945, 4, 41489);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span1);
    			append_dev(span1, span0);
    			append_dev(span1, input0);
    			set_input_value(input0, /*new_machine_location*/ ctx[16]);
    			append_dev(div0, t1);
    			append_dev(div0, span3);
    			append_dev(span3, span2);
    			append_dev(span3, input1);
    			set_input_value(input1, /*new_product_type*/ ctx[17]);
    			append_dev(div0, t3);
    			append_dev(div0, span5);
    			append_dev(span5, span4);
    			append_dev(span5, input2);
    			set_input_value(input2, /*new_product_container*/ ctx[18]);
    			append_dev(div0, t5);
    			append_dev(div0, span7);
    			append_dev(span7, span6);
    			append_dev(span7, input3);
    			set_input_value(input3, /*new_product_weight*/ ctx[19]);
    			append_dev(div1, t7);
    			mount_component(button, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[87]),
    					listen_dev(input0, "input", /*input_handler_3*/ ctx[88], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[89]),
    					listen_dev(input1, "input", /*input_handler_4*/ ctx[90], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[91]),
    					listen_dev(input2, "input", /*input_handler_5*/ ctx[92], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[93]),
    					listen_dev(input3, "input", /*input_handler_6*/ ctx[94], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*new_machine_location*/ 65536 && input0.value !== /*new_machine_location*/ ctx[16]) {
    				set_input_value(input0, /*new_machine_location*/ ctx[16]);
    			}

    			if (dirty[0] & /*new_product_type*/ 131072 && input1.value !== /*new_product_type*/ ctx[17]) {
    				set_input_value(input1, /*new_product_type*/ ctx[17]);
    			}

    			if (dirty[0] & /*new_product_container*/ 262144 && input2.value !== /*new_product_container*/ ctx[18]) {
    				set_input_value(input2, /*new_product_container*/ ctx[18]);
    			}

    			if (dirty[0] & /*new_product_weight*/ 524288 && input3.value !== /*new_product_weight*/ ctx[19]) {
    				set_input_value(input3, /*new_product_weight*/ ctx[19]);
    			}

    			const button_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(944:2) <Dialog  bind:value={showdetailsModal} on:change={get_all_completed_batches(batch_no)}>",
    		ctx
    	});

    	return block;
    }

    // (968:36) 
    function create_if_block_3$2(ctx) {
    	let h3;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let div0;
    	let textarea0;
    	let t4;
    	let h6;
    	let t6;
    	let div1;
    	let textarea1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text("Batch Notes (Batch No.");
    			t1 = text(/*batch_no*/ ctx[6]);
    			t2 = text(")");
    			t3 = space();
    			div0 = element("div");
    			textarea0 = element("textarea");
    			t4 = space();
    			h6 = element("h6");
    			h6.textContent = "Additional Batch Notes";
    			t6 = space();
    			div1 = element("div");
    			textarea1 = element("textarea");
    			add_location(h3, file$9, 968, 6, 43224);
    			attr_dev(textarea0, "rows", "5");
    			attr_dev(textarea0, "cols", "80 ");
    			textarea0.readOnly = true;
    			add_location(textarea0, file$9, 970, 33, 43530);
    			attr_dev(div0, "class", "text-gray-700");
    			add_location(div0, file$9, 970, 6, 43503);
    			attr_dev(h6, "class", "svelte-133jb13");
    			add_location(h6, file$9, 971, 6, 43623);
    			attr_dev(textarea1, "wrap", "hard");
    			attr_dev(textarea1, "placeholder", "Type Additional Batch notes here");
    			attr_dev(textarea1, "rows", "14");
    			attr_dev(textarea1, "cols", "80 ");
    			add_location(textarea1, file$9, 972, 34, 43689);
    			attr_dev(div1, "class", "text-gray-700 ");
    			add_location(div1, file$9, 972, 6, 43661);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			append_dev(h3, t1);
    			append_dev(h3, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, textarea0);
    			set_input_value(textarea0, /*new_batch_notes*/ ctx[21]);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, textarea1);
    			set_input_value(textarea1, /*new_additional_batch_notes*/ ctx[20]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea0, "input", /*textarea0_input_handler*/ ctx[100]),
    					listen_dev(textarea1, "input", /*textarea1_input_handler*/ ctx[101]),
    					listen_dev(textarea1, "input", /*input_handler_8*/ ctx[102], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*batch_no*/ 64) set_data_dev(t1, /*batch_no*/ ctx[6]);

    			if (dirty[0] & /*new_batch_notes*/ 2097152) {
    				set_input_value(textarea0, /*new_batch_notes*/ ctx[21]);
    			}

    			if (dirty[0] & /*new_additional_batch_notes*/ 1048576) {
    				set_input_value(textarea1, /*new_additional_batch_notes*/ ctx[20]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(968:36) ",
    		ctx
    	});

    	return block;
    }

    // (964:4) {#if $collection_running  }
    function create_if_block_2$2(ctx) {
    	let h3;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let div;
    	let textarea;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text("Batch Notes (Batch No.");
    			t1 = text(/*batch_no*/ ctx[6]);
    			t2 = text(")");
    			t3 = space();
    			div = element("div");
    			textarea = element("textarea");
    			add_location(h3, file$9, 964, 8, 42904);
    			attr_dev(textarea, "placeholder", "Type batch specific notes here");
    			attr_dev(textarea, "rows", "14");
    			attr_dev(textarea, "cols", "80 ");
    			add_location(textarea, file$9, 965, 36, 42984);
    			attr_dev(div, "class", "text-gray-700 ");
    			add_location(div, file$9, 965, 8, 42956);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			append_dev(h3, t1);
    			append_dev(h3, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, textarea);
    			set_input_value(textarea, /*new_batch_notes*/ ctx[21]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[98]),
    					listen_dev(textarea, "input", /*input_handler_7*/ ctx[99], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*batch_no*/ 64) set_data_dev(t1, /*batch_no*/ ctx[6]);

    			if (dirty[0] & /*new_batch_notes*/ 2097152) {
    				set_input_value(textarea, /*new_batch_notes*/ ctx[21]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(964:4) {#if $collection_running  }",
    		ctx
    	});

    	return block;
    }

    // (963:2) <Dialog  bind:value={show_batch_notes_modal} on:change={get_all_completed_batches(batch_no)}>
    function create_default_slot_6$2(ctx) {
    	let if_block_anchor;

    	function select_block_type_7(ctx, dirty) {
    		if (/*$collection_running*/ ctx[37]) return create_if_block_2$2;
    		if (!/*$collection_running*/ ctx[37]) return create_if_block_3$2;
    	}

    	let current_block_type = select_block_type_7(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_7(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(963:2) <Dialog  bind:value={show_batch_notes_modal} on:change={get_all_completed_batches(batch_no)}>",
    		ctx
    	});

    	return block;
    }

    // (979:8) <Button color="blue" text on:click={() => show_batch_notes_modal = false}>
    function create_default_slot_5$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("OK");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(979:8) <Button color=\\\"blue\\\" text on:click={() => show_batch_notes_modal = false}>",
    		ctx
    	});

    	return block;
    }

    // (978:4) 
    function create_actions_slot$1(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_3*/ ctx[97]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "slot", "actions");
    			add_location(div, file$9, 977, 4, 43958);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_actions_slot$1.name,
    		type: "slot",
    		source: "(978:4) ",
    		ctx
    	});

    	return block;
    }

    // (987:4) {#if image_deleted_success}
    function create_if_block_1$4(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_4*/ ctx[104]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "Image Deleted";
    			t1 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div0, "class", "col-md-1 ");
    			add_location(div0, file$9, 987, 4, 44204);
    			attr_dev(div1, "class", "col-md-1 ");
    			add_location(div1, file$9, 990, 4, 44263);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(987:4) {#if image_deleted_success}",
    		ctx
    	});

    	return block;
    }

    // (992:6) <Button color="blue" text on:click={() => closeDeleteImageModal()}>
    function create_default_slot_4$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("OK");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(992:6) <Button color=\\\"blue\\\" text on:click={() => closeDeleteImageModal()}>",
    		ctx
    	});

    	return block;
    }

    // (997:4) {#if !image_deleted_success}
    function create_if_block$5(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let button0;
    	let t2;
    	let div2;
    	let button1;
    	let current;

    	button0 = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*deleteImage*/ ctx[57]);

    	button1 = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_5*/ ctx[105]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "Are you sure?";
    			t1 = space();
    			div1 = element("div");
    			create_component(button0.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			create_component(button1.$$.fragment);
    			attr_dev(div0, "class", "col-md-1 ");
    			add_location(div0, file$9, 997, 4, 44440);
    			attr_dev(div1, "class", "col-md-1 ");
    			add_location(div1, file$9, 1000, 4, 44499);
    			attr_dev(div2, "class", "col-md-1 ");
    			add_location(div2, file$9, 1003, 4, 44606);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(button0, div1, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(button1, div2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[5] & /*$$scope*/ 32) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(button0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(997:4) {#if !image_deleted_success}",
    		ctx
    	});

    	return block;
    }

    // (1002:6) <Button color="blue" text on:click={deleteImage}>
    function create_default_slot_3$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Yes");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(1002:6) <Button color=\\\"blue\\\" text on:click={deleteImage}>",
    		ctx
    	});

    	return block;
    }

    // (1005:6) <Button color="blue" text on:click={() => closeDeleteImageModal()}>
    function create_default_slot_2$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(1005:6) <Button color=\\\"blue\\\" text on:click={() => closeDeleteImageModal()}>",
    		ctx
    	});

    	return block;
    }

    // (986:2) <Dialog bind:value={showDeleteImageModal}  persistent>
    function create_default_slot_1$6(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*image_deleted_success*/ ctx[14] && create_if_block_1$4(ctx);
    	let if_block1 = !/*image_deleted_success*/ ctx[14] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*image_deleted_success*/ ctx[14]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*image_deleted_success*/ 16384) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*image_deleted_success*/ ctx[14]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*image_deleted_success*/ 16384) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(986:2) <Dialog bind:value={showDeleteImageModal}  persistent>",
    		ctx
    	});

    	return block;
    }

    // (1019:4) {#each Object.entries(current_image_variables) as [key, value]}
    function create_each_block$1(ctx) {
    	let h6;
    	let t0_value = /*key*/ ctx[121] + "";
    	let t0;
    	let t1;
    	let t2_value = /*value*/ ctx[122] + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t0 = text(t0_value);
    			t1 = text(" : ");
    			t2 = text(t2_value);
    			t3 = space();
    			attr_dev(h6, "class", "svelte-133jb13");
    			add_location(h6, file$9, 1020, 6, 45235);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t0);
    			append_dev(h6, t1);
    			append_dev(h6, t2);
    			append_dev(h6, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*current_image_variables*/ 16 && t0_value !== (t0_value = /*key*/ ctx[121] + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*current_image_variables*/ 16 && t2_value !== (t2_value = /*value*/ ctx[122] + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(1019:4) {#each Object.entries(current_image_variables) as [key, value]}",
    		ctx
    	});

    	return block;
    }

    // (1013:2) <Dialog bind:value={showViewVariablesModal} >
    function create_default_slot$7(ctx) {
    	let div1;
    	let div0;
    	let textfield;
    	let updating_value;
    	let t;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[107](value);
    	}

    	let textfield_props = {
    		color: "blue",
    		label: "Search Variables Here",
    		outlined: true
    	};

    	if (/*variable_search_term*/ ctx[22] !== void 0) {
    		textfield_props.value = /*variable_search_term*/ ctx[22];
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	textfield.$on("input", function () {
    		if (is_function(/*search_variables*/ ctx[60](/*variable_search_term*/ ctx[22], /*plain_pngs_paths_string*/ ctx[11], /*batch_no*/ ctx[6]))) /*search_variables*/ ctx[60](/*variable_search_term*/ ctx[22], /*plain_pngs_paths_string*/ ctx[11], /*batch_no*/ ctx[6]).apply(this, arguments);
    	});

    	let each_value = Object.entries(/*current_image_variables*/ ctx[4]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(textfield.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div0, file$9, 1015, 4, 44946);
    			attr_dev(div1, "class", "container overflow-auto");
    			set_style(div1, "width", "400px");
    			set_style(div1, "max-height", "720px");
    			add_location(div1, file$9, 1013, 4, 44809);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(textfield, div0, null);
    			append_dev(div1, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};

    			if (!updating_value && dirty[0] & /*variable_search_term*/ 4194304) {
    				updating_value = true;
    				textfield_changes.value = /*variable_search_term*/ ctx[22];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);

    			if (dirty[0] & /*current_image_variables*/ 16) {
    				each_value = Object.entries(/*current_image_variables*/ ctx[4]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(textfield);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(1013:2) <Dialog bind:value={showViewVariablesModal} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let dialog0;
    	let updating_value;
    	let t1;
    	let dialog1;
    	let updating_value_1;
    	let t2;
    	let dialog2;
    	let updating_value_2;
    	let t3;
    	let dialog3;
    	let updating_value_3;
    	let t4;
    	let dialog4;
    	let updating_value_4;
    	let t5;
    	let dialog5;
    	let updating_value_5;
    	let current;
    	const if_block_creators = [create_if_block_8$1, create_if_block_13$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*$collection_running*/ ctx[37] && /*$ready_to_work*/ ctx[40]) return 0;
    		if (/*$collection_running*/ ctx[37] && /*$ready_to_work*/ ctx[40]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	function dialog0_value_binding(value) {
    		/*dialog0_value_binding*/ ctx[79](value);
    	}

    	let dialog0_props = {
    		class: "h-5/6 w-5/6 ",
    		persistent: true,
    		$$slots: { default: [create_default_slot_13$2] },
    		$$scope: { ctx }
    	};

    	if (/*$showProcessDialog*/ ctx[43] !== void 0) {
    		dialog0_props.value = /*$showProcessDialog*/ ctx[43];
    	}

    	dialog0 = new Dialog({ props: dialog0_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog0, 'value', dialog0_value_binding));

    	function dialog1_value_binding(value) {
    		/*dialog1_value_binding*/ ctx[86](value);
    	}

    	let dialog1_props = {
    		class: "h-screen w-5/6",
    		$$slots: { default: [create_default_slot_9$2] },
    		$$scope: { ctx }
    	};

    	if (/*showImageModal*/ ctx[7] !== void 0) {
    		dialog1_props.value = /*showImageModal*/ ctx[7];
    	}

    	dialog1 = new Dialog({ props: dialog1_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog1, 'value', dialog1_value_binding));

    	function dialog2_value_binding(value) {
    		/*dialog2_value_binding*/ ctx[96](value);
    	}

    	let dialog2_props = {
    		$$slots: { default: [create_default_slot_7$2] },
    		$$scope: { ctx }
    	};

    	if (/*showdetailsModal*/ ctx[8] !== void 0) {
    		dialog2_props.value = /*showdetailsModal*/ ctx[8];
    	}

    	dialog2 = new Dialog({ props: dialog2_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog2, 'value', dialog2_value_binding));

    	dialog2.$on("change", function () {
    		if (is_function(/*get_all_completed_batches*/ ctx[51](/*batch_no*/ ctx[6]))) /*get_all_completed_batches*/ ctx[51](/*batch_no*/ ctx[6]).apply(this, arguments);
    	});

    	function dialog3_value_binding(value) {
    		/*dialog3_value_binding*/ ctx[103](value);
    	}

    	let dialog3_props = {
    		$$slots: {
    			actions: [create_actions_slot$1],
    			default: [create_default_slot_6$2]
    		},
    		$$scope: { ctx }
    	};

    	if (/*show_batch_notes_modal*/ ctx[10] !== void 0) {
    		dialog3_props.value = /*show_batch_notes_modal*/ ctx[10];
    	}

    	dialog3 = new Dialog({ props: dialog3_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog3, 'value', dialog3_value_binding));

    	dialog3.$on("change", function () {
    		if (is_function(/*get_all_completed_batches*/ ctx[51](/*batch_no*/ ctx[6]))) /*get_all_completed_batches*/ ctx[51](/*batch_no*/ ctx[6]).apply(this, arguments);
    	});

    	function dialog4_value_binding(value) {
    		/*dialog4_value_binding*/ ctx[106](value);
    	}

    	let dialog4_props = {
    		persistent: true,
    		$$slots: { default: [create_default_slot_1$6] },
    		$$scope: { ctx }
    	};

    	if (/*showDeleteImageModal*/ ctx[15] !== void 0) {
    		dialog4_props.value = /*showDeleteImageModal*/ ctx[15];
    	}

    	dialog4 = new Dialog({ props: dialog4_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog4, 'value', dialog4_value_binding));

    	function dialog5_value_binding(value) {
    		/*dialog5_value_binding*/ ctx[108](value);
    	}

    	let dialog5_props = {
    		$$slots: { default: [create_default_slot$7] },
    		$$scope: { ctx }
    	};

    	if (/*showViewVariablesModal*/ ctx[9] !== void 0) {
    		dialog5_props.value = /*showViewVariablesModal*/ ctx[9];
    	}

    	dialog5 = new Dialog({ props: dialog5_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog5, 'value', dialog5_value_binding));

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(dialog0.$$.fragment);
    			t1 = space();
    			create_component(dialog1.$$.fragment);
    			t2 = space();
    			create_component(dialog2.$$.fragment);
    			t3 = space();
    			create_component(dialog3.$$.fragment);
    			t4 = space();
    			create_component(dialog4.$$.fragment);
    			t5 = space();
    			create_component(dialog5.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			mount_component(dialog0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dialog1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dialog2, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dialog3, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dialog4, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(dialog5, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(t0.parentNode, t0);
    				} else {
    					if_block = null;
    				}
    			}

    			const dialog0_changes = {};

    			if (dirty[1] & /*$number_of_jobs_left*/ 2 | dirty[5] & /*$$scope*/ 32) {
    				dialog0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty[1] & /*$showProcessDialog*/ 4096) {
    				updating_value = true;
    				dialog0_changes.value = /*$showProcessDialog*/ ctx[43];
    				add_flush_callback(() => updating_value = false);
    			}

    			dialog0.$set(dialog0_changes);
    			const dialog1_changes = {};

    			if (dirty[0] & /*showImageModal, showDeleteImageModal, isEnabled, batch_no, $completed_batches, slider_value, current_time_stamp, plain_image_path, sobel_image_path*/ 45294 | dirty[1] & /*$collection_running, $completed_collection, $plain_pngs_paths*/ 352 | dirty[5] & /*$$scope*/ 32) {
    				dialog1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value_1 && dirty[0] & /*showImageModal*/ 128) {
    				updating_value_1 = true;
    				dialog1_changes.value = /*showImageModal*/ ctx[7];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			dialog1.$set(dialog1_changes);
    			const dialog2_changes = {};

    			if (dirty[0] & /*showdetailsModal, new_product_weight, new_product_container, new_product_type, new_machine_location*/ 983296 | dirty[5] & /*$$scope*/ 32) {
    				dialog2_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value_2 && dirty[0] & /*showdetailsModal*/ 256) {
    				updating_value_2 = true;
    				dialog2_changes.value = /*showdetailsModal*/ ctx[8];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			dialog2.$set(dialog2_changes);
    			const dialog3_changes = {};

    			if (dirty[0] & /*show_batch_notes_modal, new_batch_notes, batch_no, new_additional_batch_notes*/ 3146816 | dirty[1] & /*$collection_running*/ 64 | dirty[5] & /*$$scope*/ 32) {
    				dialog3_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value_3 && dirty[0] & /*show_batch_notes_modal*/ 1024) {
    				updating_value_3 = true;
    				dialog3_changes.value = /*show_batch_notes_modal*/ ctx[10];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			dialog3.$set(dialog3_changes);
    			const dialog4_changes = {};

    			if (dirty[0] & /*image_deleted_success*/ 16384 | dirty[5] & /*$$scope*/ 32) {
    				dialog4_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value_4 && dirty[0] & /*showDeleteImageModal*/ 32768) {
    				updating_value_4 = true;
    				dialog4_changes.value = /*showDeleteImageModal*/ ctx[15];
    				add_flush_callback(() => updating_value_4 = false);
    			}

    			dialog4.$set(dialog4_changes);
    			const dialog5_changes = {};

    			if (dirty[0] & /*current_image_variables, variable_search_term, plain_pngs_paths_string, batch_no*/ 4196432 | dirty[5] & /*$$scope*/ 32) {
    				dialog5_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value_5 && dirty[0] & /*showViewVariablesModal*/ 512) {
    				updating_value_5 = true;
    				dialog5_changes.value = /*showViewVariablesModal*/ ctx[9];
    				add_flush_callback(() => updating_value_5 = false);
    			}

    			dialog5.$set(dialog5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(dialog0.$$.fragment, local);
    			transition_in(dialog1.$$.fragment, local);
    			transition_in(dialog2.$$.fragment, local);
    			transition_in(dialog3.$$.fragment, local);
    			transition_in(dialog4.$$.fragment, local);
    			transition_in(dialog5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(dialog0.$$.fragment, local);
    			transition_out(dialog1.$$.fragment, local);
    			transition_out(dialog2.$$.fragment, local);
    			transition_out(dialog3.$$.fragment, local);
    			transition_out(dialog4.$$.fragment, local);
    			transition_out(dialog5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(t0);
    			destroy_component(dialog0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dialog1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dialog2, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dialog3, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dialog4, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(dialog5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function process_batch_images() {
    	// console.log("process_batch_images")
    	// console.log("$process_delay", $process_delay)
    	// p_delay = $process_delay;
    	const response = await fetch("./process_batch_images");

    	await response.json();
    } // console.log("process_batch_images_response", process_batch_images_response)

    function instance$e($$self, $$props, $$invalidate) {
    	let $local_user_selection;
    	let $matching_local_user_names;
    	let $local_user_search_term;
    	let $local_product_selection;
    	let $matching_local_product_names;
    	let $local_product_search_term;
    	let $local_company_selection;
    	let $matching_local_company_names;
    	let $local_company_search_term;
    	let $number_of_jobs_left;
    	let $completed_batches;
    	let $local_collection_id;
    	let $matching_local_collection_ids;
    	let $collection_ids;
    	let $completed_collection;
    	let $collection_running;
    	let $timestamps;
    	let $create_mode_dir;
    	let $image_quality;
    	let $plain_jpgs_paths;
    	let $sobel_jpgs_paths;
    	let $plain_pngs_paths;
    	let $ready_to_work;
    	let $batches_left_to_process;
    	let $fetching_images;
    	let $showProcessDialog;
    	validate_store(local_user_selection, 'local_user_selection');
    	component_subscribe($$self, local_user_selection, $$value => $$invalidate(23, $local_user_selection = $$value));
    	validate_store(matching_local_user_names, 'matching_local_user_names');
    	component_subscribe($$self, matching_local_user_names, $$value => $$invalidate(24, $matching_local_user_names = $$value));
    	validate_store(local_user_search_term, 'local_user_search_term');
    	component_subscribe($$self, local_user_search_term, $$value => $$invalidate(25, $local_user_search_term = $$value));
    	validate_store(local_product_selection, 'local_product_selection');
    	component_subscribe($$self, local_product_selection, $$value => $$invalidate(26, $local_product_selection = $$value));
    	validate_store(matching_local_product_names, 'matching_local_product_names');
    	component_subscribe($$self, matching_local_product_names, $$value => $$invalidate(27, $matching_local_product_names = $$value));
    	validate_store(local_product_search_term, 'local_product_search_term');
    	component_subscribe($$self, local_product_search_term, $$value => $$invalidate(28, $local_product_search_term = $$value));
    	validate_store(local_company_selection, 'local_company_selection');
    	component_subscribe($$self, local_company_selection, $$value => $$invalidate(29, $local_company_selection = $$value));
    	validate_store(matching_local_company_names, 'matching_local_company_names');
    	component_subscribe($$self, matching_local_company_names, $$value => $$invalidate(30, $matching_local_company_names = $$value));
    	validate_store(local_company_search_term, 'local_company_search_term');
    	component_subscribe($$self, local_company_search_term, $$value => $$invalidate(31, $local_company_search_term = $$value));
    	validate_store(number_of_jobs_left, 'number_of_jobs_left');
    	component_subscribe($$self, number_of_jobs_left, $$value => $$invalidate(32, $number_of_jobs_left = $$value));
    	validate_store(completed_batches, 'completed_batches');
    	component_subscribe($$self, completed_batches, $$value => $$invalidate(5, $completed_batches = $$value));
    	validate_store(local_collection_id, 'local_collection_id');
    	component_subscribe($$self, local_collection_id, $$value => $$invalidate(33, $local_collection_id = $$value));
    	validate_store(matching_local_collection_ids, 'matching_local_collection_ids');
    	component_subscribe($$self, matching_local_collection_ids, $$value => $$invalidate(34, $matching_local_collection_ids = $$value));
    	validate_store(collection_ids, 'collection_ids');
    	component_subscribe($$self, collection_ids, $$value => $$invalidate(35, $collection_ids = $$value));
    	validate_store(completed_collection, 'completed_collection');
    	component_subscribe($$self, completed_collection, $$value => $$invalidate(36, $completed_collection = $$value));
    	validate_store(collection_running, 'collection_running');
    	component_subscribe($$self, collection_running, $$value => $$invalidate(37, $collection_running = $$value));
    	validate_store(timestamps, 'timestamps');
    	component_subscribe($$self, timestamps, $$value => $$invalidate(113, $timestamps = $$value));
    	validate_store(create_mode_dir, 'create_mode_dir');
    	component_subscribe($$self, create_mode_dir, $$value => $$invalidate(38, $create_mode_dir = $$value));
    	validate_store(image_quality, 'image_quality');
    	component_subscribe($$self, image_quality, $$value => $$invalidate(114, $image_quality = $$value));
    	validate_store(plain_jpgs_paths, 'plain_jpgs_paths');
    	component_subscribe($$self, plain_jpgs_paths, $$value => $$invalidate(115, $plain_jpgs_paths = $$value));
    	validate_store(sobel_jpgs_paths, 'sobel_jpgs_paths');
    	component_subscribe($$self, sobel_jpgs_paths, $$value => $$invalidate(116, $sobel_jpgs_paths = $$value));
    	validate_store(plain_pngs_paths, 'plain_pngs_paths');
    	component_subscribe($$self, plain_pngs_paths, $$value => $$invalidate(39, $plain_pngs_paths = $$value));
    	validate_store(ready_to_work, 'ready_to_work');
    	component_subscribe($$self, ready_to_work, $$value => $$invalidate(40, $ready_to_work = $$value));
    	validate_store(batches_left_to_process, 'batches_left_to_process');
    	component_subscribe($$self, batches_left_to_process, $$value => $$invalidate(41, $batches_left_to_process = $$value));
    	validate_store(fetching_images, 'fetching_images');
    	component_subscribe($$self, fetching_images, $$value => $$invalidate(42, $fetching_images = $$value));
    	validate_store(showProcessDialog, 'showProcessDialog');
    	component_subscribe($$self, showProcessDialog, $$value => $$invalidate(43, $showProcessDialog = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UploadedSoFar', slots, []);
    	let batch_no = 1;

    	// let showProcessDialog;
    	// $: showProcessDialog = false
    	let showImageModal = false;

    	let showdetailsModal = false;
    	let showViewVariablesModal = false;
    	let show_batch_notes_modal = false;

    	function openDetailsModal(batch_number) {
    		$$invalidate(6, batch_no = batch_number);

    		// console.log("batch_number", batch_number)
    		$$invalidate(8, showdetailsModal = true);

    		get_all_completed_batches(batch_no);
    	}

    	function open_batch_notes_modal(batch_number) {
    		$$invalidate(6, batch_no = batch_number);

    		// console.log("batch_number", batch_number)
    		$$invalidate(10, show_batch_notes_modal = true);

    		get_all_completed_batches(batch_no);
    	}

    	function openImageModal(batch_number) {
    		get_all_images(batch_number);
    		$$invalidate(6, batch_no = batch_number);
    		$$invalidate(7, showImageModal = true);
    	} // console.log(batch_number)

    	let plain_pngs_paths_string = "";
    	let sobel_jpgs_paths_string = "";
    	let plain_jpgs_paths_string = "";

    	async function get_all_images(batch_no) {
    		const response = await fetch("./get_all_images/" + batch_no);
    		console.log("response", response);
    		const image_paths_retrieved = await response.json();
    		console.log("image_paths_retrieved", image_paths_retrieved, batch_no);
    		set_store_value(plain_pngs_paths, $plain_pngs_paths = image_paths_retrieved.plain_pngs, $plain_pngs_paths);
    		set_store_value(sobel_jpgs_paths, $sobel_jpgs_paths = image_paths_retrieved.sobel_jpgs, $sobel_jpgs_paths);
    		set_store_value(timestamps, $timestamps = image_paths_retrieved.timestamps, $timestamps);
    		set_store_value(plain_jpgs_paths, $plain_jpgs_paths = image_paths_retrieved.plain_jpgs, $plain_jpgs_paths);

    		// $image_variables = image_paths_retrieved.variables;
    		console.log("$plain_jpgs_paths", $plain_jpgs_paths);

    		// console.log("plain_jpgs_paths", $plain_jpgs_paths)
    		// console.log("sobel_jpgs_paths", $sobel_jpgs_paths)
    		// console.log("timestamps", $timestamps)
    		reRenderImages(batch_no, slider_value);

    		get_all_completed_batches(batch_no);
    	}

    	async function send_local_collection_id(col_id) {
    		console.log("col_id", col_id);

    		// $completed_collection = []
    		const response = await fetch("./send_local_collection_id/" + col_id);

    		const completed_collection_response = await response.json();
    		set_store_value(completed_collection, $completed_collection = completed_collection_response.completed_collection, $completed_collection);

    		// console.log("collection_id", collection_id)
    		// console.log("collection_id_response", collection_id_response)
    		console.log("$completed_collection", $completed_collection);
    	} // collection_id_for_image = col_id

    	async function send_local_company_selection() {
    		console.log("Entering send_local_company_selection");
    		console.log("$local_company_selection", $local_company_selection);
    		const response = await fetch("./send_local_company_selection/" + $local_company_selection);
    		const local_company_selection_response = await response.json();
    		set_store_value(matching_local_product_names, $matching_local_product_names = local_company_selection_response.matching_local_product_names, $matching_local_product_names);
    		set_store_value(matching_local_user_names, $matching_local_user_names = local_company_selection_response.matching_local_user_names, $matching_local_user_names);
    		set_store_value(matching_local_collection_ids, $matching_local_collection_ids = local_company_selection_response.matching_local_collection_ids, $matching_local_collection_ids);
    		console.log("$local_company_selection_response", local_company_selection_response);
    		set_store_value(local_collection_id, $local_collection_id = $matching_local_collection_ids[0], $local_collection_id);

    		if ($local_collection_id) {
    			send_local_collection_id($local_collection_id);
    		}
    	}

    	async function send_local_product_selection() {
    		const response = await fetch("./send_local_product_selection/" + $local_product_selection);
    		const local_product_selection_response = await response.json();
    		set_store_value(matching_local_user_names, $matching_local_user_names = local_product_selection_response.matching_local_user_names, $matching_local_user_names);
    		set_store_value(matching_local_collection_ids, $matching_local_collection_ids = local_product_selection_response.matching_local_collection_ids, $matching_local_collection_ids);
    		set_store_value(local_collection_id, $local_collection_id = $matching_local_collection_ids[0], $local_collection_id);
    		console.log("$local_product_selection_response", local_product_selection_response);

    		if ($local_collection_id) {
    			send_local_collection_id($local_collection_id);
    		}
    	}

    	async function send_local_user_selection() {
    		const response = await fetch("./send_local_user_selection/" + $local_user_selection);
    		const local_user_selection_response = await response.json();
    		set_store_value(matching_local_collection_ids, $matching_local_collection_ids = local_user_selection_response.matching_local_collection_ids, $matching_local_collection_ids);
    		console.log("$local_user_selection_response", local_user_selection_response);
    		set_store_value(local_collection_id, $local_collection_id = $matching_local_collection_ids[0], $local_collection_id);

    		if ($local_collection_id) {
    			send_local_collection_id($local_collection_id);
    		}
    	}

    	// // let comp_batches = [];
    	// setTimeout( function() {
    	//   console.log("$completed_batches.length",$completed_batches.length)
    	//   // console.log("$completed_batches",$completed_batches)
    	// }, "10000");
    	async function get_all_completed_batches(batch_no) {
    		// console.log("$completed_batches",$completed_batches)
    		// comp_batches = $completed_batches
    		// console.log("$completed_batches.length",$completed_batches.length)
    		// console.log("comp_batches",comp_batches)
    		if ($collection_running) {
    			if (!($completed_batches.length === 0)) {
    				$$invalidate(16, new_machine_location = $completed_batches[batch_no - 1].machine_location);
    				$$invalidate(17, new_product_type = $completed_batches[batch_no - 1].product_type);
    				$$invalidate(18, new_product_container = $completed_batches[batch_no - 1].product_container);
    				$$invalidate(19, new_product_weight = $completed_batches[batch_no - 1].product_weight);
    				$$invalidate(21, new_batch_notes = $completed_batches[batch_no - 1].batch_notes);
    				console.log("new_batch_notes", new_batch_notes);
    			}
    		} else {
    			if (!($completed_collection.length === 0)) {
    				$$invalidate(16, new_machine_location = $completed_collection[batch_no - 1].machine_location);
    				$$invalidate(17, new_product_type = $completed_collection[batch_no - 1].product_type);
    				$$invalidate(18, new_product_container = $completed_collection[batch_no - 1].product_container);
    				$$invalidate(19, new_product_weight = $completed_collection[batch_no - 1].product_weight);
    				$$invalidate(21, new_batch_notes = $completed_collection[batch_no - 1].batch_notes);
    				$$invalidate(20, new_additional_batch_notes = $completed_collection[batch_no - 1].additional_batch_notes);
    				console.log("new_batch_notes", new_batch_notes);
    			}
    		}
    	}

    	let disabled = false;
    	let slider_value;

    	// console.log(batch_no, plain_pngs_paths_string)
    	let plain_image_path = "";

    	let sobel_image_path = "";

    	// console.log( plain_image_path)
    	let isEnabled = true;

    	function arrowForward() {
    		if (slider_value < $plain_pngs_paths.length) {
    			$$invalidate(12, slider_value = slider_value + 1);
    			reRenderImages(batch_no, slider_value);
    		}
    	}

    	function arrowBack() {
    		if (slider_value > 1) {
    			$$invalidate(12, slider_value = slider_value - 1);
    			reRenderImages(batch_no, slider_value);
    		}
    	}

    	function reRenderImages(batch_no, slider_value) {
    		// console.log("rerendering")
    		$$invalidate(11, plain_pngs_paths_string = $plain_pngs_paths[slider_value - 1]);

    		sobel_jpgs_paths_string = $sobel_jpgs_paths[slider_value - 1];
    		plain_jpgs_paths_string = $plain_jpgs_paths[slider_value - 1];
    		console.log("$plain_jpgs_paths", $plain_jpgs_paths);
    		console.log("plain_pngs_paths_string", plain_pngs_paths_string);

    		// console.log("sobel_jpgs_paths_string",sobel_jpgs_paths_string)
    		// console.log("$image_quality", $image_quality)
    		if (!$collection_running) {
    			// console.log("$local_collection_id", $local_collection_id)
    			// console.log("create_mode_test", $create_mode_dir.substring(15,26))
    			if ($image_quality == "jpg") {
    				$$invalidate(1, plain_image_path = $create_mode_dir.substring(15, 26) + "temp_collections/" + $local_collection_id + "/batch_" + batch_no + "/All_Images/plain_jpgs/" + plain_jpgs_paths_string);
    			} else if ($image_quality == "png") {
    				$$invalidate(1, plain_image_path = $create_mode_dir.substring(15, 26) + "temp_collections/" + $local_collection_id + "/batch_" + batch_no + "/All_Images/plain_pngs/" + plain_pngs_paths_string);
    			}

    			$$invalidate(2, sobel_image_path = $create_mode_dir.substring(15, 26) + "temp_collections/" + $local_collection_id + "/batch_" + batch_no + "/All_Images/sobel_jpgs/" + sobel_jpgs_paths_string);

    			// console.log("sobel_image_path",sobel_image_path)
    			// console.log("$completed_collection_render",$completed_collection)
    			if (!($completed_collection.length === 0)) {
    				$$invalidate(4, current_image_variables = $completed_collection[Number(batch_no) - 1]["individual_images"][plain_pngs_paths_string.split('.')[0]]);
    			} // [plain_pngs_paths_string.split('.')[0]]
    			// console.log("current_image_variables_completed_collection",current_image_variables)
    		} else if ($collection_running) {
    			// console.log("create_mode_test1", $create_mode_dir.substring(15))
    			if ($image_quality == "jpg") {
    				$$invalidate(1, plain_image_path = $create_mode_dir.substring(15) + "/batch_" + batch_no + "/All_Images/plain_jpgs/" + plain_jpgs_paths_string);
    			} else if ($image_quality == "png") {
    				$$invalidate(1, plain_image_path = $create_mode_dir.substring(15) + "/batch_" + batch_no + "/All_Images/plain_pngs/" + plain_pngs_paths_string);
    			}

    			$$invalidate(2, sobel_image_path = $create_mode_dir.substring(15) + "/batch_" + batch_no + "/All_Images/sobel_jpgs/" + sobel_jpgs_paths_string);

    			if (!($completed_batches.length === 0)) {
    				$$invalidate(4, current_image_variables = $completed_batches[Number(batch_no) - 1]["individual_images"][plain_pngs_paths_string.split('.')[0]]);
    			} // [plain_pngs_paths_string.split('.')[0]]
    			// console.log("current_image_variables",current_image_variables)
    		}

    		// console.log("plain_image_path",plain_image_path)
    		// console.log("sobel_image_path",sobel_image_path)
    		$$invalidate(3, current_time_stamp = $timestamps[plain_pngs_paths_string]);
    	} // current_image_variables = $image_variables[plain_pngs_paths_string]
    	// console.log("$timestamps",$timestamps)

    	// console.log("current_time_stamp",current_time_stamp)
    	// getTimeStamp()
    	let current_time_stamp = "";

    	let current_image_variables = {};

    	// async function getTimeStamp() {
    	//   current_time_stamp = "Loading..."
    	//   const response = await fetch("./get_parsed_timestamp/"+plain_pngs_paths_string);
    	//   const timestamp_retrieved = await response.json();
    	//   console.log("timestamp_retrieved", timestamp_retrieved)
    	//   current_time_stamp = timestamp_retrieved
    	// }  
    	function sobel_change() {
    		$$invalidate(13, isEnabled = !isEnabled);
    	}

    	let image_deleted_success;

    	async function deleteImage() {
    		// console.log("entered delete")
    		const response = await fetch("./delete_image/" + plain_pngs_paths_string + "/" + sobel_jpgs_paths_string + "/" + batch_no.toString());

    		await response.json();

    		// console.log("deleted_message", deleted_message)
    		$$invalidate(14, image_deleted_success = true);

    		get_all_images(batch_no);
    	}

    	let showDeleteImageModal = false;
    	let new_machine_location;
    	let new_product_type;
    	let new_product_container;
    	let new_product_weight;
    	let new_additional_batch_notes;
    	let new_batch_notes;

    	// }
    	// let updateDetail = false;
    	async function updateDetails(detail_key, new_value) {
    		if (new_value === "") {
    			new_value = "nothing_to_see_here";
    		}

    		if (detail_key === "batch_notes" || "additional_batch_notes") {
    			new_value = new_value.replace(/\n/g, " ");
    			console.log("new_value1", new_value);
    		}

    		console.log("detail_key,new_value, batch_no", detail_key, new_value, batch_no);

    		if ($collection_running) {
    			const response = await fetch("./update_completed_batches/" + batch_no + "/" + detail_key + "/" + new_value);
    			const update_completed_batches_response = await response.json();
    			set_store_value(completed_batches, $completed_batches = update_completed_batches_response.completed_batches, $completed_batches);
    			console.log("update_completed_batches_response", update_completed_batches_response);
    		} else {
    			const response = await fetch("./update_completed_collection/" + batch_no + "/" + detail_key + "/" + new_value);
    			const update_completed_collection_response = await response.json();
    			set_store_value(completed_collection, $completed_collection = update_completed_collection_response.completed_collection, $completed_collection);
    			console.log("update_completed_collection_response", update_completed_collection_response);
    		}
    	}

    	function viewVariables() {
    		$$invalidate(9, showViewVariablesModal = true);
    	} // $overflow_create_page = false;
    	// document.getElementById("MyElement").className = "MyClass";

    	async function retrieve_local_details() {
    		const response = await fetch("./retrieve_local_details");
    		const retrieve_local_details_response = await response.json();
    		set_store_value(matching_local_company_names, $matching_local_company_names = retrieve_local_details_response.local_companies, $matching_local_company_names);
    		set_store_value(matching_local_product_names, $matching_local_product_names = retrieve_local_details_response.local_products, $matching_local_product_names);
    		set_store_value(matching_local_user_names, $matching_local_user_names = retrieve_local_details_response.local_users, $matching_local_user_names);
    		set_store_value(matching_local_collection_ids, $matching_local_collection_ids = retrieve_local_details_response.collection_ids, $matching_local_collection_ids);
    		set_store_value(collection_ids, $collection_ids = retrieve_local_details_response.collection_ids, $collection_ids);

    		if (!$local_collection_id) {
    			set_store_value(local_collection_id, $local_collection_id = $matching_local_collection_ids[0], $local_collection_id);
    		}

    		if ($local_collection_id) {
    			send_local_collection_id($local_collection_id);
    		}

    		// const send_collection_id_response = await fetch("./send_collection_id/"+ $local_collection_id)
    		console.log("collection_ids", $matching_local_collection_ids, "local_companies", $matching_local_company_names, "local_products", $matching_local_product_names, "local_users", $matching_local_user_names);
    	}

    	onMount(() => {
    		console.log("$local_collection_id 1", $local_collection_id);
    		get_all_images(batch_no);
    		retrieve_local_details();
    		console.log("$local_collection_id 2", $local_collection_id);
    	});

    	// afterUpdate( () =>
    	// {
    	//   get_all_images(batch_no)
    	// })
    	let variable_search_term = "";

    	async function search_variables(variable_search_term, plain_pngs_paths_string, batch_no) {
    		console.log("search_variables", variable_search_term, plain_pngs_paths_string, batch_no);

    		if (variable_search_term === "") {
    			variable_search_term = "get_all";
    		}

    		// console.log("current_image_variables_test",current_image_variables);
    		const response = await fetch("./search_variables/" + variable_search_term + "/" + plain_pngs_paths_string + "/" + batch_no);

    		const current_image_variables_response = await response.json();
    		$$invalidate(4, current_image_variables = current_image_variables_response);
    	} // console.log("current_image_variables",current_image_variables);

    	let comp_batches = [];

    	// console.log("comp_batches", comp_batches)
    	// const delayModuleLoad = module =>
    	//   new Promise(res =>
    	//     setTimeout(() => res(module), Math.random() * 2000),
    	//   );
    	let promise = isJobsLeft();

    	function isJobsLeft() {
    		if ($number_of_jobs_left === 0) {
    			return "ok";
    		}
    	}

    	// }
    	function closeDeleteImageModal() {
    		$$invalidate(15, showDeleteImageModal = false);
    		$$invalidate(14, image_deleted_success = false);
    	}

    	async function no_local_collection_search_term(collection_type) {
    		console.log("no_local_collection_search_term", collection_type);
    		local_collection_search_term = "get_all";
    		const response = await fetch("./send_local_collection_search_term/" + collection_type + "/" + local_collection_search_term);
    		const send_local_collection_search_term_response = await response.json();
    		console.log("send_local_collection_search_term_response", send_local_collection_search_term_response);
    		local_collection_search_term = "";
    		set_store_value(matching_local_company_names, $matching_local_company_names = send_local_collection_search_term_response.matching_local_company_names, $matching_local_company_names);
    		set_store_value(matching_local_product_names, $matching_local_product_names = send_local_collection_search_term_response.matching_local_product_names, $matching_local_product_names);
    		set_store_value(matching_local_user_names, $matching_local_user_names = send_local_collection_search_term_response.matching_local_user_names, $matching_local_user_names);
    		console.log("$matching_local_company_names", $matching_local_company_names);
    	}

    	let local_collection_search_term = "";

    	async function send_local_collection_search_term(collection_type) {
    		if (collection_type === "company") {
    			console.log("local_company_search_term", $local_company_search_term);
    			local_collection_search_term = $local_company_search_term;

    			if (!local_collection_search_term) {
    				no_local_collection_search_term(collection_type);
    			} else {
    				const response = await fetch("./send_local_collection_search_term/" + collection_type + "/" + local_collection_search_term);
    				const send_local_collection_search_term_response = await response.json();
    				set_store_value(matching_local_company_names, $matching_local_company_names = send_local_collection_search_term_response.matching_local_company_names, $matching_local_company_names);
    				set_store_value(local_company_selection, $local_company_selection = send_local_collection_search_term_response.local_company_selection, $local_company_selection);
    				send_local_company_selection();
    			}
    		} else if (collection_type === "product") {
    			console.log("local_product_search_term", $local_product_search_term);
    			local_collection_search_term = $local_product_search_term;

    			if (!local_collection_search_term) {
    				no_local_collection_search_term(collection_type);
    			} else {
    				const response = await fetch("./send_local_collection_search_term/" + collection_type + "/" + local_collection_search_term);
    				const send_local_collection_search_term_response = await response.json();
    				set_store_value(matching_local_product_names, $matching_local_product_names = send_local_collection_search_term_response.matching_local_product_names, $matching_local_product_names);
    				set_store_value(local_product_selection, $local_product_selection = send_local_collection_search_term_response.local_product_selection, $local_product_selection);
    				send_local_product_selection();
    			}
    		} else if (collection_type === "user") {
    			console.log("local_user_search_term", $local_user_search_term);
    			local_collection_search_term = $local_user_search_term;

    			if (!local_collection_search_term) {
    				no_local_collection_search_term(collection_type);
    			} else {
    				const response = await fetch("./send_local_collection_search_term/" + collection_type + "/" + local_collection_search_term);
    				const send_local_collection_search_term_response = await response.json();
    				set_store_value(matching_local_user_names, $matching_local_user_names = send_local_collection_search_term_response.matching_local_user_names, $matching_local_user_names);
    				set_store_value(local_user_selection, $local_user_selection = send_local_collection_search_term_response.local_user_selection, $local_user_selection);
    				send_local_user_selection();
    			}
    		}
    	}

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<UploadedSoFar> was created with unknown prop '${key}'`);
    	});

    	function textfield0_value_binding(value) {
    		$local_company_search_term = value;
    		local_company_search_term.set($local_company_search_term);
    	}

    	const input_handler = () => send_local_collection_search_term("company");

    	function select1_change_handler() {
    		$local_company_selection = select_value(this);
    		local_company_selection.set($local_company_selection);
    	}

    	const change_handler = () => send_local_company_selection();

    	function textfield1_value_binding(value) {
    		$local_product_search_term = value;
    		local_product_search_term.set($local_product_search_term);
    	}

    	const input_handler_1 = () => send_local_collection_search_term("product");

    	function select3_change_handler() {
    		$local_product_selection = select_value(this);
    		local_product_selection.set($local_product_selection);
    	}

    	const change_handler_1 = () => send_local_product_selection();

    	function textfield2_value_binding(value) {
    		$local_user_search_term = value;
    		local_user_search_term.set($local_user_search_term);
    	}

    	const input_handler_2 = () => send_local_collection_search_term("user");

    	function select5_change_handler() {
    		$local_user_selection = select_value(this);
    		local_user_selection.set($local_user_selection);
    	}

    	const change_handler_2 = () => send_local_user_selection();

    	function select7_change_handler() {
    		$local_collection_id = select_value(this);
    		local_collection_id.set($local_collection_id);
    	}

    	const change_handler_3 = () => send_local_collection_id($local_collection_id);
    	const change_handler_4 = batch_number => get_all_images(batch_number);
    	const change_handler_5 = batch_number => get_all_images(batch_number);

    	function dialog0_value_binding(value) {
    		$showProcessDialog = value;
    		showProcessDialog.set($showProcessDialog);
    	}

    	function slider_value_binding(value) {
    		slider_value = value;
    		$$invalidate(12, slider_value);
    	}

    	function select1_change_handler_1() {
    		batch_no = select_value(this);
    		$$invalidate(6, batch_no);
    	}

    	function select1_change_handler_2() {
    		batch_no = select_value(this);
    		$$invalidate(6, batch_no);
    	}

    	function switch_1_value_binding(value) {
    		isEnabled = value;
    		$$invalidate(13, isEnabled);
    	}

    	const click_handler = () => $$invalidate(15, showDeleteImageModal = true);
    	const click_handler_1 = () => $$invalidate(7, showImageModal = false);

    	function dialog1_value_binding(value) {
    		showImageModal = value;
    		$$invalidate(7, showImageModal);
    	}

    	function input0_input_handler() {
    		new_machine_location = this.value;
    		$$invalidate(16, new_machine_location);
    	}

    	const input_handler_3 = () => updateDetails("machine_location", new_machine_location);

    	function input1_input_handler() {
    		new_product_type = this.value;
    		$$invalidate(17, new_product_type);
    	}

    	const input_handler_4 = () => updateDetails("product_type", new_product_type);

    	function input2_input_handler() {
    		new_product_container = this.value;
    		$$invalidate(18, new_product_container);
    	}

    	const input_handler_5 = () => updateDetails("product_container", new_product_container);

    	function input3_input_handler() {
    		new_product_weight = this.value;
    		$$invalidate(19, new_product_weight);
    	}

    	const input_handler_6 = () => updateDetails("product_weight", new_product_weight);
    	const click_handler_2 = () => $$invalidate(8, showdetailsModal = false);

    	function dialog2_value_binding(value) {
    		showdetailsModal = value;
    		$$invalidate(8, showdetailsModal);
    	}

    	const click_handler_3 = () => $$invalidate(10, show_batch_notes_modal = false);

    	function textarea_input_handler() {
    		new_batch_notes = this.value;
    		$$invalidate(21, new_batch_notes);
    	}

    	const input_handler_7 = () => updateDetails("batch_notes", new_batch_notes);

    	function textarea0_input_handler() {
    		new_batch_notes = this.value;
    		$$invalidate(21, new_batch_notes);
    	}

    	function textarea1_input_handler() {
    		new_additional_batch_notes = this.value;
    		$$invalidate(20, new_additional_batch_notes);
    	}

    	const input_handler_8 = () => updateDetails("additional_batch_notes", new_additional_batch_notes);

    	function dialog3_value_binding(value) {
    		show_batch_notes_modal = value;
    		$$invalidate(10, show_batch_notes_modal);
    	}

    	const click_handler_4 = () => closeDeleteImageModal();
    	const click_handler_5 = () => closeDeleteImageModal();

    	function dialog4_value_binding(value) {
    		showDeleteImageModal = value;
    		$$invalidate(15, showDeleteImageModal);
    	}

    	function textfield_value_binding(value) {
    		variable_search_term = value;
    		$$invalidate(22, variable_search_term);
    	}

    	function dialog5_value_binding(value) {
    		showViewVariablesModal = value;
    		$$invalidate(9, showViewVariablesModal);
    	}

    	$$self.$capture_state = () => ({
    		completed_batches,
    		plain_pngs_paths,
    		sobel_jpgs_paths,
    		timestamps,
    		create_mode_dir,
    		number_of_jobs_left,
    		ready_to_work,
    		collection_running,
    		batches_left_to_process,
    		fetching_images,
    		completed_collection,
    		showProcessDialog,
    		matching_local_company_names,
    		local_company_selection,
    		matching_local_product_names,
    		local_product_selection,
    		matching_local_user_names,
    		local_user_selection,
    		local_company_search_term,
    		local_product_search_term,
    		local_user_search_term,
    		local_collection_id,
    		matching_local_collection_ids,
    		collection_ids,
    		plain_jpgs_paths,
    		image_quality,
    		afterUpdate,
    		beforeUpdate,
    		onMount,
    		Badge,
    		Card,
    		Button,
    		Image: Image_1,
    		Dialog,
    		Switch,
    		TextField,
    		zoom,
    		batch_no,
    		showImageModal,
    		showdetailsModal,
    		showViewVariablesModal,
    		show_batch_notes_modal,
    		openDetailsModal,
    		open_batch_notes_modal,
    		openImageModal,
    		plain_pngs_paths_string,
    		sobel_jpgs_paths_string,
    		plain_jpgs_paths_string,
    		get_all_images,
    		send_local_collection_id,
    		send_local_company_selection,
    		send_local_product_selection,
    		send_local_user_selection,
    		process_batch_images,
    		get_all_completed_batches,
    		Slider,
    		disabled,
    		slider_value,
    		plain_image_path,
    		sobel_image_path,
    		isEnabled,
    		arrowForward,
    		arrowBack,
    		reRenderImages,
    		current_time_stamp,
    		current_image_variables,
    		sobel_change,
    		image_deleted_success,
    		deleteImage,
    		showDeleteImageModal,
    		new_machine_location,
    		new_product_type,
    		new_product_container,
    		new_product_weight,
    		new_additional_batch_notes,
    		new_batch_notes,
    		updateDetails,
    		viewVariables,
    		retrieve_local_details,
    		variable_search_term,
    		search_variables,
    		comp_batches,
    		promise,
    		isJobsLeft,
    		closeDeleteImageModal,
    		no_local_collection_search_term,
    		local_collection_search_term,
    		send_local_collection_search_term,
    		$local_user_selection,
    		$matching_local_user_names,
    		$local_user_search_term,
    		$local_product_selection,
    		$matching_local_product_names,
    		$local_product_search_term,
    		$local_company_selection,
    		$matching_local_company_names,
    		$local_company_search_term,
    		$number_of_jobs_left,
    		$completed_batches,
    		$local_collection_id,
    		$matching_local_collection_ids,
    		$collection_ids,
    		$completed_collection,
    		$collection_running,
    		$timestamps,
    		$create_mode_dir,
    		$image_quality,
    		$plain_jpgs_paths,
    		$sobel_jpgs_paths,
    		$plain_pngs_paths,
    		$ready_to_work,
    		$batches_left_to_process,
    		$fetching_images,
    		$showProcessDialog
    	});

    	$$self.$inject_state = $$props => {
    		if ('batch_no' in $$props) $$invalidate(6, batch_no = $$props.batch_no);
    		if ('showImageModal' in $$props) $$invalidate(7, showImageModal = $$props.showImageModal);
    		if ('showdetailsModal' in $$props) $$invalidate(8, showdetailsModal = $$props.showdetailsModal);
    		if ('showViewVariablesModal' in $$props) $$invalidate(9, showViewVariablesModal = $$props.showViewVariablesModal);
    		if ('show_batch_notes_modal' in $$props) $$invalidate(10, show_batch_notes_modal = $$props.show_batch_notes_modal);
    		if ('plain_pngs_paths_string' in $$props) $$invalidate(11, plain_pngs_paths_string = $$props.plain_pngs_paths_string);
    		if ('sobel_jpgs_paths_string' in $$props) sobel_jpgs_paths_string = $$props.sobel_jpgs_paths_string;
    		if ('plain_jpgs_paths_string' in $$props) plain_jpgs_paths_string = $$props.plain_jpgs_paths_string;
    		if ('disabled' in $$props) $$invalidate(52, disabled = $$props.disabled);
    		if ('slider_value' in $$props) $$invalidate(12, slider_value = $$props.slider_value);
    		if ('plain_image_path' in $$props) $$invalidate(1, plain_image_path = $$props.plain_image_path);
    		if ('sobel_image_path' in $$props) $$invalidate(2, sobel_image_path = $$props.sobel_image_path);
    		if ('isEnabled' in $$props) $$invalidate(13, isEnabled = $$props.isEnabled);
    		if ('current_time_stamp' in $$props) $$invalidate(3, current_time_stamp = $$props.current_time_stamp);
    		if ('current_image_variables' in $$props) $$invalidate(4, current_image_variables = $$props.current_image_variables);
    		if ('image_deleted_success' in $$props) $$invalidate(14, image_deleted_success = $$props.image_deleted_success);
    		if ('showDeleteImageModal' in $$props) $$invalidate(15, showDeleteImageModal = $$props.showDeleteImageModal);
    		if ('new_machine_location' in $$props) $$invalidate(16, new_machine_location = $$props.new_machine_location);
    		if ('new_product_type' in $$props) $$invalidate(17, new_product_type = $$props.new_product_type);
    		if ('new_product_container' in $$props) $$invalidate(18, new_product_container = $$props.new_product_container);
    		if ('new_product_weight' in $$props) $$invalidate(19, new_product_weight = $$props.new_product_weight);
    		if ('new_additional_batch_notes' in $$props) $$invalidate(20, new_additional_batch_notes = $$props.new_additional_batch_notes);
    		if ('new_batch_notes' in $$props) $$invalidate(21, new_batch_notes = $$props.new_batch_notes);
    		if ('variable_search_term' in $$props) $$invalidate(22, variable_search_term = $$props.variable_search_term);
    		if ('comp_batches' in $$props) comp_batches = $$props.comp_batches;
    		if ('promise' in $$props) promise = $$props.promise;
    		if ('local_collection_search_term' in $$props) local_collection_search_term = $$props.local_collection_search_term;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*sobel_image_path*/ 4) ;

    		if ($$self.$$.dirty[0] & /*plain_image_path*/ 2) ;

    		if ($$self.$$.dirty[0] & /*current_time_stamp*/ 8) ;

    		if ($$self.$$.dirty[0] & /*current_image_variables*/ 16) ;

    		if ($$self.$$.dirty[0] & /*$completed_batches*/ 32) {
    			comp_batches = $completed_batches;
    		}
    	};

    	$$invalidate(12, slider_value = 1);
    	$$invalidate(14, image_deleted_success = "");

    	// let machine_location_string = {"<span class:subtitle-1>Machine Location: </span>"};
    	// if ($completed_batches){
    	//   console.log($completed_batches)
    	$$invalidate(16, new_machine_location = "");

    	$$invalidate(17, new_product_type = "");
    	$$invalidate(18, new_product_container = "");
    	$$invalidate(19, new_product_weight = "");
    	$$invalidate(21, new_batch_notes = "");
    	$$invalidate(20, new_additional_batch_notes = "");

    	return [
    		get_all_images,
    		plain_image_path,
    		sobel_image_path,
    		current_time_stamp,
    		current_image_variables,
    		$completed_batches,
    		batch_no,
    		showImageModal,
    		showdetailsModal,
    		showViewVariablesModal,
    		show_batch_notes_modal,
    		plain_pngs_paths_string,
    		slider_value,
    		isEnabled,
    		image_deleted_success,
    		showDeleteImageModal,
    		new_machine_location,
    		new_product_type,
    		new_product_container,
    		new_product_weight,
    		new_additional_batch_notes,
    		new_batch_notes,
    		variable_search_term,
    		$local_user_selection,
    		$matching_local_user_names,
    		$local_user_search_term,
    		$local_product_selection,
    		$matching_local_product_names,
    		$local_product_search_term,
    		$local_company_selection,
    		$matching_local_company_names,
    		$local_company_search_term,
    		$number_of_jobs_left,
    		$local_collection_id,
    		$matching_local_collection_ids,
    		$collection_ids,
    		$completed_collection,
    		$collection_running,
    		$create_mode_dir,
    		$plain_pngs_paths,
    		$ready_to_work,
    		$batches_left_to_process,
    		$fetching_images,
    		$showProcessDialog,
    		openDetailsModal,
    		open_batch_notes_modal,
    		openImageModal,
    		send_local_collection_id,
    		send_local_company_selection,
    		send_local_product_selection,
    		send_local_user_selection,
    		get_all_completed_batches,
    		disabled,
    		arrowForward,
    		arrowBack,
    		reRenderImages,
    		sobel_change,
    		deleteImage,
    		updateDetails,
    		viewVariables,
    		search_variables,
    		closeDeleteImageModal,
    		send_local_collection_search_term,
    		textfield0_value_binding,
    		input_handler,
    		select1_change_handler,
    		change_handler,
    		textfield1_value_binding,
    		input_handler_1,
    		select3_change_handler,
    		change_handler_1,
    		textfield2_value_binding,
    		input_handler_2,
    		select5_change_handler,
    		change_handler_2,
    		select7_change_handler,
    		change_handler_3,
    		change_handler_4,
    		change_handler_5,
    		dialog0_value_binding,
    		slider_value_binding,
    		select1_change_handler_1,
    		select1_change_handler_2,
    		switch_1_value_binding,
    		click_handler,
    		click_handler_1,
    		dialog1_value_binding,
    		input0_input_handler,
    		input_handler_3,
    		input1_input_handler,
    		input_handler_4,
    		input2_input_handler,
    		input_handler_5,
    		input3_input_handler,
    		input_handler_6,
    		click_handler_2,
    		dialog2_value_binding,
    		click_handler_3,
    		textarea_input_handler,
    		input_handler_7,
    		textarea0_input_handler,
    		textarea1_input_handler,
    		input_handler_8,
    		dialog3_value_binding,
    		click_handler_4,
    		click_handler_5,
    		dialog4_value_binding,
    		textfield_value_binding,
    		dialog5_value_binding
    	];
    }

    class UploadedSoFar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { get_all_images: 0 }, null, [-1, -1, -1, -1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UploadedSoFar",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get get_all_images() {
    		return this.$$.ctx[0];
    	}

    	set get_all_images(value) {
    		throw new Error("<UploadedSoFar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Create/OpenUploadedSoFar.svelte generated by Svelte v3.40.3 */
    const file$8 = "src/Create/OpenUploadedSoFar.svelte";

    // (27:0) {:else}
    function create_else_block$1(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block0 = /*isOpen*/ ctx[0] && create_if_block_4$1(ctx);
    	let if_block1 = !/*isOpen*/ ctx[0] && create_if_block_3$1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			add_location(div, file$8, 27, 8, 868);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isOpen*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(27:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (14:0) {#if $collection_running}
    function create_if_block$4(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block0 = /*isOpen*/ ctx[0] && create_if_block_2$1(ctx);
    	let if_block1 = !/*isOpen*/ ctx[0] && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			add_location(div, file$8, 14, 8, 489);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isOpen*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(14:0) {#if $collection_running}",
    		ctx
    	});

    	return block;
    }

    // (29:12) {#if isOpen }
    function create_if_block_4$1(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "light",
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(29:12) {#if isOpen }",
    		ctx
    	});

    	return block;
    }

    // (30:12) <Button  size="lg"  color = "light"   on:click={handleClick} >
    function create_default_slot_4$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Local Collections");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(30:12) <Button  size=\\\"lg\\\"  color = \\\"light\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (34:8) {#if !isOpen }
    function create_if_block_3$1(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "info",
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(34:8) {#if !isOpen }",
    		ctx
    	});

    	return block;
    }

    // (35:12) <Button   size="lg"    color = "info"   on:click={handleClick} >
    function create_default_slot_3$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Local Collections");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(35:12) <Button   size=\\\"lg\\\"    color = \\\"info\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (16:12) {#if isOpen }
    function create_if_block_2$1(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "light",
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(16:12) {#if isOpen }",
    		ctx
    	});

    	return block;
    }

    // (17:12) <Button  size="lg"  color = "light"   on:click={handleClick} >
    function create_default_slot_2$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Completed Batches");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(17:12) <Button  size=\\\"lg\\\"  color = \\\"light\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (21:8) {#if !isOpen }
    function create_if_block_1$3(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "info",
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(21:8) {#if !isOpen }",
    		ctx
    	});

    	return block;
    }

    // (22:12) <Button   size="lg"    color = "info"   on:click={handleClick} >
    function create_default_slot_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Completed Batches");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(22:12) <Button   size=\\\"lg\\\"    color = \\\"info\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (44:4) <Fade {isOpen} >
    function create_default_slot$6(ctx) {
    	let div;
    	let uploadedsofar;
    	let current;
    	uploadedsofar = new UploadedSoFar({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(uploadedsofar.$$.fragment);
    			add_location(div, file$8, 45, 8, 1305);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(uploadedsofar, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(uploadedsofar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(uploadedsofar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(uploadedsofar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(44:4) <Fade {isOpen} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div;
    	let fade;
    	let current;
    	const if_block_creators = [create_if_block$4, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$collection_running*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	fade = new Fade({
    			props: {
    				isOpen: /*isOpen*/ ctx[0],
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if_block.c();
    			t = space();
    			div = element("div");
    			create_component(fade.$$.fragment);
    			attr_dev(div, "class", "col-md-9  offset-md-2");
    			add_location(div, file$8, 42, 0, 1239);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(fade, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(t.parentNode, t);
    			}

    			const fade_changes = {};
    			if (dirty & /*isOpen*/ 1) fade_changes.isOpen = /*isOpen*/ ctx[0];

    			if (dirty & /*$$scope*/ 8) {
    				fade_changes.$$scope = { dirty, ctx };
    			}

    			fade.$set(fade_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(fade.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(fade.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_component(fade);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $collection_running;
    	validate_store(collection_running, 'collection_running');
    	component_subscribe($$self, collection_running, $$value => $$invalidate(1, $collection_running = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OpenUploadedSoFar', slots, []);
    	let isOpen = true;

    	function handleClick() {
    		$$invalidate(0, isOpen = !isOpen);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OpenUploadedSoFar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Fade,
    		Button: Button$1,
    		BatchRun,
    		UploadedSoFar,
    		isOpen,
    		handleClick,
    		collection_running,
    		$collection_running
    	});

    	$$self.$inject_state = $$props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isOpen, $collection_running, handleClick];
    }

    class OpenUploadedSoFar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OpenUploadedSoFar",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src/Create/CollectionRun.svelte generated by Svelte v3.40.3 */

    const { console: console_1$1 } = globals;

    const file$7 = "src/Create/CollectionRun.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[70] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[70] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[70] = list[i];
    	return child_ctx;
    }

    // (320:32) {#each $matching_company_names as collection_name}
    function create_each_block_2(ctx) {
    	let option;
    	let t_value = /*collection_name*/ ctx[70] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*collection_name*/ ctx[70];
    			option.value = option.__value;
    			add_location(option, file$7, 320, 36, 13092);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$matching_company_names*/ 524288 && t_value !== (t_value = /*collection_name*/ ctx[70] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$matching_company_names*/ 524288 && option_value_value !== (option_value_value = /*collection_name*/ ctx[70])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(320:32) {#each $matching_company_names as collection_name}",
    		ctx
    	});

    	return block;
    }

    // (333:36) <Button outlined on:click={() => add_to_collection("company")} color="blue">
    function create_default_slot_29(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create New Company");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_29.name,
    		type: "slot",
    		source: "(333:36) <Button outlined on:click={() => add_to_collection(\\\"company\\\")} color=\\\"blue\\\">",
    		ctx
    	});

    	return block;
    }

    // (333:28) <Label >
    function create_default_slot_28(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				outlined: true,
    				color: "blue",
    				$$slots: { default: [create_default_slot_29] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_1*/ ctx[40]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_28.name,
    		type: "slot",
    		source: "(333:28) <Label >",
    		ctx
    	});

    	return block;
    }

    // (331:24) <FormGroup>
    function create_default_slot_27(ctx) {
    	let textfield;
    	let updating_value;
    	let t;
    	let label;
    	let current;

    	function textfield_value_binding_1(value) {
    		/*textfield_value_binding_1*/ ctx[39](value);
    	}

    	let textfield_props = {
    		label: "Type New Company Name",
    		maxlength: "50",
    		color: "blue",
    		outlined: true
    	};

    	if (/*$new_collection_name*/ ctx[16] !== void 0) {
    		textfield_props.value = /*$new_collection_name*/ ctx[16];
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_1));

    	label = new Label$2({
    			props: {
    				$$slots: { default: [create_default_slot_28] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(textfield.$$.fragment);
    			t = space();
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textfield, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty[0] & /*$new_collection_name*/ 65536) {
    				updating_value = true;
    				textfield_changes.value = /*$new_collection_name*/ ctx[16];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    			const label_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textfield, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_27.name,
    		type: "slot",
    		source: "(331:24) <FormGroup>",
    		ctx
    	});

    	return block;
    }

    // (311:16) <Tab id="1" {selected}  >
    function create_default_slot_26(ctx) {
    	let div0;
    	let textfield;
    	let updating_value;
    	let t0;
    	let select1;
    	let select0;
    	let t1;
    	let div1;
    	let h4;
    	let t3;
    	let div2;
    	let formgroup;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[34](value);
    	}

    	let textfield_props = {
    		label: "Search Company",
    		color: "blue",
    		outlined: true
    	};

    	if (/*$company_search_term*/ ctx[15] !== void 0) {
    		textfield_props.value = /*$company_search_term*/ ctx[15];
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));
    	textfield.$on("input", /*input_handler*/ ctx[35]);
    	let each_value_2 = /*$matching_company_names*/ ctx[19];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	formgroup = new FormGroup({
    			props: {
    				$$slots: { default: [create_default_slot_27] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(textfield.$$.fragment);
    			t0 = text("\n                            \n                        \n                            Select Company:\n                             \n                            ");
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			select0 = element("select");
    			t1 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Or";
    			t3 = space();
    			div2 = element("div");
    			create_component(formgroup.$$.fragment);
    			add_location(select0, file$7, 322, 28, 13221);
    			attr_dev(select1, "open", "");
    			if (/*$company_selection*/ ctx[9] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[36].call(select1));
    			add_location(select1, file$7, 317, 28, 12767);
    			attr_dev(div0, "class", "col-md-3 offset-md-2 ");
    			add_location(div0, file$7, 311, 20, 12301);
    			add_location(h4, file$7, 325, 20, 13345);
    			attr_dev(div1, "class", " col-md-1 offset-md-1 text-center");
    			add_location(div1, file$7, 324, 20, 13277);
    			attr_dev(div2, "class", "col-md-3 offset-md-1 ");
    			add_location(div2, file$7, 327, 20, 13405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(textfield, div0, null);
    			append_dev(div0, t0);
    			append_dev(div0, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			append_dev(select1, select0);
    			select_option(select1, /*$company_selection*/ ctx[9]);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h4);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(formgroup, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[36]),
    					listen_dev(select1, "change", /*change_handler*/ ctx[37], false, false, false),
    					listen_dev(div0, "mousemove", /*mousemove_handler*/ ctx[38], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty[0] & /*$company_search_term*/ 32768) {
    				updating_value = true;
    				textfield_changes.value = /*$company_search_term*/ ctx[15];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);

    			if (dirty[0] & /*$matching_company_names*/ 524288) {
    				each_value_2 = /*$matching_company_names*/ ctx[19];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, select0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}

    			if (dirty[0] & /*$company_selection, $matching_company_names*/ 524800) {
    				select_option(select1, /*$company_selection*/ ctx[9]);
    			}

    			const formgroup_changes = {};

    			if (dirty[0] & /*$new_collection_name*/ 65536 | dirty[2] & /*$$scope*/ 32768) {
    				formgroup_changes.$$scope = { dirty, ctx };
    			}

    			formgroup.$set(formgroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			transition_in(formgroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			transition_out(formgroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(textfield);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			destroy_component(formgroup);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26.name,
    		type: "slot",
    		source: "(311:16) <Tab id=\\\"1\\\" {selected}  >",
    		ctx
    	});

    	return block;
    }

    // (347:32) {#each $matching_product_names as collection_name}
    function create_each_block_1(ctx) {
    	let option;
    	let t_value = /*collection_name*/ ctx[70] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*collection_name*/ ctx[70];
    			option.value = option.__value;
    			add_location(option, file$7, 347, 36, 14741);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$matching_product_names*/ 262144 && t_value !== (t_value = /*collection_name*/ ctx[70] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$matching_product_names*/ 262144 && option_value_value !== (option_value_value = /*collection_name*/ ctx[70])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(347:32) {#each $matching_product_names as collection_name}",
    		ctx
    	});

    	return block;
    }

    // (361:36) <Button outlined on:click={() => add_to_collection("product")} color="blue">
    function create_default_slot_25(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create New Product");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25.name,
    		type: "slot",
    		source: "(361:36) <Button outlined on:click={() => add_to_collection(\\\"product\\\")} color=\\\"blue\\\">",
    		ctx
    	});

    	return block;
    }

    // (361:28) <Label >
    function create_default_slot_24(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				outlined: true,
    				color: "blue",
    				$$slots: { default: [create_default_slot_25] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_2*/ ctx[45]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24.name,
    		type: "slot",
    		source: "(361:28) <Label >",
    		ctx
    	});

    	return block;
    }

    // (359:24) <FormGroup>
    function create_default_slot_23(ctx) {
    	let textfield;
    	let updating_value;
    	let t;
    	let label;
    	let current;

    	function textfield_value_binding_3(value) {
    		/*textfield_value_binding_3*/ ctx[44](value);
    	}

    	let textfield_props = {
    		label: "Type New Product Name",
    		maxlength: "50",
    		color: "blue",
    		outlined: true
    	};

    	if (/*$new_collection_name*/ ctx[16] !== void 0) {
    		textfield_props.value = /*$new_collection_name*/ ctx[16];
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_3));

    	label = new Label$2({
    			props: {
    				$$slots: { default: [create_default_slot_24] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(textfield.$$.fragment);
    			t = space();
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textfield, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty[0] & /*$new_collection_name*/ 65536) {
    				updating_value = true;
    				textfield_changes.value = /*$new_collection_name*/ ctx[16];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    			const label_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textfield, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23.name,
    		type: "slot",
    		source: "(359:24) <FormGroup>",
    		ctx
    	});

    	return block;
    }

    // (338:16) <Tab id="2" {selected}  >
    function create_default_slot_22(ctx) {
    	let div0;
    	let textfield;
    	let updating_value;
    	let t0;
    	let select1;
    	let select0;
    	let t1;
    	let div1;
    	let h4;
    	let t3;
    	let div2;
    	let formgroup;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield_value_binding_2(value) {
    		/*textfield_value_binding_2*/ ctx[41](value);
    	}

    	let textfield_props = {
    		label: "Search Product",
    		color: "blue",
    		outlined: true
    	};

    	if (/*$product_search_term*/ ctx[13] !== void 0) {
    		textfield_props.value = /*$product_search_term*/ ctx[13];
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_2));
    	textfield.$on("input", /*input_handler_1*/ ctx[42]);
    	let each_value_1 = /*$matching_product_names*/ ctx[18];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	formgroup = new FormGroup({
    			props: {
    				$$slots: { default: [create_default_slot_23] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(textfield.$$.fragment);
    			t0 = text("\n                            \n                        \n                            Select Product:\n                             \n                            ");
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			select0 = element("select");
    			t1 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Or";
    			t3 = space();
    			div2 = element("div");
    			create_component(formgroup.$$.fragment);
    			add_location(select0, file$7, 349, 28, 14871);
    			attr_dev(select1, "open", "");
    			if (/*$product_selection*/ ctx[8] === void 0) add_render_callback(() => /*select1_change_handler_1*/ ctx[43].call(select1));
    			add_location(select1, file$7, 344, 28, 14434);
    			attr_dev(div0, "class", "col-md-3 offset-md-2 ");
    			add_location(div0, file$7, 338, 20, 13988);
    			add_location(h4, file$7, 353, 24, 15000);
    			attr_dev(div1, "class", "col-md-1 offset-md-1 text-center");
    			add_location(div1, file$7, 352, 20, 14929);
    			attr_dev(div2, "class", "col-md-3 offset-md-1 ");
    			add_location(div2, file$7, 355, 20, 15060);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(textfield, div0, null);
    			append_dev(div0, t0);
    			append_dev(div0, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			append_dev(select1, select0);
    			select_option(select1, /*$product_selection*/ ctx[8]);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h4);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(formgroup, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select1, "change", /*select1_change_handler_1*/ ctx[43]),
    					listen_dev(select1, "change", /*send_product_selection*/ ctx[26], false, false, false),
    					listen_dev(div0, "mousemove", /*send_product_selection*/ ctx[26], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty[0] & /*$product_search_term*/ 8192) {
    				updating_value = true;
    				textfield_changes.value = /*$product_search_term*/ ctx[13];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);

    			if (dirty[0] & /*$matching_product_names*/ 262144) {
    				each_value_1 = /*$matching_product_names*/ ctx[18];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, select0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty[0] & /*$product_selection, $matching_product_names*/ 262400) {
    				select_option(select1, /*$product_selection*/ ctx[8]);
    			}

    			const formgroup_changes = {};

    			if (dirty[0] & /*$new_collection_name*/ 65536 | dirty[2] & /*$$scope*/ 32768) {
    				formgroup_changes.$$scope = { dirty, ctx };
    			}

    			formgroup.$set(formgroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			transition_in(formgroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			transition_out(formgroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(textfield);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			destroy_component(formgroup);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22.name,
    		type: "slot",
    		source: "(338:16) <Tab id=\\\"2\\\" {selected}  >",
    		ctx
    	});

    	return block;
    }

    // (375:32) {#each $matching_user_names as collection_name}
    function create_each_block(ctx) {
    	let option;
    	let t_value = /*collection_name*/ ctx[70] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*collection_name*/ ctx[70];
    			option.value = option.__value;
    			add_location(option, file$7, 375, 36, 16379);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$matching_user_names*/ 131072 && t_value !== (t_value = /*collection_name*/ ctx[70] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$matching_user_names*/ 131072 && option_value_value !== (option_value_value = /*collection_name*/ ctx[70])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(375:32) {#each $matching_user_names as collection_name}",
    		ctx
    	});

    	return block;
    }

    // (389:36) <Button outlined on:click={() => add_to_collection("user")} color="blue">
    function create_default_slot_21(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create New User");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21.name,
    		type: "slot",
    		source: "(389:36) <Button outlined on:click={() => add_to_collection(\\\"user\\\")} color=\\\"blue\\\">",
    		ctx
    	});

    	return block;
    }

    // (389:28) <Label >
    function create_default_slot_20(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				outlined: true,
    				color: "blue",
    				$$slots: { default: [create_default_slot_21] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_3*/ ctx[50]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20.name,
    		type: "slot",
    		source: "(389:28) <Label >",
    		ctx
    	});

    	return block;
    }

    // (387:24) <FormGroup>
    function create_default_slot_19(ctx) {
    	let textfield;
    	let updating_value;
    	let t;
    	let label;
    	let current;

    	function textfield_value_binding_5(value) {
    		/*textfield_value_binding_5*/ ctx[49](value);
    	}

    	let textfield_props = {
    		label: "Type New User Name",
    		maxlength: "50",
    		color: "blue",
    		outlined: true
    	};

    	if (/*$new_collection_name*/ ctx[16] !== void 0) {
    		textfield_props.value = /*$new_collection_name*/ ctx[16];
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_5));

    	label = new Label$2({
    			props: {
    				$$slots: { default: [create_default_slot_20] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(textfield.$$.fragment);
    			t = space();
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textfield, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty[0] & /*$new_collection_name*/ 65536) {
    				updating_value = true;
    				textfield_changes.value = /*$new_collection_name*/ ctx[16];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    			const label_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textfield, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(387:24) <FormGroup>",
    		ctx
    	});

    	return block;
    }

    // (366:16) <Tab id="3" {selected} >
    function create_default_slot_18(ctx) {
    	let div0;
    	let textfield;
    	let updating_value;
    	let t0;
    	let select1;
    	let select0;
    	let t1;
    	let div1;
    	let h4;
    	let t3;
    	let div2;
    	let formgroup;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield_value_binding_4(value) {
    		/*textfield_value_binding_4*/ ctx[46](value);
    	}

    	let textfield_props = {
    		label: "Search User",
    		color: "blue",
    		outlined: true
    	};

    	if (/*$user_search_term*/ ctx[11] !== void 0) {
    		textfield_props.value = /*$user_search_term*/ ctx[11];
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_4));
    	textfield.$on("input", /*input_handler_2*/ ctx[47]);
    	let each_value = /*$matching_user_names*/ ctx[17];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	formgroup = new FormGroup({
    			props: {
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(textfield.$$.fragment);
    			t0 = text("\n                            \n                        \n                            Select User:\n                             \n                            ");
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			select0 = element("select");
    			t1 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Or";
    			t3 = space();
    			div2 = element("div");
    			create_component(formgroup.$$.fragment);
    			add_location(select0, file$7, 377, 28, 16508);
    			attr_dev(select1, "selected", "");
    			attr_dev(select1, "open", "");
    			if (/*$user_selection*/ ctx[7] === void 0) add_render_callback(() => /*select1_change_handler_2*/ ctx[48].call(select1));
    			add_location(select1, file$7, 372, 28, 16072);
    			attr_dev(div0, "class", "col-md-3 offset-md-2 ");
    			add_location(div0, file$7, 366, 20, 15641);
    			add_location(h4, file$7, 381, 24, 16637);
    			attr_dev(div1, "class", "col-md-1 offset-md-1 text-center");
    			add_location(div1, file$7, 380, 20, 16566);
    			attr_dev(div2, "class", "col-md-3 offset-md-1 ");
    			add_location(div2, file$7, 383, 20, 16697);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(textfield, div0, null);
    			append_dev(div0, t0);
    			append_dev(div0, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			append_dev(select1, select0);
    			select_option(select1, /*$user_selection*/ ctx[7]);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h4);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(formgroup, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select1, "change", /*select1_change_handler_2*/ ctx[48]),
    					listen_dev(select1, "change", /*send_user_selection*/ ctx[27], false, false, false),
    					listen_dev(div0, "mousemove", /*send_user_selection*/ ctx[27], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty[0] & /*$user_search_term*/ 2048) {
    				updating_value = true;
    				textfield_changes.value = /*$user_search_term*/ ctx[11];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);

    			if (dirty[0] & /*$matching_user_names*/ 131072) {
    				each_value = /*$matching_user_names*/ ctx[17];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, select0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*$user_selection, $matching_user_names*/ 131200) {
    				select_option(select1, /*$user_selection*/ ctx[7]);
    			}

    			const formgroup_changes = {};

    			if (dirty[0] & /*$new_collection_name*/ 65536 | dirty[2] & /*$$scope*/ 32768) {
    				formgroup_changes.$$scope = { dirty, ctx };
    			}

    			formgroup.$set(formgroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			transition_in(formgroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			transition_out(formgroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(textfield);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			destroy_component(formgroup);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(366:16) <Tab id=\\\"3\\\" {selected} >",
    		ctx
    	});

    	return block;
    }

    // (307:12) 
    function create_content_slot(ctx) {
    	let div;
    	let tab0;
    	let t0;
    	let tab1;
    	let t1;
    	let tab2;
    	let current;

    	tab0 = new Tab({
    			props: {
    				id: "1",
    				selected: /*selected*/ ctx[69],
    				$$slots: { default: [create_default_slot_26] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab1 = new Tab({
    			props: {
    				id: "2",
    				selected: /*selected*/ ctx[69],
    				$$slots: { default: [create_default_slot_22] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab2 = new Tab({
    			props: {
    				id: "3",
    				selected: /*selected*/ ctx[69],
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tab0.$$.fragment);
    			t0 = space();
    			create_component(tab1.$$.fragment);
    			t1 = space();
    			create_component(tab2.$$.fragment);
    			attr_dev(div, "slot", "content");
    			attr_dev(div, "class", "flex items-stretch md:items-center content-center overflow-hidden w-full bg-white shadow h-full");
    			set_style(div, "height", "250px");
    			add_location(div, file$7, 306, 12, 12044);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tab0, div, null);
    			append_dev(div, t0);
    			mount_component(tab1, div, null);
    			append_dev(div, t1);
    			mount_component(tab2, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab0_changes = {};
    			if (dirty[2] & /*selected*/ 128) tab0_changes.selected = /*selected*/ ctx[69];

    			if (dirty[0] & /*$new_collection_name, $company_selection, $matching_company_names, $company_search_term*/ 623104 | dirty[2] & /*$$scope*/ 32768) {
    				tab0_changes.$$scope = { dirty, ctx };
    			}

    			tab0.$set(tab0_changes);
    			const tab1_changes = {};
    			if (dirty[2] & /*selected*/ 128) tab1_changes.selected = /*selected*/ ctx[69];

    			if (dirty[0] & /*$new_collection_name, $product_selection, $matching_product_names, $product_search_term*/ 336128 | dirty[2] & /*$$scope*/ 32768) {
    				tab1_changes.$$scope = { dirty, ctx };
    			}

    			tab1.$set(tab1_changes);
    			const tab2_changes = {};
    			if (dirty[2] & /*selected*/ 128) tab2_changes.selected = /*selected*/ ctx[69];

    			if (dirty[0] & /*$new_collection_name, $user_selection, $matching_user_names, $user_search_term*/ 198784 | dirty[2] & /*$$scope*/ 32768) {
    				tab2_changes.$$scope = { dirty, ctx };
    			}

    			tab2.$set(tab2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			transition_in(tab2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			transition_out(tab2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tab0);
    			destroy_component(tab1);
    			destroy_component(tab2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot.name,
    		type: "slot",
    		source: "(307:12) ",
    		ctx
    	});

    	return block;
    }

    // (288:0) <Dialog  bind:value={showDialog}  >
    function create_default_slot_17(ctx) {
    	let div;
    	let tabs;
    	let current;

    	tabs = new Tabs({
    			props: {
    				selected: /*tab_selected*/ ctx[2],
    				class: "bg-grey-300 shadow-sm mt-6 text-grey-500",
    				color: "blue",
    				notSelectedColor: "light",
    				loading: /*loading*/ ctx[31],
    				items: [
    					{
    						id: '1',
    						text: 'Company',
    						icon: 'business'
    					},
    					{
    						id: '2',
    						text: 'Product',
    						icon: 'restaurant'
    					},
    					{ id: '3', text: 'User', icon: 'face' }
    				],
    				$$slots: {
    					content: [
    						create_content_slot,
    						({ selected }) => ({ 69: selected }),
    						({ selected }) => [0, 0, selected ? 128 : 0]
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tabs.$$.fragment);
    			set_style(div, "width", "1300px");
    			add_location(div, file$7, 292, 4, 11557);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tabs, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabs_changes = {};
    			if (dirty[0] & /*tab_selected*/ 4) tabs_changes.selected = /*tab_selected*/ ctx[2];

    			if (dirty[0] & /*$new_collection_name, $user_selection, $matching_user_names, $user_search_term, $product_selection, $matching_product_names, $product_search_term, $company_selection, $matching_company_names, $company_search_term*/ 1026944 | dirty[2] & /*$$scope, selected*/ 32896) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tabs);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(288:0) <Dialog  bind:value={showDialog}  >",
    		ctx
    	});

    	return block;
    }

    // (399:8) <Button color="blue" text on:click={() => showDialog = false}>
    function create_default_slot_16(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Done");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(399:8) <Button color=\\\"blue\\\" text on:click={() => showDialog = false}>",
    		ctx
    	});

    	return block;
    }

    // (398:4) 
    function create_actions_slot(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				text: true,
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[33]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "flex justify-center");
    			attr_dev(div, "slot", "actions");
    			add_location(div, file$7, 397, 4, 17267);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_actions_slot.name,
    		type: "slot",
    		source: "(398:4) ",
    		ctx
    	});

    	return block;
    }

    // (432:16) {:else}
    function create_else_block_2(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				icon: "business",
    				color: "dark",
    				outlined: true,
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_5*/ ctx[53]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(432:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (410:16) {#if $is_company_selected}
    function create_if_block_15(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_16, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*alert_collection_running*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(410:16) {#if $is_company_selected}",
    		ctx
    	});

    	return block;
    }

    // (433:20) <Button                     icon="business"                     color="dark"                     outlined                     on:click={() => handleClick("company")}                     >
    function create_default_slot_15(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Company");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(433:20) <Button                     icon=\\\"business\\\"                     color=\\\"dark\\\"                     outlined                     on:click={() => handleClick(\\\"company\\\")}                     >",
    		ctx
    	});

    	return block;
    }

    // (420:20) {:else}
    function create_else_block_1(ctx) {
    	let button;
    	let t0;
    	let div;
    	let h6;
    	let t1;
    	let current;

    	button = new Button({
    			props: {
    				icon: "business",
    				color: "blue",
    				outlined: true,
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_4*/ ctx[52]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t0 = space();
    			div = element("div");
    			h6 = element("h6");
    			t1 = text(/*$company_selection*/ ctx[9]);
    			add_location(h6, file$7, 427, 30, 18403);
    			add_location(div, file$7, 427, 24, 18397);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, h6);
    			append_dev(h6, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			if (!current || dirty[0] & /*$company_selection*/ 512) set_data_dev(t1, /*$company_selection*/ ctx[9]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(420:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (411:20) {#if alert_collection_running}
    function create_if_block_16(ctx) {
    	let button;
    	let t0;
    	let div;
    	let h6;
    	let t1;
    	let current;

    	button = new Button({
    			props: {
    				icon: "business",
    				color: "blue",
    				outlined: true,
    				$$slots: { default: [create_default_slot_13$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t0 = space();
    			div = element("div");
    			h6 = element("h6");
    			t1 = text(/*$company_selection*/ ctx[9]);
    			add_location(h6, file$7, 417, 29, 18015);
    			add_location(div, file$7, 417, 24, 18010);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, h6);
    			append_dev(h6, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			if (!current || dirty[0] & /*$company_selection*/ 512) set_data_dev(t1, /*$company_selection*/ ctx[9]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(411:20) {#if alert_collection_running}",
    		ctx
    	});

    	return block;
    }

    // (421:24) <Button                                                  icon="business"                         color="blue"                         outlined                         on:click={() => handleClick("company")}                         >
    function create_default_slot_14(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Company");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(421:24) <Button                                                  icon=\\\"business\\\"                         color=\\\"blue\\\"                         outlined                         on:click={() => handleClick(\\\"company\\\")}                         >",
    		ctx
    	});

    	return block;
    }

    // (412:24) <Button                                                          icon="business"                         color="blue"                         outlined                         >
    function create_default_slot_13$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Company");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$1.name,
    		type: "slot",
    		source: "(412:24) <Button                                                          icon=\\\"business\\\"                         color=\\\"blue\\\"                         outlined                         >",
    		ctx
    	});

    	return block;
    }

    // (449:16) {#if $is_product_selected}
    function create_if_block_12(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*alert_collection_running*/ ctx[1] && create_if_block_14(ctx);
    	let if_block1 = !/*alert_collection_running*/ ctx[1] && create_if_block_13(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*alert_collection_running*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*alert_collection_running*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_14(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*alert_collection_running*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*alert_collection_running*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_13(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(449:16) {#if $is_product_selected}",
    		ctx
    	});

    	return block;
    }

    // (451:20) {#if alert_collection_running}
    function create_if_block_14(ctx) {
    	let button;
    	let t0;
    	let h6;
    	let t1;
    	let current;

    	button = new Button({
    			props: {
    				icon: "restaurant",
    				color: "blue",
    				outlined: true,
    				$$slots: { default: [create_default_slot_12$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t0 = space();
    			h6 = element("h6");
    			t1 = text(/*$product_selection*/ ctx[8]);
    			add_location(h6, file$7, 456, 24, 19245);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			if (!current || dirty[0] & /*$product_selection*/ 256) set_data_dev(t1, /*$product_selection*/ ctx[8]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(451:20) {#if alert_collection_running}",
    		ctx
    	});

    	return block;
    }

    // (452:24) <Button                         icon="restaurant"                         color="blue"                         outlined                         >
    function create_default_slot_12$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Product");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$1.name,
    		type: "slot",
    		source: "(452:24) <Button                         icon=\\\"restaurant\\\"                         color=\\\"blue\\\"                         outlined                         >",
    		ctx
    	});

    	return block;
    }

    // (459:20) {#if !alert_collection_running}
    function create_if_block_13(ctx) {
    	let button;
    	let t0;
    	let h6;
    	let t1;
    	let current;

    	button = new Button({
    			props: {
    				icon: "restaurant",
    				color: "blue",
    				outlined: true,
    				$$slots: { default: [create_default_slot_11$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_6*/ ctx[54]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t0 = space();
    			h6 = element("h6");
    			t1 = text(/*$product_selection*/ ctx[8]);
    			add_location(h6, file$7, 465, 24, 19627);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			if (!current || dirty[0] & /*$product_selection*/ 256) set_data_dev(t1, /*$product_selection*/ ctx[8]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(459:20) {#if !alert_collection_running}",
    		ctx
    	});

    	return block;
    }

    // (460:24) <Button                         icon="restaurant"                         color="blue"                         outlined                         on:click={() => handleClick("product")}                         >
    function create_default_slot_11$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Product");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$1.name,
    		type: "slot",
    		source: "(460:24) <Button                         icon=\\\"restaurant\\\"                         color=\\\"blue\\\"                         outlined                         on:click={() => handleClick(\\\"product\\\")}                         >",
    		ctx
    	});

    	return block;
    }

    // (472:16) {#if !$is_product_selected}
    function create_if_block_11(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				icon: "restaurant",
    				color: "dark",
    				outlined: true,
    				$$slots: { default: [create_default_slot_10$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_7*/ ctx[55]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(472:16) {#if !$is_product_selected}",
    		ctx
    	});

    	return block;
    }

    // (473:20) <Button                     icon="restaurant"                     color="dark"                     outlined                     on:click={() => handleClick("product")}                     >
    function create_default_slot_10$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Product");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$1.name,
    		type: "slot",
    		source: "(473:20) <Button                     icon=\\\"restaurant\\\"                     color=\\\"dark\\\"                     outlined                     on:click={() => handleClick(\\\"product\\\")}                     >",
    		ctx
    	});

    	return block;
    }

    // (486:12) {#if $is_user_selected}
    function create_if_block_8(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*alert_collection_running*/ ctx[1] && create_if_block_10(ctx);
    	let if_block1 = !/*alert_collection_running*/ ctx[1] && create_if_block_9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*alert_collection_running*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*alert_collection_running*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_10(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*alert_collection_running*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*alert_collection_running*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_9(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(486:12) {#if $is_user_selected}",
    		ctx
    	});

    	return block;
    }

    // (487:20) {#if alert_collection_running}
    function create_if_block_10(ctx) {
    	let button;
    	let t0;
    	let h6;
    	let t1;
    	let current;

    	button = new Button({
    			props: {
    				icon: "face",
    				color: "blue",
    				outlined: true,
    				$$slots: { default: [create_default_slot_9$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t0 = space();
    			h6 = element("h6");
    			t1 = text(/*$user_selection*/ ctx[7]);
    			add_location(h6, file$7, 492, 24, 20458);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			if (!current || dirty[0] & /*$user_selection*/ 128) set_data_dev(t1, /*$user_selection*/ ctx[7]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(487:20) {#if alert_collection_running}",
    		ctx
    	});

    	return block;
    }

    // (488:24) <Button                         icon="face"                         color="blue"                         outlined                         >
    function create_default_slot_9$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("User");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$1.name,
    		type: "slot",
    		source: "(488:24) <Button                         icon=\\\"face\\\"                         color=\\\"blue\\\"                         outlined                         >",
    		ctx
    	});

    	return block;
    }

    // (495:20) {#if !alert_collection_running}
    function create_if_block_9(ctx) {
    	let button;
    	let t0;
    	let h6;
    	let t1;
    	let current;

    	button = new Button({
    			props: {
    				icon: "face",
    				color: "blue",
    				outlined: true,
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_8*/ ctx[56]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t0 = space();
    			h6 = element("h6");
    			t1 = text(/*$user_selection*/ ctx[7]);
    			add_location(h6, file$7, 501, 24, 20825);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			if (!current || dirty[0] & /*$user_selection*/ 128) set_data_dev(t1, /*$user_selection*/ ctx[7]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(495:20) {#if !alert_collection_running}",
    		ctx
    	});

    	return block;
    }

    // (496:24) <Button                         icon="face"                         color="blue"                         outlined                         on:click={() => handleClick("user")}                         >
    function create_default_slot_8$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("User");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(496:24) <Button                         icon=\\\"face\\\"                         color=\\\"blue\\\"                         outlined                         on:click={() => handleClick(\\\"user\\\")}                         >",
    		ctx
    	});

    	return block;
    }

    // (507:12) {#if !$is_user_selected}
    function create_if_block_7(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				icon: "face",
    				color: "dark",
    				outlined: true,
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_9*/ ctx[57]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(507:12) {#if !$is_user_selected}",
    		ctx
    	});

    	return block;
    }

    // (508:16) <Button                 icon="face"                 color="dark"                 outlined                 on:click={() => handleClick("user")}>
    function create_default_slot_7$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("User");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(508:16) <Button                 icon=\\\"face\\\"                 color=\\\"dark\\\"                 outlined                 on:click={() => handleClick(\\\"user\\\")}>",
    		ctx
    	});

    	return block;
    }

    // (521:12) {#if $is_product_selected }
    function create_if_block_6(ctx) {
    	let button;
    	let t0;
    	let h6;
    	let t1;
    	let current;

    	button = new Button({
    			props: {
    				icon: "vpn_key",
    				color: "blue",
    				outlined: true,
    				text: true,
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t0 = space();
    			h6 = element("h6");
    			t1 = text(/*$collection_id*/ ctx[6]);
    			add_location(h6, file$7, 528, 16, 21538);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			if (!current || dirty[0] & /*$collection_id*/ 64) set_data_dev(t1, /*$collection_id*/ ctx[6]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(521:12) {#if $is_product_selected }",
    		ctx
    	});

    	return block;
    }

    // (522:16) <Button                 icon="vpn_key"                 color="blue"                 outlined                 text >
    function create_default_slot_6$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("ID");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(522:16) <Button                 icon=\\\"vpn_key\\\"                 color=\\\"blue\\\"                 outlined                 text >",
    		ctx
    	});

    	return block;
    }

    // (536:12) {#if !$is_clicked_begin_collection}
    function create_if_block_3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_4, create_if_block_5, create_else_block];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$is_product_selected*/ ctx[12] & /*$is_company_selected*/ ctx[14] & /*$is_user_selected*/ ctx[10]) return 0;
    		if (/*$collection_button_alert*/ ctx[3]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(536:12) {#if !$is_clicked_begin_collection}",
    		ctx
    	});

    	return block;
    }

    // (547:20) {:else}
    function create_else_block(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*enable_collection_button_alert*/ ctx[32]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-4");
    			add_location(div, file$7, 547, 20, 22301);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(547:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (543:20) {#if $collection_button_alert}
    function create_if_block_5(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "alert",
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-4");
    			add_location(div, file$7, 543, 20, 22127);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(543:20) {#if $collection_button_alert}",
    		ctx
    	});

    	return block;
    }

    // (537:16) {#if $is_product_selected & $is_company_selected & $is_user_selected }
    function create_if_block_4(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*send_begin_collection*/ ctx[29]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-4");
    			add_location(div, file$7, 537, 20, 21857);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(537:16) {#if $is_product_selected & $is_company_selected & $is_user_selected }",
    		ctx
    	});

    	return block;
    }

    // (549:24) <Button  color = "blue" on:click={enable_collection_button_alert} >
    function create_default_slot_5$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Begin Collection");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(549:24) <Button  color = \\\"blue\\\" on:click={enable_collection_button_alert} >",
    		ctx
    	});

    	return block;
    }

    // (545:24) <Button color = "alert"  >
    function create_default_slot_4$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Begin Collection");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(545:24) <Button color = \\\"alert\\\"  >",
    		ctx
    	});

    	return block;
    }

    // (539:24) <Button  color = "blue" on:click={send_begin_collection} >
    function create_default_slot_3$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Begin Collection");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(539:24) <Button  color = \\\"blue\\\" on:click={send_begin_collection} >",
    		ctx
    	});

    	return block;
    }

    // (556:12) {#if $is_clicked_begin_collection || !send_end_collection_delete_batches || $fetching_images || $ending_collection}
    function create_if_block_2(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				disabled: true,
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-4");
    			add_location(div, file$7, 556, 16, 22680);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(556:12) {#if $is_clicked_begin_collection || !send_end_collection_delete_batches || $fetching_images || $ending_collection}",
    		ctx
    	});

    	return block;
    }

    // (558:20) <Button disabled   >
    function create_default_slot_2$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Begin Collection");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(558:20) <Button disabled   >",
    		ctx
    	});

    	return block;
    }

    // (561:12) {#if $is_clicked_end_collection || !$ready_to_end_collection || $fetching_images || $ending_collection}
    function create_if_block_1$2(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				disabled: true,
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-4");
    			add_location(div, file$7, 561, 12, 22942);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(561:12) {#if $is_clicked_end_collection || !$ready_to_end_collection || $fetching_images || $ending_collection}",
    		ctx
    	});

    	return block;
    }

    // (563:16) <Button disabled   >
    function create_default_slot_1$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("End Collection");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(563:16) <Button disabled   >",
    		ctx
    	});

    	return block;
    }

    // (566:12) {#if !$is_clicked_end_collection && $ready_to_end_collection && !$fetching_images && !$ending_collection}
    function create_if_block$3(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "blue",
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*send_end_collection*/ ctx[30]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "col-md-4");
    			add_location(div, file$7, 566, 12, 23194);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[2] & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(566:12) {#if !$is_clicked_end_collection && $ready_to_end_collection && !$fetching_images && !$ending_collection}",
    		ctx
    	});

    	return block;
    }

    // (568:16) <Button color = "blue" on:click={send_end_collection} >
    function create_default_slot$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("End Collection");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(568:16) <Button color = \\\"blue\\\" on:click={send_end_collection} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let dialog;
    	let updating_value;
    	let t0;
    	let div6;
    	let div5;
    	let div0;
    	let current_block_type_index;
    	let if_block0;
    	let t1;
    	let div1;
    	let t2;
    	let t3;
    	let div2;
    	let t4;
    	let t5;
    	let div3;
    	let t6;
    	let div4;
    	let t7;
    	let t8;
    	let t9;
    	let current;

    	function dialog_value_binding(value) {
    		/*dialog_value_binding*/ ctx[51](value);
    	}

    	let dialog_props = {
    		$$slots: {
    			actions: [create_actions_slot],
    			default: [create_default_slot_17]
    		},
    		$$scope: { ctx }
    	};

    	if (/*showDialog*/ ctx[0] !== void 0) {
    		dialog_props.value = /*showDialog*/ ctx[0];
    	}

    	dialog = new Dialog({ props: dialog_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog, 'value', dialog_value_binding));
    	const if_block_creators = [create_if_block_15, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$is_company_selected*/ ctx[14]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*$is_product_selected*/ ctx[12] && create_if_block_12(ctx);
    	let if_block2 = !/*$is_product_selected*/ ctx[12] && create_if_block_11(ctx);
    	let if_block3 = /*$is_user_selected*/ ctx[10] && create_if_block_8(ctx);
    	let if_block4 = !/*$is_user_selected*/ ctx[10] && create_if_block_7(ctx);
    	let if_block5 = /*$is_product_selected*/ ctx[12] && create_if_block_6(ctx);
    	let if_block6 = !/*$is_clicked_begin_collection*/ ctx[5] && create_if_block_3(ctx);
    	let if_block7 = (/*$is_clicked_begin_collection*/ ctx[5] || !send_end_collection_delete_batches || /*$fetching_images*/ ctx[20] || /*$ending_collection*/ ctx[21]) && create_if_block_2(ctx);
    	let if_block8 = (/*$is_clicked_end_collection*/ ctx[4] || !/*$ready_to_end_collection*/ ctx[22] || /*$fetching_images*/ ctx[20] || /*$ending_collection*/ ctx[21]) && create_if_block_1$2(ctx);
    	let if_block9 = !/*$is_clicked_end_collection*/ ctx[4] && /*$ready_to_end_collection*/ ctx[22] && !/*$fetching_images*/ ctx[20] && !/*$ending_collection*/ ctx[21] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			create_component(dialog.$$.fragment);
    			t0 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			if_block0.c();
    			t1 = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div2 = element("div");
    			if (if_block3) if_block3.c();
    			t4 = space();
    			if (if_block4) if_block4.c();
    			t5 = space();
    			div3 = element("div");
    			if (if_block5) if_block5.c();
    			t6 = space();
    			div4 = element("div");
    			if (if_block6) if_block6.c();
    			t7 = space();
    			if (if_block7) if_block7.c();
    			t8 = space();
    			if (if_block8) if_block8.c();
    			t9 = space();
    			if (if_block9) if_block9.c();
    			attr_dev(div0, "class", " break-all  col-md-2  grid justify-items-center place-content-between gap-8");
    			add_location(div0, file$7, 408, 8, 17582);
    			attr_dev(div1, "class", "col-md-2 break-all grid justify-items-center place-content-between gap-8");
    			add_location(div1, file$7, 445, 8, 18809);
    			attr_dev(div2, "class", "col-md-2  break-all grid justify-items-center place-content-between gap-8");
    			add_location(div2, file$7, 483, 8, 20078);
    			attr_dev(div3, "class", "col-md-2 break-all grid justify-items-center place-content-between gap-8");
    			add_location(div3, file$7, 519, 8, 21217);
    			attr_dev(div4, "class", "col-md-2 grid justify-items-center place-content-between gap-8");
    			add_location(div4, file$7, 534, 8, 21624);
    			attr_dev(div5, "class", "  h-48 flex flex-wrap content-evenly");
    			add_location(div5, file$7, 407, 4, 17523);
    			attr_dev(div6, "class", "border-bottom pb-4");
    			add_location(div6, file$7, 405, 0, 17435);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialog, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div5, t1);
    			append_dev(div5, div1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t2);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div5, t3);
    			append_dev(div5, div2);
    			if (if_block3) if_block3.m(div2, null);
    			append_dev(div2, t4);
    			if (if_block4) if_block4.m(div2, null);
    			append_dev(div5, t5);
    			append_dev(div5, div3);
    			if (if_block5) if_block5.m(div3, null);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			if (if_block6) if_block6.m(div4, null);
    			append_dev(div4, t7);
    			if (if_block7) if_block7.m(div4, null);
    			append_dev(div4, t8);
    			if (if_block8) if_block8.m(div4, null);
    			append_dev(div4, t9);
    			if (if_block9) if_block9.m(div4, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dialog_changes = {};

    			if (dirty[0] & /*showDialog, tab_selected, $new_collection_name, $user_selection, $matching_user_names, $user_search_term, $product_selection, $matching_product_names, $product_search_term, $company_selection, $matching_company_names, $company_search_term*/ 1026949 | dirty[2] & /*$$scope*/ 32768) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty[0] & /*showDialog*/ 1) {
    				updating_value = true;
    				dialog_changes.value = /*showDialog*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			dialog.$set(dialog_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div0, null);
    			}

    			if (/*$is_product_selected*/ ctx[12]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*$is_product_selected*/ 4096) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_12(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!/*$is_product_selected*/ ctx[12]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*$is_product_selected*/ 4096) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_11(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$is_user_selected*/ ctx[10]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*$is_user_selected*/ 1024) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_8(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div2, t4);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!/*$is_user_selected*/ ctx[10]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*$is_user_selected*/ 1024) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_7(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div2, null);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*$is_product_selected*/ ctx[12]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*$is_product_selected*/ 4096) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_6(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div3, null);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (!/*$is_clicked_begin_collection*/ ctx[5]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[0] & /*$is_clicked_begin_collection*/ 32) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_3(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div4, t7);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (/*$is_clicked_begin_collection*/ ctx[5] || !send_end_collection_delete_batches || /*$fetching_images*/ ctx[20] || /*$ending_collection*/ ctx[21]) {
    				if (if_block7) {
    					if (dirty[0] & /*$is_clicked_begin_collection, $fetching_images, $ending_collection*/ 3145760) {
    						transition_in(if_block7, 1);
    					}
    				} else {
    					if_block7 = create_if_block_2(ctx);
    					if_block7.c();
    					transition_in(if_block7, 1);
    					if_block7.m(div4, t8);
    				}
    			} else if (if_block7) {
    				group_outros();

    				transition_out(if_block7, 1, 1, () => {
    					if_block7 = null;
    				});

    				check_outros();
    			}

    			if (/*$is_clicked_end_collection*/ ctx[4] || !/*$ready_to_end_collection*/ ctx[22] || /*$fetching_images*/ ctx[20] || /*$ending_collection*/ ctx[21]) {
    				if (if_block8) {
    					if (dirty[0] & /*$is_clicked_end_collection, $ready_to_end_collection, $fetching_images, $ending_collection*/ 7340048) {
    						transition_in(if_block8, 1);
    					}
    				} else {
    					if_block8 = create_if_block_1$2(ctx);
    					if_block8.c();
    					transition_in(if_block8, 1);
    					if_block8.m(div4, t9);
    				}
    			} else if (if_block8) {
    				group_outros();

    				transition_out(if_block8, 1, 1, () => {
    					if_block8 = null;
    				});

    				check_outros();
    			}

    			if (!/*$is_clicked_end_collection*/ ctx[4] && /*$ready_to_end_collection*/ ctx[22] && !/*$fetching_images*/ ctx[20] && !/*$ending_collection*/ ctx[21]) {
    				if (if_block9) {
    					if_block9.p(ctx, dirty);

    					if (dirty[0] & /*$is_clicked_end_collection, $ready_to_end_collection, $fetching_images, $ending_collection*/ 7340048) {
    						transition_in(if_block9, 1);
    					}
    				} else {
    					if_block9 = create_if_block$3(ctx);
    					if_block9.c();
    					transition_in(if_block9, 1);
    					if_block9.m(div4, null);
    				}
    			} else if (if_block9) {
    				group_outros();

    				transition_out(if_block9, 1, 1, () => {
    					if_block9 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			transition_in(if_block7);
    			transition_in(if_block8);
    			transition_in(if_block9);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			transition_out(if_block7);
    			transition_out(if_block8);
    			transition_out(if_block9);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dialog, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div6);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			if (if_block8) if_block8.d();
    			if (if_block9) if_block9.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $collection_button_alert;
    	let $collection_ids;
    	let $matching_local_collection_ids;
    	let $matching_local_user_names;
    	let $matching_local_product_names;
    	let $matching_local_company_names;
    	let $is_clicked_end_collection;
    	let $is_clicked_begin_collection;
    	let $completed_collection;
    	let $local_collection_id;
    	let $collection_id;
    	let $user_selection;
    	let $product_selection;
    	let $company_selection;
    	let $is_Clicked_start;
    	let $collection_running;
    	let $collection_search_term;
    	let $is_user_selected;
    	let $user_search_term;
    	let $is_product_selected;
    	let $product_search_term;
    	let $is_company_selected;
    	let $company_search_term;
    	let $new_collection_name;
    	let $matching_user_names;
    	let $matching_product_names;
    	let $matching_company_names;
    	let $fetching_images;
    	let $ending_collection;
    	let $ready_to_end_collection;
    	validate_store(collection_button_alert, 'collection_button_alert');
    	component_subscribe($$self, collection_button_alert, $$value => $$invalidate(3, $collection_button_alert = $$value));
    	validate_store(collection_ids, 'collection_ids');
    	component_subscribe($$self, collection_ids, $$value => $$invalidate(58, $collection_ids = $$value));
    	validate_store(matching_local_collection_ids, 'matching_local_collection_ids');
    	component_subscribe($$self, matching_local_collection_ids, $$value => $$invalidate(59, $matching_local_collection_ids = $$value));
    	validate_store(matching_local_user_names, 'matching_local_user_names');
    	component_subscribe($$self, matching_local_user_names, $$value => $$invalidate(60, $matching_local_user_names = $$value));
    	validate_store(matching_local_product_names, 'matching_local_product_names');
    	component_subscribe($$self, matching_local_product_names, $$value => $$invalidate(61, $matching_local_product_names = $$value));
    	validate_store(matching_local_company_names, 'matching_local_company_names');
    	component_subscribe($$self, matching_local_company_names, $$value => $$invalidate(62, $matching_local_company_names = $$value));
    	validate_store(is_clicked_end_collection, 'is_clicked_end_collection');
    	component_subscribe($$self, is_clicked_end_collection, $$value => $$invalidate(4, $is_clicked_end_collection = $$value));
    	validate_store(is_clicked_begin_collection, 'is_clicked_begin_collection');
    	component_subscribe($$self, is_clicked_begin_collection, $$value => $$invalidate(5, $is_clicked_begin_collection = $$value));
    	validate_store(completed_collection, 'completed_collection');
    	component_subscribe($$self, completed_collection, $$value => $$invalidate(63, $completed_collection = $$value));
    	validate_store(local_collection_id, 'local_collection_id');
    	component_subscribe($$self, local_collection_id, $$value => $$invalidate(64, $local_collection_id = $$value));
    	validate_store(collection_id, 'collection_id');
    	component_subscribe($$self, collection_id, $$value => $$invalidate(6, $collection_id = $$value));
    	validate_store(user_selection, 'user_selection');
    	component_subscribe($$self, user_selection, $$value => $$invalidate(7, $user_selection = $$value));
    	validate_store(product_selection, 'product_selection');
    	component_subscribe($$self, product_selection, $$value => $$invalidate(8, $product_selection = $$value));
    	validate_store(company_selection, 'company_selection');
    	component_subscribe($$self, company_selection, $$value => $$invalidate(9, $company_selection = $$value));
    	validate_store(is_Clicked_start, 'is_Clicked_start');
    	component_subscribe($$self, is_Clicked_start, $$value => $$invalidate(65, $is_Clicked_start = $$value));
    	validate_store(collection_running, 'collection_running');
    	component_subscribe($$self, collection_running, $$value => $$invalidate(66, $collection_running = $$value));
    	validate_store(collection_search_term, 'collection_search_term');
    	component_subscribe($$self, collection_search_term, $$value => $$invalidate(67, $collection_search_term = $$value));
    	validate_store(is_user_selected, 'is_user_selected');
    	component_subscribe($$self, is_user_selected, $$value => $$invalidate(10, $is_user_selected = $$value));
    	validate_store(user_search_term, 'user_search_term');
    	component_subscribe($$self, user_search_term, $$value => $$invalidate(11, $user_search_term = $$value));
    	validate_store(is_product_selected, 'is_product_selected');
    	component_subscribe($$self, is_product_selected, $$value => $$invalidate(12, $is_product_selected = $$value));
    	validate_store(product_search_term, 'product_search_term');
    	component_subscribe($$self, product_search_term, $$value => $$invalidate(13, $product_search_term = $$value));
    	validate_store(is_company_selected, 'is_company_selected');
    	component_subscribe($$self, is_company_selected, $$value => $$invalidate(14, $is_company_selected = $$value));
    	validate_store(company_search_term, 'company_search_term');
    	component_subscribe($$self, company_search_term, $$value => $$invalidate(15, $company_search_term = $$value));
    	validate_store(new_collection_name, 'new_collection_name');
    	component_subscribe($$self, new_collection_name, $$value => $$invalidate(16, $new_collection_name = $$value));
    	validate_store(matching_user_names, 'matching_user_names');
    	component_subscribe($$self, matching_user_names, $$value => $$invalidate(17, $matching_user_names = $$value));
    	validate_store(matching_product_names, 'matching_product_names');
    	component_subscribe($$self, matching_product_names, $$value => $$invalidate(18, $matching_product_names = $$value));
    	validate_store(matching_company_names, 'matching_company_names');
    	component_subscribe($$self, matching_company_names, $$value => $$invalidate(19, $matching_company_names = $$value));
    	validate_store(fetching_images, 'fetching_images');
    	component_subscribe($$self, fetching_images, $$value => $$invalidate(20, $fetching_images = $$value));
    	validate_store(ending_collection, 'ending_collection');
    	component_subscribe($$self, ending_collection, $$value => $$invalidate(21, $ending_collection = $$value));
    	validate_store(ready_to_end_collection, 'ready_to_end_collection');
    	component_subscribe($$self, ready_to_end_collection, $$value => $$invalidate(22, $ready_to_end_collection = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CollectionRun', slots, []);
    	let showDialog = false;
    	let alert_collection_running = false;
    	let tab_selected = "1";

    	onMount(async () => {
    		const response = await fetch("/retrieve_selections");
    		console.log("retrieved_selections_response", response);
    		const retrieved_selections = await response.json();
    		console.log("retrieved_selections", retrieved_selections);
    		set_store_value(company_selection, $company_selection = retrieved_selections.company_selection, $company_selection);
    		set_store_value(product_selection, $product_selection = retrieved_selections.product_selection, $product_selection);
    		set_store_value(user_selection, $user_selection = retrieved_selections.user_selection, $user_selection);
    		set_store_value(collection_id, $collection_id = retrieved_selections.collection_id, $collection_id);
    	}); // console.log($company_selection,$product_selection,$user_selection)

    	function handleClick(type) {
    		if (!$is_clicked_begin_collection) {
    			if (type === "company") {
    				$$invalidate(2, tab_selected = "1");
    			}

    			if (type === "product") {
    				$$invalidate(2, tab_selected = "2");
    			} // console.log("product selected");

    			if (type === "user") {
    				$$invalidate(2, tab_selected = "3");
    			} // console.log("user selected");

    			$$invalidate(0, showDialog = true);
    		}

    		if ($is_clicked_begin_collection) {
    			$$invalidate(1, alert_collection_running = true);

    			// console.log("alert_collection_running = true")
    			fetch("./send_next_step/" + "In order to change collection details - End Current Collection First").then(d => d.text());
    		}
    	}

    	async function add_to_collection(collection_type) {
    		const response = await fetch("./add_to_collection/" + collection_type + "/" + $new_collection_name);
    		const add_to_collection_response = await response.json();
    		console.log("add_to_collection_finished");

    		if (collection_type === "company") {
    			set_store_value(matching_company_names, $matching_company_names = add_to_collection_response, $matching_company_names);
    			change_content_selection(collection_type);
    			set_store_value(is_company_selected, $is_company_selected = true, $is_company_selected);
    		}

    		if (collection_type === "product") {
    			set_store_value(matching_product_names, $matching_product_names = add_to_collection_response, $matching_product_names);
    			change_content_selection(collection_type);
    			const response = await fetch("./ready_for_id");
    			const collection_id_response = await response.json();
    			set_store_value(collection_id, $collection_id = collection_id_response, $collection_id);

    			// console.log("$collection_id", $collection_id)
    			set_store_value(is_product_selected, $is_product_selected = true, $is_product_selected);
    		}

    		if (collection_type === "user") {
    			set_store_value(matching_user_names, $matching_user_names = add_to_collection_response, $matching_user_names);
    			change_content_selection(collection_type);
    			set_store_value(is_user_selected, $is_user_selected = true, $is_user_selected);
    		}
    	}

    	function change_content_selection(collection_type) {
    		if (collection_type === "company") {
    			set_store_value(company_selection, $company_selection = $new_collection_name, $company_selection);
    		}

    		if (collection_type === "product") {
    			set_store_value(product_selection, $product_selection = $new_collection_name, $product_selection);
    		}

    		if (collection_type === "user") {
    			set_store_value(user_selection, $user_selection = $new_collection_name, $user_selection);
    		}

    		set_store_value(collection_search_term, $collection_search_term = "", $collection_search_term);
    	}

    	async function send_company_selection(change_type) {
    		if ($company_selection) {
    			fetch("./send_company_selection/" + $company_selection).then(d => d.text());

    			// console.log($company_selection);
    			set_store_value(is_company_selected, $is_company_selected = true, $is_company_selected);
    		} // console.log($company_selection);
    	}

    	async function send_product_selection() {
    		if ($product_selection) {
    			fetch("./send_product_selection/" + $product_selection).then(d => d.text());

    			// console.log($product_selection);
    			set_store_value(is_product_selected, $is_product_selected = true, $is_product_selected);

    			// fetch("./ready_for_id").then(d => d.text());
    			const response = await fetch("./ready_for_id");

    			const collection_id_response = await response.json();

    			// console.log("collection_id_response1", collection_id_response);
    			set_store_value(collection_id, $collection_id = collection_id_response, $collection_id);
    		} // console.log("$collection_id 1", $collection_id)
    	}

    	function send_user_selection() {
    		if ($user_selection) {
    			fetch("./send_user_selection/" + $user_selection).then(d => d.text());

    			// console.log($user_selection);
    			set_store_value(is_user_selected, $is_user_selected = true, $is_user_selected);
    		}
    	}

    	function send_collection_search_term(collection_type) {
    		// console.log($collection_search_term);
    		if (collection_type === "company") {
    			set_store_value(collection_search_term, $collection_search_term = $company_search_term, $collection_search_term);
    			set_store_value(is_company_selected, $is_company_selected = true, $is_company_selected);
    		} else if (collection_type === "product") {
    			set_store_value(collection_search_term, $collection_search_term = $product_search_term, $collection_search_term); // console.log($collection_search_term);
    			set_store_value(is_product_selected, $is_product_selected = true, $is_product_selected);
    		} else if (collection_type === "user") {
    			set_store_value(collection_search_term, $collection_search_term = $user_search_term, $collection_search_term); // console.log($collection_search_term);
    			set_store_value(is_user_selected, $is_user_selected = true, $is_user_selected);
    		} // console.log($collection_search_term);

    		if (!$collection_search_term) {
    			// console.log($collection_search_term);
    			set_store_value(collection_search_term, $collection_search_term = "get_all", $collection_search_term);

    			// console.log($collection_search_term);
    			fetch("./send_collection_search_term/" + collection_type + "/" + $collection_search_term).then(d => d.text());

    			// console.log($collection_search_term);
    			set_store_value(collection_search_term, $collection_search_term = "", $collection_search_term);
    		} else {
    			fetch("./send_collection_search_term/" + collection_type + "/" + $collection_search_term).then(d => d.text()); // console.log($collection_search_term);
    		} // console.log($collection_search_term);
    	}

    	async function send_begin_collection() {
    		// console.log("beginning collection");
    		// console.log($company_selection);
    		// console.log($product_selection);
    		// console.log($user_selection);
    		// console.log($collection_id);
    		if (!($company_selection === "" || $product_selection === "" || $user_selection === "" || $collection_id === "")) {
    			set_store_value(collection_running, $collection_running = true, $collection_running);

    			// console.log("in the beginning of  collection");
    			set_store_value(is_clicked_begin_collection, $is_clicked_begin_collection = true, $is_clicked_begin_collection);

    			set_store_value(collection_button_alert, $collection_button_alert = false, $collection_button_alert);
    			fetch("./is_clicked_begin_collection/" + $is_clicked_begin_collection).then(d => d.text());

    			// console.log("began collection")
    			fetch("./is_Clicked_start/" + false).then(d => d.text());

    			// console.log("unclicked start")
    			set_store_value(is_Clicked_start, $is_Clicked_start = false, $is_Clicked_start);

    			fetch("./is_clicked_end_collection/" + false).then(d => d.text());
    			set_store_value(is_clicked_end_collection, $is_clicked_end_collection = false, $is_clicked_end_collection);
    			const response = await fetch("./send_begin_collection/" + $company_selection + "/" + $product_selection + "/" + $user_selection + "/" + $collection_id);
    			const collection_id_response = await response.json();
    			set_store_value(collection_id, $collection_id = collection_id_response, $collection_id);
    		}
    	}

    	async function send_end_collection() {
    		fetch("./is_clicked_begin_collection/" + false).then(d => d.text());
    		fetch("./is_clicked_end_collection/" + true).then(d => d.text());
    		const send_end_collection_response = await fetch("./send_end_collection");
    		const send_end_collection_response_string = await send_end_collection_response.json();
    		console.log("send_end_collection_response_string", send_end_collection_response_string);

    		if (send_end_collection_response_string == "ended collection") {
    			set_store_value(local_collection_id, $local_collection_id = $collection_id, $local_collection_id);
    			console.log("($local_collection_id collection run", $local_collection_id);
    			const response = await fetch("./retrieve_completed_collection/" + $local_collection_id);
    			const retrieve_completed_collection_response = await response.json();
    			console.log("retrieve_completed_collection_response.completed_collection", retrieve_completed_collection_response.completed_collection);
    			set_store_value(completed_collection, $completed_collection = retrieve_completed_collection_response.completed_collection, $completed_collection);
    		} // console.log("$local_collection_id",retrieve_completed_collection_response.collection_id)

    		$$invalidate(1, alert_collection_running = false);
    		set_store_value(is_clicked_begin_collection, $is_clicked_begin_collection = false, $is_clicked_begin_collection);
    		set_store_value(is_clicked_end_collection, $is_clicked_end_collection = true, $is_clicked_end_collection);
    		const response_one = await fetch("./retrieve_local_details");
    		const retrieve_local_details_response = await response_one.json();
    		set_store_value(matching_local_company_names, $matching_local_company_names = retrieve_local_details_response.local_companies, $matching_local_company_names);
    		set_store_value(matching_local_product_names, $matching_local_product_names = retrieve_local_details_response.local_products, $matching_local_product_names);
    		set_store_value(matching_local_user_names, $matching_local_user_names = retrieve_local_details_response.local_users, $matching_local_user_names);
    		set_store_value(matching_local_collection_ids, $matching_local_collection_ids = retrieve_local_details_response.collection_ids, $matching_local_collection_ids);
    		set_store_value(collection_ids, $collection_ids = retrieve_local_details_response.collection_ids, $collection_ids);
    	} // console.log("ended collection")
    	// console.log("ready_to_end_collection", $ready_to_end_collection)

    	// send_local_collection_id($collection_id)
    	// console.log("col_id", col_id)
    	// $local_collection_id = $collection_id
    	// const send_collection_id_response = await fetch("./send_collection_id/"+ $collection_id)
    	// const completed_collection_response = await send_collection_id_response.json();
    	// $completed_collection = completed_collection_response.completed_collection
    	// console.log("$completed_collection",$completed_collection)
    	let loading = false;

    	function enable_collection_button_alert() {
    		set_store_value(collection_button_alert, $collection_button_alert = true, $collection_button_alert);
    		fetch("./send_next_step/" + "Select all Collection Details Before Beginning a Collection").then(d => d.text());
    	} // console.log($next_step)

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<CollectionRun> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, showDialog = false);

    	function textfield_value_binding(value) {
    		$company_search_term = value;
    		company_search_term.set($company_search_term);
    	}

    	const input_handler = () => send_collection_search_term("company");

    	function select1_change_handler() {
    		$company_selection = select_value(this);
    		company_selection.set($company_selection);
    	}

    	const change_handler = () => send_company_selection();
    	const mousemove_handler = () => send_company_selection();

    	function textfield_value_binding_1(value) {
    		$new_collection_name = value;
    		new_collection_name.set($new_collection_name);
    	}

    	const click_handler_1 = () => add_to_collection("company");

    	function textfield_value_binding_2(value) {
    		$product_search_term = value;
    		product_search_term.set($product_search_term);
    	}

    	const input_handler_1 = () => send_collection_search_term("product");

    	function select1_change_handler_1() {
    		$product_selection = select_value(this);
    		product_selection.set($product_selection);
    	}

    	function textfield_value_binding_3(value) {
    		$new_collection_name = value;
    		new_collection_name.set($new_collection_name);
    	}

    	const click_handler_2 = () => add_to_collection("product");

    	function textfield_value_binding_4(value) {
    		$user_search_term = value;
    		user_search_term.set($user_search_term);
    	}

    	const input_handler_2 = () => send_collection_search_term("user");

    	function select1_change_handler_2() {
    		$user_selection = select_value(this);
    		user_selection.set($user_selection);
    	}

    	function textfield_value_binding_5(value) {
    		$new_collection_name = value;
    		new_collection_name.set($new_collection_name);
    	}

    	const click_handler_3 = () => add_to_collection("user");

    	function dialog_value_binding(value) {
    		showDialog = value;
    		$$invalidate(0, showDialog);
    	}

    	const click_handler_4 = () => handleClick("company");
    	const click_handler_5 = () => handleClick("company");
    	const click_handler_6 = () => handleClick("product");
    	const click_handler_7 = () => handleClick("product");
    	const click_handler_8 = () => handleClick("user");
    	const click_handler_9 = () => handleClick("user");

    	$$self.$capture_state = () => ({
    		Button,
    		Chip,
    		Dialog,
    		TextField,
    		Tabs,
    		Tab,
    		onMount,
    		Fade,
    		FormGroup,
    		Label: Label$2,
    		is_company_selected,
    		is_product_selected,
    		is_user_selected,
    		collection_search_term,
    		image_collection_names,
    		matching_company_names,
    		matching_product_names,
    		matching_user_names,
    		company_selection,
    		product_selection,
    		user_selection,
    		is_clicked_begin_collection,
    		is_clicked_end_collection,
    		collection_button_alert,
    		new_collection_name,
    		next_step,
    		collection_id,
    		is_Clicked_start,
    		ready_to_end_collection,
    		send_end_collection_delete_batches,
    		fetching_images,
    		collection_running,
    		completed_collection,
    		matching_local_collection_ids,
    		company_search_term,
    		product_search_term,
    		user_search_term,
    		matching_local_product_names,
    		matching_local_company_names,
    		matching_local_user_names,
    		local_collection_id,
    		collection_ids,
    		ending_collection,
    		showDialog,
    		alert_collection_running,
    		tab_selected,
    		handleClick,
    		add_to_collection,
    		change_content_selection,
    		send_company_selection,
    		send_product_selection,
    		send_user_selection,
    		send_collection_search_term,
    		send_begin_collection,
    		send_end_collection,
    		loading,
    		enable_collection_button_alert,
    		$collection_button_alert,
    		$collection_ids,
    		$matching_local_collection_ids,
    		$matching_local_user_names,
    		$matching_local_product_names,
    		$matching_local_company_names,
    		$is_clicked_end_collection,
    		$is_clicked_begin_collection,
    		$completed_collection,
    		$local_collection_id,
    		$collection_id,
    		$user_selection,
    		$product_selection,
    		$company_selection,
    		$is_Clicked_start,
    		$collection_running,
    		$collection_search_term,
    		$is_user_selected,
    		$user_search_term,
    		$is_product_selected,
    		$product_search_term,
    		$is_company_selected,
    		$company_search_term,
    		$new_collection_name,
    		$matching_user_names,
    		$matching_product_names,
    		$matching_company_names,
    		$fetching_images,
    		$ending_collection,
    		$ready_to_end_collection
    	});

    	$$self.$inject_state = $$props => {
    		if ('showDialog' in $$props) $$invalidate(0, showDialog = $$props.showDialog);
    		if ('alert_collection_running' in $$props) $$invalidate(1, alert_collection_running = $$props.alert_collection_running);
    		if ('tab_selected' in $$props) $$invalidate(2, tab_selected = $$props.tab_selected);
    		if ('loading' in $$props) $$invalidate(31, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showDialog,
    		alert_collection_running,
    		tab_selected,
    		$collection_button_alert,
    		$is_clicked_end_collection,
    		$is_clicked_begin_collection,
    		$collection_id,
    		$user_selection,
    		$product_selection,
    		$company_selection,
    		$is_user_selected,
    		$user_search_term,
    		$is_product_selected,
    		$product_search_term,
    		$is_company_selected,
    		$company_search_term,
    		$new_collection_name,
    		$matching_user_names,
    		$matching_product_names,
    		$matching_company_names,
    		$fetching_images,
    		$ending_collection,
    		$ready_to_end_collection,
    		handleClick,
    		add_to_collection,
    		send_company_selection,
    		send_product_selection,
    		send_user_selection,
    		send_collection_search_term,
    		send_begin_collection,
    		send_end_collection,
    		loading,
    		enable_collection_button_alert,
    		click_handler,
    		textfield_value_binding,
    		input_handler,
    		select1_change_handler,
    		change_handler,
    		mousemove_handler,
    		textfield_value_binding_1,
    		click_handler_1,
    		textfield_value_binding_2,
    		input_handler_1,
    		select1_change_handler_1,
    		textfield_value_binding_3,
    		click_handler_2,
    		textfield_value_binding_4,
    		input_handler_2,
    		select1_change_handler_2,
    		textfield_value_binding_5,
    		click_handler_3,
    		dialog_value_binding,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8,
    		click_handler_9
    	];
    }

    class CollectionRun extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {}, null, [-1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CollectionRun",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src/Create/OpenCollectionRun.svelte generated by Svelte v3.40.3 */
    const file$6 = "src/Create/OpenCollectionRun.svelte";

    // (14:0) {#if isOpen }
    function create_if_block_1$1(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "light",
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(14:0) {#if isOpen }",
    		ctx
    	});

    	return block;
    }

    // (15:4) <Button  size="lg"  color = "light"   on:click={handleClick} >
    function create_default_slot_2$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Collection Run");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(15:4) <Button  size=\\\"lg\\\"  color = \\\"light\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (19:0) {#if !isOpen }
    function create_if_block$2(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "info",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(19:0) {#if !isOpen }",
    		ctx
    	});

    	return block;
    }

    // (20:4) <Button   size="lg"    color = "info"   on:click={handleClick} >
    function create_default_slot_1$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Collection Run");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(20:4) <Button   size=\\\"lg\\\"    color = \\\"info\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (28:4) <Fade {isOpen} >
    function create_default_slot$4(ctx) {
    	let div;
    	let collectionrun;
    	let current;
    	collectionrun = new CollectionRun({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(collectionrun.$$.fragment);
    			add_location(div, file$6, 29, 8, 695);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(collectionrun, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(collectionrun.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(collectionrun.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(collectionrun);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(28:4) <Fade {isOpen} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let t0;
    	let t1;
    	let div;
    	let fade;
    	let current;
    	let if_block0 = /*isOpen*/ ctx[0] && create_if_block_1$1(ctx);
    	let if_block1 = !/*isOpen*/ ctx[0] && create_if_block$2(ctx);

    	fade = new Fade({
    			props: {
    				isOpen: /*isOpen*/ ctx[0],
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div = element("div");
    			create_component(fade.$$.fragment);
    			attr_dev(div, "class", "col-md-9  offset-md-2 ");
    			add_location(div, file$6, 26, 0, 628);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(fade, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isOpen*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const fade_changes = {};
    			if (dirty & /*isOpen*/ 1) fade_changes.isOpen = /*isOpen*/ ctx[0];

    			if (dirty & /*$$scope*/ 4) {
    				fade_changes.$$scope = { dirty, ctx };
    			}

    			fade.$set(fade_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(fade.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(fade.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(fade);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OpenCollectionRun', slots, []);
    	let isOpen = true;

    	function handleClick() {
    		$$invalidate(0, isOpen = !isOpen);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OpenCollectionRun> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Fade,
    		Button: Button$1,
    		CollectionRun,
    		isOpen,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isOpen, handleClick];
    }

    class OpenCollectionRun extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OpenCollectionRun",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src/Create/Update.svelte generated by Svelte v3.40.3 */

    function create_fragment$a(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Update', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Update> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Button });
    	return [];
    }

    class Update extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Update",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src/Create/OpenUpdate.svelte generated by Svelte v3.40.3 */
    const file$5 = "src/Create/OpenUpdate.svelte";

    // (16:4) {#if isOpen }
    function create_if_block_1(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "light",
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(16:4) {#if isOpen }",
    		ctx
    	});

    	return block;
    }

    // (17:4) <Button  size="lg"  color = "light"   on:click={handleClick} >
    function create_default_slot_2$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Update");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(17:4) <Button  size=\\\"lg\\\"  color = \\\"light\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (21:0) {#if !isOpen }
    function create_if_block$1(ctx) {
    	let button;
    	let current;

    	button = new Button$1({
    			props: {
    				size: "lg",
    				color: "info",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*handleClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(21:0) {#if !isOpen }",
    		ctx
    	});

    	return block;
    }

    // (22:4) <Button   size="lg"    color = "info"   on:click={handleClick} >
    function create_default_slot_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Update");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(22:4) <Button   size=\\\"lg\\\"    color = \\\"info\\\"   on:click={handleClick} >",
    		ctx
    	});

    	return block;
    }

    // (29:4) <Fade {isOpen} >
    function create_default_slot$3(ctx) {
    	let div;
    	let update;
    	let current;
    	update = new Update({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(update.$$.fragment);
    			add_location(div, file$5, 30, 8, 714);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(update, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(update.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(update.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(update);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(29:4) <Fade {isOpen} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let fade;
    	let current;
    	let if_block0 = /*isOpen*/ ctx[0] && create_if_block_1(ctx);
    	let if_block1 = !/*isOpen*/ ctx[0] && create_if_block$1(ctx);

    	fade = new Fade({
    			props: {
    				isOpen: /*isOpen*/ ctx[0],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			create_component(fade.$$.fragment);
    			add_location(div0, file$5, 14, 0, 395);
    			attr_dev(div1, "class", "col-md-9  offset-md-2");
    			add_location(div1, file$5, 27, 0, 648);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(fade, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isOpen*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const fade_changes = {};
    			if (dirty & /*isOpen*/ 1) fade_changes.isOpen = /*isOpen*/ ctx[0];

    			if (dirty & /*$$scope*/ 4) {
    				fade_changes.$$scope = { dirty, ctx };
    			}

    			fade.$set(fade_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(fade.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(fade.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(fade);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OpenUpdate', slots, []);
    	let isOpen = true;

    	function handleClick() {
    		$$invalidate(0, isOpen = !isOpen);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OpenUpdate> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Fade,
    		Button: Button$1,
    		BatchRun,
    		Update,
    		isOpen,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isOpen, handleClick];
    }

    class OpenUpdate extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OpenUpdate",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src/Create/Create_Components.svelte generated by Svelte v3.40.3 */

    function create_fragment$8(ctx) {
    	let opencollectionrun;
    	let t0;
    	let opengeneralnotes;
    	let t1;
    	let batchinfo;
    	let t2;
    	let openbatchrun;
    	let t3;
    	let openuploadedsofar;
    	let t4;
    	let openupdate;
    	let current;
    	opencollectionrun = new OpenCollectionRun({ $$inline: true });
    	opengeneralnotes = new OpenGeneralNotes({ $$inline: true });
    	batchinfo = new Batch_Info({ $$inline: true });
    	openbatchrun = new OpenBatchRun({ $$inline: true });
    	openuploadedsofar = new OpenUploadedSoFar({ $$inline: true });
    	openupdate = new OpenUpdate({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(opencollectionrun.$$.fragment);
    			t0 = space();
    			create_component(opengeneralnotes.$$.fragment);
    			t1 = space();
    			create_component(batchinfo.$$.fragment);
    			t2 = space();
    			create_component(openbatchrun.$$.fragment);
    			t3 = space();
    			create_component(openuploadedsofar.$$.fragment);
    			t4 = space();
    			create_component(openupdate.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(opencollectionrun, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(opengeneralnotes, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(batchinfo, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(openbatchrun, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(openuploadedsofar, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(openupdate, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(opencollectionrun.$$.fragment, local);
    			transition_in(opengeneralnotes.$$.fragment, local);
    			transition_in(batchinfo.$$.fragment, local);
    			transition_in(openbatchrun.$$.fragment, local);
    			transition_in(openuploadedsofar.$$.fragment, local);
    			transition_in(openupdate.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(opencollectionrun.$$.fragment, local);
    			transition_out(opengeneralnotes.$$.fragment, local);
    			transition_out(batchinfo.$$.fragment, local);
    			transition_out(openbatchrun.$$.fragment, local);
    			transition_out(openuploadedsofar.$$.fragment, local);
    			transition_out(openupdate.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(opencollectionrun, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(opengeneralnotes, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(batchinfo, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(openbatchrun, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(openuploadedsofar, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(openupdate, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Create_Components', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Create_Components> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		BatchInfo: Batch_Info,
    		ConnectToMachine,
    		OpenGeneralNotes,
    		OpenBatchRun,
    		OpenUploadedSoFar,
    		OpenCollectionRun,
    		OpenUpdate
    	});

    	return [];
    }

    class Create_Components extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Create_Components",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src/Create/Create.svelte generated by Svelte v3.40.3 */

    const { console: console_1 } = globals;
    const file$4 = "src/Create/Create.svelte";

    // (434:44) <Badge class= "align-top" color = "info">
    function create_default_slot_3$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Not Connected");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(434:44) <Badge class= \\\"align-top\\\" color = \\\"info\\\">",
    		ctx
    	});

    	return block;
    }

    // (437:43) <Badge class= "align-top text-wrap" color = "info">
    function create_default_slot_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*$next_step*/ ctx[4]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$next_step*/ 16) set_data_dev(t, /*$next_step*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(437:43) <Badge class= \\\"align-top text-wrap\\\" color = \\\"info\\\">",
    		ctx
    	});

    	return block;
    }

    // (438:66) <Badge class= "align-top text-wrap" color = "info">
    function create_default_slot_1$1(ctx) {
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text(/*$contaminants*/ ctx[3]);
    			t1 = text(" / ");
    			t2 = text(/*$no_contaminants*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$contaminants*/ 8) set_data_dev(t0, /*$contaminants*/ ctx[3]);
    			if (dirty[0] & /*$no_contaminants*/ 4) set_data_dev(t2, /*$no_contaminants*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(438:66) <Badge class= \\\"align-top text-wrap\\\" color = \\\"info\\\">",
    		ctx
    	});

    	return block;
    }

    // (439:54) <Badge class= "align-top" color = "info">
    function create_default_slot$2(ctx) {
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text(/*$number_of_jobs_left*/ ctx[1]);
    			t1 = text(" - ");
    			t2 = text(/*$process_to_finish*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$number_of_jobs_left*/ 2) set_data_dev(t0, /*$number_of_jobs_left*/ ctx[1]);
    			if (dirty[0] & /*$process_to_finish*/ 1) set_data_dev(t2, /*$process_to_finish*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(439:54) <Badge class= \\\"align-top\\\" color = \\\"info\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let head;
    	let link;
    	let t0;
    	let div4;
    	let div0;
    	let h60;
    	let t1;
    	let badge0;
    	let t2;
    	let div1;
    	let h61;
    	let t3;
    	let badge1;
    	let t4;
    	let div2;
    	let h62;
    	let t5;
    	let badge2;
    	let t6;
    	let div3;
    	let h63;
    	let t7;
    	let badge3;
    	let t8;
    	let create_components;
    	let current;

    	badge0 = new Badge({
    			props: {
    				class: "align-top",
    				color: "info",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge1 = new Badge({
    			props: {
    				class: "align-top text-wrap",
    				color: "info",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge2 = new Badge({
    			props: {
    				class: "align-top text-wrap",
    				color: "info",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge3 = new Badge({
    			props: {
    				class: "align-top",
    				color: "info",
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	create_components = new Create_Components({ $$inline: true });

    	const block = {
    		c: function create() {
    			head = element("head");
    			link = element("link");
    			t0 = space();
    			div4 = element("div");
    			div0 = element("div");
    			h60 = element("h6");
    			t1 = text("Connection: ");
    			create_component(badge0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			h61 = element("h6");
    			t3 = text("Next Step: ");
    			create_component(badge1.$$.fragment);
    			t4 = space();
    			div2 = element("div");
    			h62 = element("h6");
    			t5 = text("Images With/Without Contaminants: ");
    			create_component(badge2.$$.fragment);
    			t6 = space();
    			div3 = element("div");
    			h63 = element("h6");
    			t7 = text("Processing Jobs Left: ");
    			create_component(badge3.$$.fragment);
    			t8 = space();
    			create_component(create_components.$$.fragment);
    			attr_dev(link, "href", "https://fonts.googleapis.com/icon?family=Material+Icons");
    			attr_dev(link, "rel", "stylesheet");
    			add_location(link, file$4, 420, 4, 17914);
    			add_location(head, file$4, 419, 0, 17903);
    			add_location(h60, file$4, 433, 27, 18257);
    			attr_dev(div0, "class", "col-md-1 ");
    			add_location(div0, file$4, 433, 4, 18234);
    			add_location(h61, file$4, 436, 27, 18635);
    			attr_dev(div1, "class", "col-md-3 ");
    			add_location(div1, file$4, 436, 4, 18612);
    			add_location(h62, file$4, 437, 27, 18761);
    			attr_dev(div2, "class", "col-md-2 ");
    			add_location(div2, file$4, 437, 4, 18738);
    			add_location(h63, file$4, 438, 27, 18934);
    			attr_dev(div3, "class", "col-md-2 ");
    			add_location(div3, file$4, 438, 4, 18911);
    			attr_dev(div4, "class", "row align-items-center offset-md-2 col-md-12 text-center border-top border-bottom pt-4 pb-4");
    			add_location(div4, file$4, 428, 0, 18104);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, head, anchor);
    			append_dev(head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div0, h60);
    			append_dev(h60, t1);
    			mount_component(badge0, h60, null);
    			append_dev(div4, t2);
    			append_dev(div4, div1);
    			append_dev(div1, h61);
    			append_dev(h61, t3);
    			mount_component(badge1, h61, null);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			append_dev(div2, h62);
    			append_dev(h62, t5);
    			mount_component(badge2, h62, null);
    			append_dev(div4, t6);
    			append_dev(div4, div3);
    			append_dev(div3, h63);
    			append_dev(h63, t7);
    			mount_component(badge3, h63, null);
    			insert_dev(target, t8, anchor);
    			mount_component(create_components, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge0_changes = {};

    			if (dirty[1] & /*$$scope*/ 65536) {
    				badge0_changes.$$scope = { dirty, ctx };
    			}

    			badge0.$set(badge0_changes);
    			const badge1_changes = {};

    			if (dirty[0] & /*$next_step*/ 16 | dirty[1] & /*$$scope*/ 65536) {
    				badge1_changes.$$scope = { dirty, ctx };
    			}

    			badge1.$set(badge1_changes);
    			const badge2_changes = {};

    			if (dirty[0] & /*$no_contaminants, $contaminants*/ 12 | dirty[1] & /*$$scope*/ 65536) {
    				badge2_changes.$$scope = { dirty, ctx };
    			}

    			badge2.$set(badge2_changes);
    			const badge3_changes = {};

    			if (dirty[0] & /*$process_to_finish, $number_of_jobs_left*/ 3 | dirty[1] & /*$$scope*/ 65536) {
    				badge3_changes.$$scope = { dirty, ctx };
    			}

    			badge3.$set(badge3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge0.$$.fragment, local);
    			transition_in(badge1.$$.fragment, local);
    			transition_in(badge2.$$.fragment, local);
    			transition_in(badge3.$$.fragment, local);
    			transition_in(create_components.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge0.$$.fragment, local);
    			transition_out(badge1.$$.fragment, local);
    			transition_out(badge2.$$.fragment, local);
    			transition_out(badge3.$$.fragment, local);
    			transition_out(create_components.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(head);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div4);
    			destroy_component(badge0);
    			destroy_component(badge1);
    			destroy_component(badge2);
    			destroy_component(badge3);
    			if (detaching) detach_dev(t8);
    			destroy_component(create_components, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $completed_batches;
    	let $is_clicked_end_collection;
    	let $is_clicked_begin_collection;
    	let $is_Clicked_start;
    	let $is_Clicked_end;
    	let $local_collection_id;
    	let $completed_collection;
    	let $ready_to_work;
    	let $collection_running;
    	let $ready_to_end_batch_boolean;
    	let $button_alert_change;
    	let $ready_to_end_batch;
    	let $product_weight;
    	let $product_container;
    	let $product_type;
    	let $machine_location;
    	let $showProcessDialog;
    	let $completed_batches_update_ready;
    	let $ending_collection;
    	let $fetching_images;
    	let $send_end_collection_delete_batches;
    	let $completed_collections;
    	let $batches_left_to_process;
    	let $process_to_finish;
    	let $number_of_jobs_left;
    	let $ready_to_end_collection;
    	let $create_mode_dir;
    	let $no_contaminants;
    	let $contaminants;
    	let $is_user_selected;
    	let $is_product_selected;
    	let $is_company_selected;
    	let $next_step;
    	let $batch_collection;
    	let $matching_user_names;
    	let $matching_product_names;
    	let $matching_company_names;
    	let $batch_number;
    	validate_store(completed_batches, 'completed_batches');
    	component_subscribe($$self, completed_batches, $$value => $$invalidate(8, $completed_batches = $$value));
    	validate_store(is_clicked_end_collection, 'is_clicked_end_collection');
    	component_subscribe($$self, is_clicked_end_collection, $$value => $$invalidate(9, $is_clicked_end_collection = $$value));
    	validate_store(is_clicked_begin_collection, 'is_clicked_begin_collection');
    	component_subscribe($$self, is_clicked_begin_collection, $$value => $$invalidate(10, $is_clicked_begin_collection = $$value));
    	validate_store(is_Clicked_start, 'is_Clicked_start');
    	component_subscribe($$self, is_Clicked_start, $$value => $$invalidate(11, $is_Clicked_start = $$value));
    	validate_store(is_Clicked_end, 'is_Clicked_end');
    	component_subscribe($$self, is_Clicked_end, $$value => $$invalidate(12, $is_Clicked_end = $$value));
    	validate_store(local_collection_id, 'local_collection_id');
    	component_subscribe($$self, local_collection_id, $$value => $$invalidate(13, $local_collection_id = $$value));
    	validate_store(completed_collection, 'completed_collection');
    	component_subscribe($$self, completed_collection, $$value => $$invalidate(14, $completed_collection = $$value));
    	validate_store(ready_to_work, 'ready_to_work');
    	component_subscribe($$self, ready_to_work, $$value => $$invalidate(15, $ready_to_work = $$value));
    	validate_store(collection_running, 'collection_running');
    	component_subscribe($$self, collection_running, $$value => $$invalidate(16, $collection_running = $$value));
    	validate_store(ready_to_end_batch_boolean, 'ready_to_end_batch_boolean');
    	component_subscribe($$self, ready_to_end_batch_boolean, $$value => $$invalidate(17, $ready_to_end_batch_boolean = $$value));
    	validate_store(button_alert_change, 'button_alert_change');
    	component_subscribe($$self, button_alert_change, $$value => $$invalidate(18, $button_alert_change = $$value));
    	validate_store(ready_to_end_batch, 'ready_to_end_batch');
    	component_subscribe($$self, ready_to_end_batch, $$value => $$invalidate(19, $ready_to_end_batch = $$value));
    	validate_store(product_weight, 'product_weight');
    	component_subscribe($$self, product_weight, $$value => $$invalidate(20, $product_weight = $$value));
    	validate_store(product_container, 'product_container');
    	component_subscribe($$self, product_container, $$value => $$invalidate(21, $product_container = $$value));
    	validate_store(product_type, 'product_type');
    	component_subscribe($$self, product_type, $$value => $$invalidate(22, $product_type = $$value));
    	validate_store(machine_location, 'machine_location');
    	component_subscribe($$self, machine_location, $$value => $$invalidate(23, $machine_location = $$value));
    	validate_store(showProcessDialog, 'showProcessDialog');
    	component_subscribe($$self, showProcessDialog, $$value => $$invalidate(24, $showProcessDialog = $$value));
    	validate_store(completed_batches_update_ready, 'completed_batches_update_ready');
    	component_subscribe($$self, completed_batches_update_ready, $$value => $$invalidate(25, $completed_batches_update_ready = $$value));
    	validate_store(ending_collection, 'ending_collection');
    	component_subscribe($$self, ending_collection, $$value => $$invalidate(26, $ending_collection = $$value));
    	validate_store(fetching_images, 'fetching_images');
    	component_subscribe($$self, fetching_images, $$value => $$invalidate(27, $fetching_images = $$value));
    	validate_store(send_end_collection_delete_batches, 'send_end_collection_delete_batches');
    	component_subscribe($$self, send_end_collection_delete_batches, $$value => $$invalidate(28, $send_end_collection_delete_batches = $$value));
    	validate_store(completed_collections, 'completed_collections');
    	component_subscribe($$self, completed_collections, $$value => $$invalidate(29, $completed_collections = $$value));
    	validate_store(batches_left_to_process, 'batches_left_to_process');
    	component_subscribe($$self, batches_left_to_process, $$value => $$invalidate(30, $batches_left_to_process = $$value));
    	validate_store(process_to_finish, 'process_to_finish');
    	component_subscribe($$self, process_to_finish, $$value => $$invalidate(0, $process_to_finish = $$value));
    	validate_store(number_of_jobs_left, 'number_of_jobs_left');
    	component_subscribe($$self, number_of_jobs_left, $$value => $$invalidate(1, $number_of_jobs_left = $$value));
    	validate_store(ready_to_end_collection, 'ready_to_end_collection');
    	component_subscribe($$self, ready_to_end_collection, $$value => $$invalidate(31, $ready_to_end_collection = $$value));
    	validate_store(create_mode_dir, 'create_mode_dir');
    	component_subscribe($$self, create_mode_dir, $$value => $$invalidate(32, $create_mode_dir = $$value));
    	validate_store(no_contaminants, 'no_contaminants');
    	component_subscribe($$self, no_contaminants, $$value => $$invalidate(2, $no_contaminants = $$value));
    	validate_store(contaminants, 'contaminants');
    	component_subscribe($$self, contaminants, $$value => $$invalidate(3, $contaminants = $$value));
    	validate_store(is_user_selected, 'is_user_selected');
    	component_subscribe($$self, is_user_selected, $$value => $$invalidate(33, $is_user_selected = $$value));
    	validate_store(is_product_selected, 'is_product_selected');
    	component_subscribe($$self, is_product_selected, $$value => $$invalidate(34, $is_product_selected = $$value));
    	validate_store(is_company_selected, 'is_company_selected');
    	component_subscribe($$self, is_company_selected, $$value => $$invalidate(35, $is_company_selected = $$value));
    	validate_store(next_step, 'next_step');
    	component_subscribe($$self, next_step, $$value => $$invalidate(4, $next_step = $$value));
    	validate_store(batch_collection, 'batch_collection');
    	component_subscribe($$self, batch_collection, $$value => $$invalidate(36, $batch_collection = $$value));
    	validate_store(matching_user_names, 'matching_user_names');
    	component_subscribe($$self, matching_user_names, $$value => $$invalidate(37, $matching_user_names = $$value));
    	validate_store(matching_product_names, 'matching_product_names');
    	component_subscribe($$self, matching_product_names, $$value => $$invalidate(38, $matching_product_names = $$value));
    	validate_store(matching_company_names, 'matching_company_names');
    	component_subscribe($$self, matching_company_names, $$value => $$invalidate(39, $matching_company_names = $$value));
    	validate_store(batch_number, 'batch_number');
    	component_subscribe($$self, batch_number, $$value => $$invalidate(40, $batch_number = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Create', slots, []);

    	async function goGetEm() {
    		console.log("goGetEm");
    		const response = await fetch("/get_create_database");
    		console.log("data create response", response);
    		const create_database = await response.json();
    		console.log("data create", create_database);
    		set_store_value(batch_number, $batch_number = create_database.batch_number, $batch_number);
    		set_store_value(matching_company_names, $matching_company_names = create_database.matching_company_names, $matching_company_names);
    		set_store_value(matching_product_names, $matching_product_names = create_database.matching_product_names, $matching_product_names);
    		set_store_value(matching_user_names, $matching_user_names = create_database.matching_user_names, $matching_user_names);
    		set_store_value(batch_collection, $batch_collection = create_database.batch_collection, $batch_collection);
    		set_store_value(next_step, $next_step = create_database.next_step, $next_step);
    		set_store_value(ready_to_end_batch, $ready_to_end_batch = create_database.ready_to_end_batch, $ready_to_end_batch);
    		set_store_value(is_company_selected, $is_company_selected = create_database.is_company_selected, $is_company_selected);
    		set_store_value(is_product_selected, $is_product_selected = create_database.is_product_selected, $is_product_selected);
    		set_store_value(is_user_selected, $is_user_selected = create_database.is_user_selected, $is_user_selected);
    		set_store_value(contaminants, $contaminants = create_database.contaminants, $contaminants);
    		set_store_value(no_contaminants, $no_contaminants = create_database.no_contaminants, $no_contaminants);
    		set_store_value(create_mode_dir, $create_mode_dir = create_database.create_mode_dir, $create_mode_dir);
    		set_store_value(ready_to_end_collection, $ready_to_end_collection = create_database.ready_to_end_collection, $ready_to_end_collection);
    		set_store_value(number_of_jobs_left, $number_of_jobs_left = create_database.number_of_jobs_left, $number_of_jobs_left);
    		set_store_value(process_to_finish, $process_to_finish = create_database.process_to_finish, $process_to_finish);
    		set_store_value(ready_to_work, $ready_to_work = create_database.ready_to_work, $ready_to_work);
    		(set_store_value(collection_running, $collection_running = create_database.collection_running, $collection_running), set_store_value(batches_left_to_process, $batches_left_to_process = create_database.batches_left_to_process, $batches_left_to_process));
    		set_store_value(completed_collections, $completed_collections = create_database.completed_collections, $completed_collections);
    		set_store_value(send_end_collection_delete_batches, $send_end_collection_delete_batches = create_database.send_end_collection_delete_batches, $send_end_collection_delete_batches);
    		set_store_value(fetching_images, $fetching_images = create_database.fetching_images, $fetching_images);
    		set_store_value(ending_collection, $ending_collection = create_database.ending_collection, $ending_collection);
    		set_store_value(completed_batches_update_ready, $completed_batches_update_ready = create_database.completed_batches_update_ready, $completed_batches_update_ready);
    	}

    	// promise = response.json()
    	//     promise = create_database()
    	//     console.log("create_database", create_database)
    	// }
    	// let promise: Promise<any>;
    	// ( async() => {
    	// });
    	// $: promise
    	// let create_database = {}
    	// const {results} = await fetch("./stream").then(res => res.json())
    	// const httpServer = createServer();
    	// io = new Server(httpServer);
    	// httpServer.listen(() => {
    	//     const port = httpServer.address().port;
    	//     clientSocket = new Client(`http://localhost:${port}`)
    	// export const getSocket = async () => {
    	//   const script = document.createElement("script");
    	//   script.src = "/socket-3-0-0.js";
    	//   document.head.appendChild(script);
    	//   script.onload = () => {
    	//     const client = io()
    	//     $socket.set(client)
    	//   }
    	// }
    	// onMount(async () => {
    	//         getSocket();
    	//     } 
    	//     socket.on("blah", function() {});
    	// clientSocket = new Client('http://localhost:8000')
    	// window.jQuery(document).ready(function(){
    	// let create_database = {}
    	// const socket = io()
    	//     socket.on('create_database_update', create_database_dict =>  {
    	//     console.log("it worked", create_database_dict)
    	//     create_database = create_database_dict
    	//     console.log("create_database.ready_to_work", create_database.ready_to_work)
    	//     $ready_to_work = create_database.ready_to_work
    	// const socket = new WebSocket('ws://' + location.host + '/echo');
    	// var eventSourceCalibrate = new EventSource("/stream_calibrate");
    	// eventSourceCalibrate.onmessage = function(event) {
    	// var dataCalibrate = JSON.parse(event.data);
    	// var source = new EventSource
    	// // source.onmessage = function(event) {
    	// // var create_database_dict = JSON.parse(event.data);
    	// // console.log("it worked", create_database_dict)
    	// source.addEventListener('greeting', function(event) {
    	//     console.log("The server says " + data.message);
    	// }, false);
    	// source.addEventListener('error', function(event) {
    	//     console.log("Failed to connect to event stream. Is Redis running?");
    	// }, false);         
    	// create_database = create_database_dict
    	// console.log("create_database.ready_to_work", create_database.ready_to_work)
    	// source.addEventListener('greeting', function(event) {
    	//     alert("The server says " + data.message);
    	// }, false);
    	// source.addEventListener('error', function(event) {
    	//     alert("Failed to connect to event stream. Is Redis running?");
    	// }, false);         
    	beforeUpdate(async () => {
    		goGetEm();

    		if ($ready_to_work === true) {
    			set_store_value(showProcessDialog, $showProcessDialog = false, $showProcessDialog);
    		} else {
    			set_store_value(showProcessDialog, $showProcessDialog = true, $showProcessDialog); // console.log("$ready_to_work", $ready_to_work, "showProcessDialog",showProcessDialog)
    		} // console.log("$ready_to_work", $ready_to_work, "showProcessDialog",showProcessDialog)

    		// console.log("$collection_ids", $collection_ids)
    		ready_to_end_batch_check();

    		retrieve_completed_batches_check();
    		retrieve_completed_collection_check();
    	}); //     socket.addEventListener('message', ev => {
    	//     // console.log('<<< ' + ev.data, 'blue');
    	//   });

    	afterUpdate(async () => {
    		goGetEm();
    	});

    	// else if (!$ready_to_work){
    	//     const rw_response = await fetch("./is_ready_to_work/");
    	//     const is_ready_to_work_response = await rw_response.json();
    	//     if (is_ready_to_work_response == "ready to work"){
    	//     wait_to_process()
    	//     }
    	// }
    	// );
    	// }
    	// handleUpdate()
    	let ready_to_end_batch_boolean_check;

    	async function ready_to_end_batch_check() {
    		if ($machine_location !== "" && $product_type !== "" && $product_container !== "" && $product_weight !== "") {
    			set_store_value(ready_to_end_batch_boolean, $ready_to_end_batch_boolean = true, $ready_to_end_batch_boolean);

    			// console.log("$ready_to_end_batch_boolean", $ready_to_end_batch_boolean)
    			set_store_value(ready_to_end_batch, $ready_to_end_batch = true, $ready_to_end_batch);

    			set_store_value(button_alert_change, $button_alert_change = false, $button_alert_change);
    		} else {
    			set_store_value(ready_to_end_batch_boolean, $ready_to_end_batch_boolean = false, $ready_to_end_batch_boolean);
    		}

    		if (!ready_to_end_batch_boolean_check === $ready_to_end_batch_boolean) {
    			ready_to_end_batch_boolean_check = $ready_to_end_batch_boolean;
    			const response = await fetch("./ready_to_end_batch_check/" + $ready_to_end_batch_boolean);
    			const ready_to_end_batch_check = await response.json();
    			console.log("ready_to_end_batch_check", ready_to_end_batch_check);
    		}
    	}

    	// let length_of_completed_batches;
    	let ready_to_work_check = false;

    	//   afterUpdate(async  () => {
    	//   }
    	// send_collection_id()
    	// console.log("$completed_collections.collection_id", $completed_collections)
    	// if (showDeleteImageModal === false){
    	//   image_deleted_success = false
    	// }
    	// console.log("$completed_batches1",$completed_batches)
    	// console.log("length_of_completed_batches",length_of_completed_batches)
    	async function retrieve_completed_batches_check() {
    		if ($collection_running) {
    			// if (length_of_completed_batches !== Number($batch_number.slice(0, -5))-1) {
    			//     console.log("$batch_number", Number($batch_number.slice(0, -5))-1)
    			//     console.log("length_of_completed_batches",length_of_completed_batches)
    			//     console.log("retrieve_completed_batches")
    			//     retrieve_completed_batches()
    			// }
    			if ($ready_to_work === true) {
    				if (ready_to_work_check !== $ready_to_work) {
    					console.log("ready_to_work_check", ready_to_work_check);
    					console.log("retrieve_completed_batches");
    					ready_to_work_check = $ready_to_work;
    					retrieve_completed_batches();
    					console.log("ready_to_work_check", ready_to_work_check);
    				}
    			} else {
    				ready_to_work_check = $ready_to_work;
    			}
    		}
    	}

    	async function retrieve_completed_batches() {
    		const response = await fetch("./retrieve_completed_batches");
    		const completed_batches_response = await response.json();
    		set_store_value(completed_batches, $completed_batches = completed_batches_response.completed_batches, $completed_batches);
    		console.log("$completed_batches1", $completed_batches);
    	} //   length_of_completed_batches = $completed_batches.length

    	let ready_to_work_completed_collection_check = false;

    	async function retrieve_completed_collection_check() {
    		if (!$collection_running) {
    			if ($ready_to_work === true) {
    				if (ready_to_work_completed_collection_check !== $ready_to_work) {
    					console.log("ready_to_work_completed_collection_check", ready_to_work_completed_collection_check);
    					console.log("retrieve_completed_collection");
    					ready_to_work_completed_collection_check = $ready_to_work;
    					retrieve_completed_collection();
    					console.log("ready_to_work_completed_collection_check", ready_to_work_completed_collection_check);
    				}
    			} else {
    				ready_to_work_completed_collection_check = $ready_to_work;
    			}
    		}
    	}

    	async function retrieve_completed_collection() {
    		if ($local_collection_id) {
    			const response = await fetch("./retrieve_completed_collection/" + $local_collection_id);
    			const retrieve_completed_collection_response = await response.json();
    			console.log("retrieve_completed_collection_response.completed_collection", retrieve_completed_collection_response.completed_collection);
    			set_store_value(completed_collection, $completed_collection = retrieve_completed_collection_response.completed_collection, $completed_collection);

    			// $local_collection_id = retrieve_completed_collection_response.collection_id
    			console.log("($local_collection_id create", $local_collection_id);
    		}
    	}

    	onMount(async () => {
    		const response = await fetch("./retrieve_clicked");
    		const retrieve_clicked_response = await response.json();
    		set_store_value(is_Clicked_end, $is_Clicked_end = retrieve_clicked_response.is_Clicked_end, $is_Clicked_end);
    		set_store_value(is_Clicked_start, $is_Clicked_start = retrieve_clicked_response.is_Clicked_start, $is_Clicked_start);
    		set_store_value(is_clicked_begin_collection, $is_clicked_begin_collection = retrieve_clicked_response.is_clicked_begin_collection, $is_clicked_begin_collection);
    		set_store_value(is_clicked_end_collection, $is_clicked_end_collection = retrieve_clicked_response.is_clicked_end_collection, $is_clicked_end_collection);

    		// console.log("$collection_ids", $collection_ids)
    		retrieve_completed_collection();

    		retrieve_completed_batches();
    		console.log("$completed_batches", $completed_batches);
    	}); // const sse = new EventSource(`http://127.0.0.1:8000/stream`)
    	// sse.onmessage = (event) => {
    	// console.log("goGetEm1")
    	// let response = JSON.parse(event.data);

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Create> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		beforeUpdate,
    		onMount,
    		batch_collection,
    		matching_company_names,
    		matching_product_names,
    		matching_user_names,
    		contaminants,
    		no_contaminants,
    		batch_number,
    		next_step,
    		ready_to_end_batch,
    		is_company_selected,
    		is_product_selected,
    		is_user_selected,
    		collection_id,
    		is_clicked_begin_collection,
    		is_Clicked_end,
    		is_Clicked_start,
    		is_clicked_end_collection,
    		create_mode_dir,
    		ready_to_end_collection,
    		number_of_jobs_left,
    		process_to_finish,
    		machine_location,
    		product_type,
    		product_container,
    		product_weight,
    		button_alert_change,
    		ready_to_work,
    		collection_running,
    		batches_left_to_process,
    		completed_collections,
    		send_end_collection_delete_batches,
    		fetching_images,
    		ready_to_end_batch_boolean,
    		completed_batches_update_ready,
    		showProcessDialog,
    		completed_batches,
    		completed_collection,
    		local_collection_id,
    		ending_collection,
    		Badge,
    		Create_Components,
    		goGetEm,
    		ready_to_end_batch_boolean_check,
    		ready_to_end_batch_check,
    		ready_to_work_check,
    		retrieve_completed_batches_check,
    		retrieve_completed_batches,
    		ready_to_work_completed_collection_check,
    		retrieve_completed_collection_check,
    		retrieve_completed_collection,
    		$completed_batches,
    		$is_clicked_end_collection,
    		$is_clicked_begin_collection,
    		$is_Clicked_start,
    		$is_Clicked_end,
    		$local_collection_id,
    		$completed_collection,
    		$ready_to_work,
    		$collection_running,
    		$ready_to_end_batch_boolean,
    		$button_alert_change,
    		$ready_to_end_batch,
    		$product_weight,
    		$product_container,
    		$product_type,
    		$machine_location,
    		$showProcessDialog,
    		$completed_batches_update_ready,
    		$ending_collection,
    		$fetching_images,
    		$send_end_collection_delete_batches,
    		$completed_collections,
    		$batches_left_to_process,
    		$process_to_finish,
    		$number_of_jobs_left,
    		$ready_to_end_collection,
    		$create_mode_dir,
    		$no_contaminants,
    		$contaminants,
    		$is_user_selected,
    		$is_product_selected,
    		$is_company_selected,
    		$next_step,
    		$batch_collection,
    		$matching_user_names,
    		$matching_product_names,
    		$matching_company_names,
    		$batch_number
    	});

    	$$self.$inject_state = $$props => {
    		if ('ready_to_end_batch_boolean_check' in $$props) ready_to_end_batch_boolean_check = $$props.ready_to_end_batch_boolean_check;
    		if ('ready_to_work_check' in $$props) ready_to_work_check = $$props.ready_to_work_check;
    		if ('ready_to_work_completed_collection_check' in $$props) ready_to_work_completed_collection_check = $$props.ready_to_work_completed_collection_check;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		$process_to_finish,
    		$number_of_jobs_left,
    		$no_contaminants,
    		$contaminants,
    		$next_step
    	];
    }

    class Create extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Create",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src/Search/Search.svelte generated by Svelte v3.40.3 */

    function create_fragment$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Search functionality is currently being built");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Search', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Search> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Search extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Search",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    // Settings Page
    const image_mode = writable("sim");
    const storage_folder = writable("");
    // export const image_quality = writable("jpg");

    /* src/Settings/Create_mode.svelte generated by Svelte v3.40.3 */
    const file$3 = "src/Settings/Create_mode.svelte";

    // (33:0) {#if $image_mode === "prod"}
    function create_if_block(ctx) {
    	let div;
    	let connect;
    	let current;
    	connect = new Connect({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(connect.$$.fragment);
    			attr_dev(div, "class", "offset-md-2 pt-4 pb-4 text-center");
    			add_location(div, file$3, 33, 0, 1045);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(connect, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(connect.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(connect.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(connect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(33:0) {#if $image_mode === \\\"prod\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div4;
    	let div3;
    	let div0;
    	let h5;
    	let t1;
    	let div1;
    	let label0;
    	let input0;
    	let t2;
    	let h60;
    	let t4;
    	let div2;
    	let label1;
    	let input1;
    	let t5;
    	let h61;
    	let t7;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*$image_mode*/ ctx[0] === "prod" && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Create Mode:";
    			t1 = space();
    			div1 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t2 = space();
    			h60 = element("h6");
    			h60.textContent = "Simulation";
    			t4 = space();
    			div2 = element("div");
    			label1 = element("label");
    			input1 = element("input");
    			t5 = space();
    			h61 = element("h6");
    			h61.textContent = "Production";
    			t7 = space();
    			if (if_block) if_block.c();
    			add_location(h5, file$3, 20, 34, 597);
    			attr_dev(div0, "class", "col-md-2 text-center");
    			add_location(div0, file$3, 20, 0, 563);
    			attr_dev(input0, "type", "radio");
    			input0.__value = "sim";
    			input0.value = input0.__value;
    			/*$$binding_groups*/ ctx[3][0].push(input0);
    			add_location(input0, file$3, 23, 8, 680);
    			add_location(h60, file$3, 23, 104, 776);
    			add_location(label0, file$3, 22, 4, 664);
    			attr_dev(div1, "class", "col-md-1 text-center");
    			add_location(div1, file$3, 21, 0, 625);
    			attr_dev(input1, "type", "radio");
    			input1.__value = "prod";
    			input1.value = input1.__value;
    			/*$$binding_groups*/ ctx[3][0].push(input1);
    			add_location(input1, file$3, 28, 8, 871);
    			add_location(h61, file$3, 28, 106, 969);
    			add_location(label1, file$3, 27, 4, 855);
    			attr_dev(div2, "class", "col-md-1 text-center");
    			add_location(div2, file$3, 26, 0, 816);
    			attr_dev(div3, "class", "offset-md-2 row align-items-center");
    			add_location(div3, file$3, 19, 0, 513);
    			attr_dev(div4, "class", "border-top border-bottom pt-8 pb-8");
    			add_location(div4, file$3, 18, 0, 462);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, h5);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, label0);
    			append_dev(label0, input0);
    			input0.checked = input0.__value === /*$image_mode*/ ctx[0];
    			append_dev(label0, t2);
    			append_dev(label0, h60);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, label1);
    			append_dev(label1, input1);
    			input1.checked = input1.__value === /*$image_mode*/ ctx[0];
    			append_dev(label1, t5);
    			append_dev(label1, h61);
    			append_dev(div4, t7);
    			if (if_block) if_block.m(div4, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[2]),
    					listen_dev(input0, "change", /*change_handler*/ ctx[4], false, false, false),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[5]),
    					listen_dev(input1, "change", /*change_handler_1*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$image_mode*/ 1) {
    				input0.checked = input0.__value === /*$image_mode*/ ctx[0];
    			}

    			if (dirty & /*$image_mode*/ 1) {
    				input1.checked = input1.__value === /*$image_mode*/ ctx[0];
    			}

    			if (/*$image_mode*/ ctx[0] === "prod") {
    				if (if_block) {
    					if (dirty & /*$image_mode*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div4, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			/*$$binding_groups*/ ctx[3][0].splice(/*$$binding_groups*/ ctx[3][0].indexOf(input0), 1);
    			/*$$binding_groups*/ ctx[3][0].splice(/*$$binding_groups*/ ctx[3][0].indexOf(input1), 1);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $image_mode;
    	validate_store(image_mode, 'image_mode');
    	component_subscribe($$self, image_mode, $$value => $$invalidate(0, $image_mode = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Create_mode', slots, []);

    	function image_mode_change() {
    		if ($image_mode === "sim") {
    			fetch("./image_mode_change/" + "sim").then(d => d.text());
    		} else if ($image_mode === "prod") {
    			fetch("./image_mode_change/" + "prod").then(d => d.text());
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Create_mode> was created with unknown prop '${key}'`);
    	});

    	const $$binding_groups = [[]];

    	function input0_change_handler() {
    		$image_mode = this.__value;
    		image_mode.set($image_mode);
    	}

    	const change_handler = () => image_mode_change;

    	function input1_change_handler() {
    		$image_mode = this.__value;
    		image_mode.set($image_mode);
    	}

    	const change_handler_1 = () => image_mode_change;

    	$$self.$capture_state = () => ({
    		Connect,
    		image_mode,
    		image_mode_change,
    		$image_mode
    	});

    	return [
    		$image_mode,
    		image_mode_change,
    		input0_change_handler,
    		$$binding_groups,
    		change_handler,
    		input1_change_handler,
    		change_handler_1
    	];
    }

    class Create_mode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Create_mode",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src/Settings/Storage.svelte generated by Svelte v3.40.3 */
    const file$2 = "src/Settings/Storage.svelte";

    // (55:43) <Badge class= "align-top" color = "info">
    function create_default_slot$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*change_outcome_txt*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*change_outcome_txt*/ 1) set_data_dev(t, /*change_outcome_txt*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(55:43) <Badge class= \\\"align-top\\\" color = \\\"info\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div5;
    	let div2;
    	let div0;
    	let h5;
    	let t1;
    	let div1;
    	let textfield;
    	let updating_value;
    	let t2;
    	let div4;
    	let div3;
    	let h7;
    	let badge;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[3](value);
    	}

    	let textfield_props = {
    		color: "blue",
    		placeholder: "Copy Dropbox Database folder path here",
    		label: "Dropbox Database",
    		outlined: true
    	};

    	if (/*$storage_folder*/ ctx[1] !== void 0) {
    		textfield_props.value = /*$storage_folder*/ ctx[1];
    	}

    	textfield = new TextField({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));
    	textfield.$on("change", /*change_storage_folder*/ ctx[2]);

    	badge = new Badge({
    			props: {
    				class: "align-top",
    				color: "info",
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Storage:";
    			t1 = space();
    			div1 = element("div");
    			create_component(textfield.$$.fragment);
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			h7 = element("h7");
    			create_component(badge.$$.fragment);
    			add_location(h5, file$2, 48, 42, 1594);
    			attr_dev(div0, "class", "col-md-2 text-center");
    			add_location(div0, file$2, 48, 8, 1560);
    			attr_dev(div1, "class", " col-md-4 ");
    			add_location(div1, file$2, 49, 8, 1626);
    			attr_dev(div2, "class", "offset-md-2 row align-items-center");
    			add_location(div2, file$2, 47, 4, 1499);
    			add_location(h7, file$2, 54, 39, 1959);
    			attr_dev(div3, "class", "offset-md-2 col-md-4 ");
    			add_location(div3, file$2, 54, 4, 1924);
    			attr_dev(div4, "class", "offset-md-2 row align-items-center");
    			add_location(div4, file$2, 53, 4, 1869);
    			attr_dev(div5, "class", "border-bottom pt-8 pb-12");
    			add_location(div5, file$2, 46, 0, 1454);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div2);
    			append_dev(div2, div0);
    			append_dev(div0, h5);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(textfield, div1, null);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, h7);
    			mount_component(badge, h7, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const textfield_changes = {};

    			if (!updating_value && dirty & /*$storage_folder*/ 2) {
    				updating_value = true;
    				textfield_changes.value = /*$storage_folder*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    			const badge_changes = {};

    			if (dirty & /*$$scope, change_outcome_txt*/ 65) {
    				badge_changes.$$scope = { dirty, ctx };
    			}

    			badge.$set(badge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(textfield);
    			destroy_component(badge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $storage_folder;
    	validate_store(storage_folder, 'storage_folder');
    	component_subscribe($$self, storage_folder, $$value => $$invalidate(1, $storage_folder = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Storage', slots, []);
    	let storage_folder_text;
    	let storage_folder_save_str;
    	let change_outcome_txt;

    	// function setAttributeWebkitdirectory(node) {
    	// node.setAttribute('webkitdirectory', '');
    	// }
    	async function change_storage_folder() {
    		if ($storage_folder.charAt(0) === "/") {
    			storage_folder_save_str = $storage_folder.slice(1);
    		} else {
    			storage_folder_save_str = $storage_folder; // console.log("storage_folder_save_str changed", storage_folder_save_str)
    		} // console.log("storage_folder_save_str not changed", storage_folder_save_str)

    		const response = await fetch("./save_dropbox_path/" + storage_folder_save_str);
    		const change_outcome = await response.json();

    		// console.log(change_outcome);
    		$$invalidate(0, change_outcome_txt = change_outcome);
    	}

    	onMount(async () => {
    		await fetch("./get_dropbox_path").then(d => d.text()).then(d => JSON.parse(d)).then(d => storage_folder_text = d);

    		// console.log(storage_folder_text)
    		set_store_value(storage_folder, $storage_folder = storage_folder_text, $storage_folder);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Storage> was created with unknown prop '${key}'`);
    	});

    	function textfield_value_binding(value) {
    		$storage_folder = value;
    		storage_folder.set($storage_folder);
    	}

    	$$self.$capture_state = () => ({
    		Connect,
    		storage_folder,
    		onMount,
    		TextField,
    		Button,
    		Badge,
    		storage_folder_text,
    		storage_folder_save_str,
    		change_outcome_txt,
    		change_storage_folder,
    		$storage_folder
    	});

    	$$self.$inject_state = $$props => {
    		if ('storage_folder_text' in $$props) storage_folder_text = $$props.storage_folder_text;
    		if ('storage_folder_save_str' in $$props) storage_folder_save_str = $$props.storage_folder_save_str;
    		if ('change_outcome_txt' in $$props) $$invalidate(0, change_outcome_txt = $$props.change_outcome_txt);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(0, change_outcome_txt = "");

    	return [
    		change_outcome_txt,
    		$storage_folder,
    		change_storage_folder,
    		textfield_value_binding
    	];
    }

    class Storage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Storage",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src/Settings/Image_quality.svelte generated by Svelte v3.40.3 */
    const file$1 = "src/Settings/Image_quality.svelte";

    function create_fragment$3(ctx) {
    	let div4;
    	let div3;
    	let div0;
    	let h5;
    	let t1;
    	let div1;
    	let label0;
    	let input0;
    	let t2;
    	let h60;
    	let h61;
    	let h62;
    	let t6;
    	let div2;
    	let label1;
    	let input1;
    	let t7;
    	let h63;
    	let h64;
    	let h65;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Image Quality:";
    			t1 = space();
    			div1 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t2 = space();
    			h60 = element("h6");
    			h60.textContent = "Jpg";
    			h61 = element("h6");
    			h61.textContent = "Lower Quality";
    			h62 = element("h6");
    			h62.textContent = "Faster";
    			t6 = space();
    			div2 = element("div");
    			label1 = element("label");
    			input1 = element("input");
    			t7 = space();
    			h63 = element("h6");
    			h63.textContent = "Png";
    			h64 = element("h6");
    			h64.textContent = "Higher Quality";
    			h65 = element("h6");
    			h65.textContent = "Slower";
    			add_location(h5, file$1, 20, 34, 590);
    			attr_dev(div0, "class", "col-md-2 text-center");
    			add_location(div0, file$1, 20, 0, 556);
    			attr_dev(input0, "type", "radio");
    			input0.__value = "jpg";
    			input0.value = input0.__value;
    			/*$$binding_groups*/ ctx[2][0].push(input0);
    			add_location(input0, file$1, 23, 8, 675);
    			add_location(h60, file$1, 23, 71, 738);
    			add_location(h61, file$1, 23, 83, 750);
    			add_location(h62, file$1, 23, 106, 773);
    			add_location(label0, file$1, 22, 4, 659);
    			attr_dev(div1, "class", "col-md-2 text-center");
    			add_location(div1, file$1, 21, 0, 620);
    			attr_dev(input1, "type", "radio");
    			input1.__value = "png";
    			input1.value = input1.__value;
    			/*$$binding_groups*/ ctx[2][0].push(input1);
    			add_location(input1, file$1, 28, 8, 864);
    			add_location(h63, file$1, 28, 73, 929);
    			add_location(h64, file$1, 28, 85, 941);
    			add_location(h65, file$1, 28, 109, 965);
    			add_location(label1, file$1, 27, 4, 848);
    			attr_dev(div2, "class", "col-md-2 text-center");
    			add_location(div2, file$1, 26, 0, 809);
    			attr_dev(div3, "class", "offset-md-2 row align-items-center");
    			add_location(div3, file$1, 19, 0, 506);
    			attr_dev(div4, "class", "border-top border-bottom pt-8 pb-8");
    			add_location(div4, file$1, 18, 0, 455);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, h5);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, label0);
    			append_dev(label0, input0);
    			input0.checked = input0.__value === /*$image_quality*/ ctx[0];
    			append_dev(label0, t2);
    			append_dev(label0, h60);
    			append_dev(label0, h61);
    			append_dev(label0, h62);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			append_dev(div2, label1);
    			append_dev(label1, input1);
    			input1.checked = input1.__value === /*$image_quality*/ ctx[0];
    			append_dev(label1, t7);
    			append_dev(label1, h63);
    			append_dev(label1, h64);
    			append_dev(label1, h65);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[1]),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[3])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$image_quality*/ 1) {
    				input0.checked = input0.__value === /*$image_quality*/ ctx[0];
    			}

    			if (dirty & /*$image_quality*/ 1) {
    				input1.checked = input1.__value === /*$image_quality*/ ctx[0];
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			/*$$binding_groups*/ ctx[2][0].splice(/*$$binding_groups*/ ctx[2][0].indexOf(input0), 1);
    			/*$$binding_groups*/ ctx[2][0].splice(/*$$binding_groups*/ ctx[2][0].indexOf(input1), 1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $image_quality;
    	validate_store(image_quality, 'image_quality');
    	component_subscribe($$self, image_quality, $$value => $$invalidate(0, $image_quality = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Image_quality', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Image_quality> was created with unknown prop '${key}'`);
    	});

    	const $$binding_groups = [[]];

    	function input0_change_handler() {
    		$image_quality = this.__value;
    		image_quality.set($image_quality);
    	}

    	function input1_change_handler() {
    		$image_quality = this.__value;
    		image_quality.set($image_quality);
    	}

    	$$self.$capture_state = () => ({ image_quality, $image_quality });
    	return [$image_quality, input0_change_handler, $$binding_groups, input1_change_handler];
    }

    class Image_quality extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Image_quality",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/Settings/Settings.svelte generated by Svelte v3.40.3 */

    function create_fragment$2(ctx) {
    	let createmode;
    	let t0;
    	let storage;
    	let t1;
    	let imagequality;
    	let current;
    	createmode = new Create_mode({ $$inline: true });
    	storage = new Storage({ $$inline: true });
    	imagequality = new Image_quality({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(createmode.$$.fragment);
    			t0 = space();
    			create_component(storage.$$.fragment);
    			t1 = space();
    			create_component(imagequality.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(createmode, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(storage, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(imagequality, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(createmode.$$.fragment, local);
    			transition_in(storage.$$.fragment, local);
    			transition_in(imagequality.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(createmode.$$.fragment, local);
    			transition_out(storage.$$.fragment, local);
    			transition_out(imagequality.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(createmode, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(storage, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(imagequality, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Settings', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Settings> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ CreateMode: Create_mode, Storage, ImageQuality: Image_quality });
    	return [];
    }

    class Settings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Settings",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/Evaluate/Evaluate.svelte generated by Svelte v3.40.3 */

    function create_fragment$1(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Evaluate', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Evaluate> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Evaluate extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Evaluate",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.40.3 */
    const file = "src/App.svelte";

    // (58:2) <NavbarBrand href="/">
    function create_default_slot_13(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Fortress Images");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(58:2) <NavbarBrand href=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    // (63:8) <NavLink href="/#/">
    function create_default_slot_12(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Home");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(63:8) <NavLink href=\\\"/#/\\\">",
    		ctx
    	});

    	return block;
    }

    // (62:6) <NavItem>
    function create_default_slot_11(ctx) {
    	let navlink;
    	let current;

    	navlink = new NavLink({
    			props: {
    				href: "/#/",
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navlink.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navlink, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navlink_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navlink, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(62:6) <NavItem>",
    		ctx
    	});

    	return block;
    }

    // (66:8) <NavLink href="/#/evaluate">
    function create_default_slot_10(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Evaluate");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(66:8) <NavLink href=\\\"/#/evaluate\\\">",
    		ctx
    	});

    	return block;
    }

    // (65:6) <NavItem>
    function create_default_slot_9(ctx) {
    	let navlink;
    	let current;

    	navlink = new NavLink({
    			props: {
    				href: "/#/evaluate",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navlink.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navlink, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navlink_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navlink, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(65:6) <NavItem>",
    		ctx
    	});

    	return block;
    }

    // (69:8) <NavLink href="/#/search">
    function create_default_slot_8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Search");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(69:8) <NavLink href=\\\"/#/search\\\">",
    		ctx
    	});

    	return block;
    }

    // (68:6) <NavItem>
    function create_default_slot_7(ctx) {
    	let navlink;
    	let current;

    	navlink = new NavLink({
    			props: {
    				href: "/#/search",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navlink.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navlink, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navlink_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navlink, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(68:6) <NavItem>",
    		ctx
    	});

    	return block;
    }

    // (72:8) <NavLink href="/#/create">
    function create_default_slot_6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(72:8) <NavLink href=\\\"/#/create\\\">",
    		ctx
    	});

    	return block;
    }

    // (71:6) <NavItem>
    function create_default_slot_5(ctx) {
    	let navlink;
    	let current;

    	navlink = new NavLink({
    			props: {
    				href: "/#/create",
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navlink.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navlink, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navlink_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navlink, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(71:6) <NavItem>",
    		ctx
    	});

    	return block;
    }

    // (75:8) <NavLink href="/#/settings">
    function create_default_slot_4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Settings");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(75:8) <NavLink href=\\\"/#/settings\\\">",
    		ctx
    	});

    	return block;
    }

    // (74:6) <NavItem>
    function create_default_slot_3(ctx) {
    	let navlink;
    	let current;

    	navlink = new NavLink({
    			props: {
    				href: "/#/settings",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navlink.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navlink, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navlink_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navlink, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(74:6) <NavItem>",
    		ctx
    	});

    	return block;
    }

    // (61:4) <Nav class="ml-auto" navbar>
    function create_default_slot_2(ctx) {
    	let navitem0;
    	let t0;
    	let navitem1;
    	let t1;
    	let navitem2;
    	let t2;
    	let navitem3;
    	let t3;
    	let navitem4;
    	let current;

    	navitem0 = new NavItem({
    			props: {
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	navitem1 = new NavItem({
    			props: {
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	navitem2 = new NavItem({
    			props: {
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	navitem3 = new NavItem({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	navitem4 = new NavItem({
    			props: {
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navitem0.$$.fragment);
    			t0 = space();
    			create_component(navitem1.$$.fragment);
    			t1 = space();
    			create_component(navitem2.$$.fragment);
    			t2 = space();
    			create_component(navitem3.$$.fragment);
    			t3 = space();
    			create_component(navitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(navitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(navitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(navitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(navitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navitem0_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navitem0_changes.$$scope = { dirty, ctx };
    			}

    			navitem0.$set(navitem0_changes);
    			const navitem1_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navitem1_changes.$$scope = { dirty, ctx };
    			}

    			navitem1.$set(navitem1_changes);
    			const navitem2_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navitem2_changes.$$scope = { dirty, ctx };
    			}

    			navitem2.$set(navitem2_changes);
    			const navitem3_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navitem3_changes.$$scope = { dirty, ctx };
    			}

    			navitem3.$set(navitem3_changes);
    			const navitem4_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navitem4_changes.$$scope = { dirty, ctx };
    			}

    			navitem4.$set(navitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navitem0.$$.fragment, local);
    			transition_in(navitem1.$$.fragment, local);
    			transition_in(navitem2.$$.fragment, local);
    			transition_in(navitem3.$$.fragment, local);
    			transition_in(navitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navitem0.$$.fragment, local);
    			transition_out(navitem1.$$.fragment, local);
    			transition_out(navitem2.$$.fragment, local);
    			transition_out(navitem3.$$.fragment, local);
    			transition_out(navitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(navitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(navitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(navitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(navitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(61:4) <Nav class=\\\"ml-auto\\\" navbar>",
    		ctx
    	});

    	return block;
    }

    // (60:2) <Collapse {isOpen} navbar expand="md" on:update={handleUpdate}>
    function create_default_slot_1(ctx) {
    	let nav;
    	let current;

    	nav = new Nav({
    			props: {
    				class: "ml-auto",
    				navbar: true,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(60:2) <Collapse {isOpen} navbar expand=\\\"md\\\" on:update={handleUpdate}>",
    		ctx
    	});

    	return block;
    }

    // (57:0) <Navbar color="light" light expand="md">
    function create_default_slot(ctx) {
    	let navbarbrand;
    	let t0;
    	let navbartoggler;
    	let t1;
    	let collapse;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "/",
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	navbartoggler = new NavbarToggler({ $$inline: true });
    	navbartoggler.$on("click", /*click_handler*/ ctx[2]);

    	collapse = new Collapse({
    			props: {
    				isOpen: /*isOpen*/ ctx[0],
    				navbar: true,
    				expand: "md",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	collapse.$on("update", /*handleUpdate*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t0 = space();
    			create_component(navbartoggler.$$.fragment);
    			t1 = space();
    			create_component(collapse.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(navbartoggler, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(collapse, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const collapse_changes = {};
    			if (dirty & /*isOpen*/ 1) collapse_changes.isOpen = /*isOpen*/ ctx[0];

    			if (dirty & /*$$scope*/ 32) {
    				collapse_changes.$$scope = { dirty, ctx };
    			}

    			collapse.$set(collapse_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(navbartoggler.$$.fragment, local);
    			transition_in(collapse.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(navbartoggler.$$.fragment, local);
    			transition_out(collapse.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(navbartoggler, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(collapse, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(57:0) <Navbar color=\\\"light\\\" light expand=\\\"md\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let head;
    	let link;
    	let t0;
    	let navbar;
    	let t1;
    	let router;
    	let current;

    	navbar = new Navbar({
    			props: {
    				color: "light",
    				light: true,
    				expand: "md",
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	router = new Router({
    			props: {
    				routes: {
    					'/': Home,
    					'/create': Create,
    					'/search': Search,
    					'/evaluate': Evaluate,
    					'/settings': Settings
    				}
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			head = element("head");
    			link = element("link");
    			t0 = space();
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			create_component(router.$$.fragment);
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css");
    			add_location(link, file, 40, 2, 778);
    			add_location(head, file, 39, 0, 769);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, head, anchor);
    			append_dev(head, link);
    			insert_dev(target, t0, anchor);
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope, isOpen*/ 33) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(head);
    			if (detaching) detach_dev(t0);
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let isOpen = false;

    	function handleUpdate(event) {
    		$$invalidate(0, isOpen = event.detail.isOpen);
    	}

    	let rand = -1;

    	function getRand() {
    		fetch("./rand").then(d => d.text()).then(d => rand = d);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, isOpen = !isOpen);

    	$$self.$capture_state = () => ({
    		Collapse,
    		Navbar,
    		NavbarToggler,
    		NavbarBrand,
    		Nav,
    		NavItem,
    		NavLink,
    		UncontrolledDropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		isOpen,
    		handleUpdate,
    		rand,
    		getRand,
    		Router,
    		Home,
    		Create,
    		Search,
    		Settings,
    		Evaluate
    	});

    	$$self.$inject_state = $$props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    		if ('rand' in $$props) rand = $$props.rand;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isOpen, handleUpdate, click_handler];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    var app = new App({
    	target: document.body
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
